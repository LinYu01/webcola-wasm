{"version":3,"file":"cola.umd.production.min.js","sources":["../src/powergraph.ts","../src/linklengths.ts","../src/descent.ts","../src/vpsc.ts","../src/rbtree.ts","../src/rectangle.ts","../src/pqueue.ts","../src/shortestpaths.ts","../src/geom.ts","../src/handledisconnected.ts","../src/wasm/build/simd/derivative_computer_bg.js","../src/wasm/build/no_simd/derivative_computer_bg.js","../src/layout.ts","../src/wasmEngine.ts","../src/adaptor.ts","../src/d3v3adaptor.ts","../src/d3v4adaptor.ts","../src/gridrouter.ts","../src/layout3d.ts","../src/d3adaptor.ts","../src/batch.ts"],"sourcesContent":["import {LinkAccessor} from './linklengths'\n\nexport interface LinkTypeAccessor<Link> extends LinkAccessor<Link> {\n        // return a unique identifier for the type of the link\n        getType(l: Link): number;\n    }\n\n    export class PowerEdge {\n        constructor(\n            public source: any,\n            public target: any,\n            public type: number) { }\n    }\n\n    export class Configuration<Link> {\n        // canonical list of modules.\n        // Initialized to a module for each leaf node, such that the ids and indexes of the module in the array match the indexes of the nodes in links\n        // Modules created through merges are appended to the end of this.\n        modules: Module[];\n        // top level modules and candidates for merges\n        roots: ModuleSet[];\n        // remaining edge count\n        R: number;\n        constructor(n: number, edges: Link[], private linkAccessor: LinkTypeAccessor<Link>, rootGroup?: any[]) {\n            this.modules = new Array(n);\n            this.roots = [];\n            if (rootGroup) {\n                this.initModulesFromGroup(rootGroup);\n            } else {\n                this.roots.push(new ModuleSet());\n                for (var i = 0; i < n; ++i)\n                    this.roots[0].add(this.modules[i] = new Module(i));\n            }\n            this.R = edges.length;\n            edges.forEach(e => {\n                var s = this.modules[linkAccessor.getSourceIndex(e)],\n                    t = this.modules[linkAccessor.getTargetIndex(e)],\n                    type = linkAccessor.getType(e);\n                s.outgoing.add(type, t);\n                t.incoming.add(type, s);\n            });\n        }\n\n        private initModulesFromGroup(group): ModuleSet {\n            var moduleSet = new ModuleSet();\n            this.roots.push(moduleSet);\n            for (var i = 0; i < group.leaves.length; ++i) {\n                var node = group.leaves[i];\n                var module = new Module(node.id);\n                this.modules[node.id] = module;\n                moduleSet.add(module);\n            }\n            if (group.groups) {\n                for (var j = 0; j < group.groups.length; ++j) {\n                    var child = group.groups[j];\n                    // Propagate group properties (like padding, stiffness, ...) as module definition so that the generated power graph group will inherit it\n                    var definition = {};\n                    for (var prop in child)\n                        if (prop !== \"leaves\" && prop !== \"groups\" && child.hasOwnProperty(prop))\n                            definition[prop] = child[prop];\n                    // Use negative module id to avoid clashes between predefined and generated modules\n                    moduleSet.add(new Module(-1-j, new LinkSets(), new LinkSets(), this.initModulesFromGroup(child), definition));\n                }\n            }\n            return moduleSet;\n         }\n\n        // merge modules a and b keeping track of their power edges and removing the from roots\n        merge(a: Module, b: Module, k: number = 0): Module {\n            var inInt = a.incoming.intersection(b.incoming),\n                outInt = a.outgoing.intersection(b.outgoing);\n            var children = new ModuleSet();\n            children.add(a);\n            children.add(b);\n            var m = new Module(this.modules.length, outInt, inInt, children);\n            this.modules.push(m);\n            var update = (s: LinkSets, i: string, o: string) => {\n                s.forAll((ms, linktype) => {\n                    ms.forAll(n => {\n                        var nls = <LinkSets>n[i];\n                        nls.add(linktype, m);\n                        nls.remove(linktype, a);\n                        nls.remove(linktype, b);\n                        (<LinkSets>a[o]).remove(linktype, n);\n                        (<LinkSets>b[o]).remove(linktype, n);\n                    });\n                });\n            };\n            update(outInt, \"incoming\", \"outgoing\");\n            update(inInt, \"outgoing\", \"incoming\");\n            this.R -= inInt.count() + outInt.count();\n            this.roots[k].remove(a);\n            this.roots[k].remove(b);\n            this.roots[k].add(m);\n            return m;\n        }\n\n        private rootMerges(k: number = 0): {\n            id: number;\n            nEdges: number;\n            a: Module;\n            b: Module;\n        }[] {\n            var rs = this.roots[k].modules();\n            var n = rs.length;\n            var merges = new Array(n * (n - 1));\n            var ctr = 0;\n            for (var i = 0, i_ = n - 1; i < i_; ++i) {\n                for (var j = i+1; j < n; ++j) {\n                    var a = rs[i], b = rs[j];\n                    merges[ctr] = { id: ctr, nEdges: this.nEdges(a, b), a: a, b: b };\n                    ctr++;\n                }\n            }\n            return merges;\n        }\n\n        greedyMerge(): boolean {\n            for (var i = 0; i < this.roots.length; ++i) {\n                // Handle single nested module case\n                if (this.roots[i].modules().length < 2) continue;\n\n                // find the merge that allows for the most edges to be removed.  secondary ordering based on arbitrary id (for predictability)\n                var ms = this.rootMerges(i).sort((a, b) => a.nEdges == b.nEdges ? a.id - b.id : a.nEdges - b.nEdges);\n                var m = ms[0];\n                if (m.nEdges >= this.R) continue;\n                this.merge(m.a, m.b, i);\n                return true;\n            }\n        }\n\n        private nEdges(a: Module, b: Module): number {\n            var inInt = a.incoming.intersection(b.incoming),\n                outInt = a.outgoing.intersection(b.outgoing);\n            return this.R - inInt.count() - outInt.count();\n        }\n\n        getGroupHierarchy(retargetedEdges: PowerEdge[]): any[]{\n            var groups = [];\n            var root = {};\n            toGroups(this.roots[0], root, groups);\n            var es = this.allEdges();\n            es.forEach(e => {\n                var a = this.modules[e.source];\n                var b = this.modules[e.target];\n                retargetedEdges.push(new PowerEdge(\n                    typeof a.gid === \"undefined\" ? e.source : groups[a.gid],\n                    typeof b.gid === \"undefined\" ? e.target : groups[b.gid],\n                    e.type\n                ));\n            });\n            return groups;\n        }\n\n        allEdges(): PowerEdge[] {\n            var es = [];\n            Configuration.getEdges(this.roots[0], es);\n            return es;\n        }\n\n        static getEdges(modules: ModuleSet, es: PowerEdge[]) {\n            modules.forAll(m => {\n                m.getEdges(es);\n                Configuration.getEdges(m.children, es);\n            });\n        }\n    }\n\n    function toGroups(modules: ModuleSet, group, groups) {\n        modules.forAll(m => {\n            if (m.isLeaf()) {\n                if (!group.leaves) group.leaves = [];\n                group.leaves.push(m.id);\n            } else {\n                var g = group;\n                m.gid = groups.length;\n                if (!m.isIsland() || m.isPredefined()) {\n                    g = { id: m.gid };\n                    if (m.isPredefined())\n                        // Apply original group properties\n                        for (var prop in m.definition)\n                            g[prop] = m.definition[prop];\n                    if (!group.groups) group.groups = [];\n                    group.groups.push(m.gid);\n                    groups.push(g);\n                }\n                toGroups(m.children, g, groups);\n            }\n        });\n    }\n\n    export class Module {\n        gid: number;\n\n        constructor(\n            public id: number,\n            public outgoing: LinkSets = new LinkSets(),\n            public incoming: LinkSets = new LinkSets(),\n            public children: ModuleSet = new ModuleSet(),\n            public definition?: any) { }\n\n        getEdges(es: PowerEdge[]) {\n            this.outgoing.forAll((ms, edgetype) => {\n                ms.forAll(target => {\n                    es.push(new PowerEdge(this.id, target.id, edgetype));\n                });\n            });\n        }\n\n        isLeaf() {\n            return this.children.count() === 0;\n        }\n\n        isIsland() {\n            return this.outgoing.count() === 0 && this.incoming.count() === 0;\n        }\n\n        isPredefined(): boolean {\n            return typeof this.definition !== \"undefined\";\n        }\n    }\n\n    function intersection(m: any, n: any): any {\n        var i = {};\n        for (var v in m) if (v in n) i[v] = m[v];\n        return i;\n    }\n\n    export class ModuleSet {\n        table: any = {};\n        count() {\n            return Object.keys(this.table).length;\n        }\n        intersection(other: ModuleSet): ModuleSet {\n            var result = new ModuleSet();\n            result.table = intersection(this.table, other.table);\n            return result;\n        }\n        intersectionCount(other: ModuleSet): number {\n            return this.intersection(other).count();\n        }\n        contains(id: number): boolean {\n            return id in this.table;\n        }\n        add(m: Module): void {\n            this.table[m.id] = m;\n        }\n        remove(m: Module): void {\n            delete this.table[m.id];\n        }\n        forAll(f: (m: Module) => void) {\n            for (var mid in this.table) {\n                f(this.table[mid]);\n            }\n        }\n        modules(): Module[] {\n            var vs = [];\n            this.forAll(m => {\n                if (!m.isPredefined())\n                    vs.push(m);\n            });\n            return vs;\n        }\n    }\n\n    export class LinkSets {\n        sets: any = {};\n        n: number = 0;\n        count(): number {\n            return this.n;\n        }\n        contains(id: number) {\n            var result = false;\n            this.forAllModules(m => {\n                if (!result && m.id == id) {\n                    result = true;\n                }\n            });\n            return result;\n        }\n        add(linktype: number, m: Module) {\n            var s: ModuleSet = linktype in this.sets ? this.sets[linktype] : this.sets[linktype] = new ModuleSet();\n            s.add(m);\n            ++this.n;\n        }\n        remove(linktype: number, m: Module) {\n            var ms = <ModuleSet>this.sets[linktype];\n            ms.remove(m);\n            if (ms.count() === 0) {\n                delete this.sets[linktype];\n            }\n            --this.n;\n        }\n        forAll(f: (ms: ModuleSet, linktype: number) => void) {\n            for (var linktype in this.sets) {\n                f(<ModuleSet>this.sets[linktype], Number(linktype));\n            }\n        }\n        forAllModules(f: (m: Module) => void) {\n            this.forAll((ms, lt) => ms.forAll(f));\n        }\n        intersection(other: LinkSets): LinkSets {\n            var result: LinkSets = new LinkSets();\n            this.forAll((ms, lt) => {\n                if (lt in other.sets) {\n                    var i = ms.intersection(other.sets[lt]),\n                        n = i.count();\n                    if (n > 0) {\n                        result.sets[lt] = i;\n                        result.n += n;\n                    }\n                }\n            });\n            return result;\n        }\n    }\n\n    function intersectionCount(m: any, n: any): number {\n        return Object.keys(intersection(m, n)).length\n    }\n\n    export function getGroups<Link>(nodes: any[], links: Link[], la: LinkTypeAccessor<Link>, rootGroup?: any[]): { groups: any[]; powerEdges: PowerEdge[] } {\n        var n = nodes.length,\n            c = new Configuration(n, links, la, rootGroup);\n        while (c.greedyMerge());\n        var powerEdges: PowerEdge[] = [];\n        var g = c.getGroupHierarchy(powerEdges);\n        powerEdges.forEach(function (e) {\n            var f = (end) => {\n                var g = e[end];\n                if (typeof g == \"number\") e[end] = nodes[g];\n            };\n            f(\"source\");\n            f(\"target\");\n        });\n        return { groups: g, powerEdges: powerEdges };\n    }\n","    export interface LinkAccessor<Link> {\n        getSourceIndex(l: Link): number;\n        getTargetIndex(l: Link): number;\n    }\n\n    export interface LinkLengthAccessor<Link> extends LinkAccessor<Link> {\n        setLength(l: Link, value: number): void;\n    }\n\n    // compute the size of the union of two sets a and b\n    function unionCount(a: any, b: any): number {\n        var u = {};\n        for (var i in a) u[i] = {};\n        for (var i in b) u[i] = {};\n        return Object.keys(u).length;\n    }\n\n    // compute the size of the intersection of two sets a and b\n    function intersectionCount(a: number[], b: number[]): number {\n        var n = 0;\n        for (var i in a) if (typeof b[i] !== 'undefined') ++n;\n        return n;\n    }\n\n    function getNeighbours<Link>(links: Link[], la: LinkAccessor<Link>): any {\n        var neighbours = {};\n        var addNeighbours = (u, v) => {\n            if (typeof neighbours[u] === 'undefined')\n                neighbours[u] = {};\n            neighbours[u][v] = {};\n        };\n        links.forEach(e => {\n            var u = la.getSourceIndex(e), v = la.getTargetIndex(e);\n            addNeighbours(u, v);\n            addNeighbours(v, u);\n        });\n        return neighbours;\n    }\n\n    // modify the lengths of the specified links by the result of function f weighted by w\n    function computeLinkLengths<Link>(links: Link[], w: number, f: (a: any, b: any) => number, la: LinkLengthAccessor<Link>) {\n        var neighbours = getNeighbours(links, la);\n        links.forEach(l => {\n            var a = neighbours[la.getSourceIndex(l)];\n            var b = neighbours[la.getTargetIndex(l)];\n            la.setLength(l, 1 + w * f(a, b));\n        });\n    }\n\n    /** modify the specified link lengths based on the symmetric difference of their neighbours\n     * @class symmetricDiffLinkLengths\n     */\n    export function symmetricDiffLinkLengths<Link>(links: Link[], la: LinkLengthAccessor<Link>, w: number = 1) {\n        computeLinkLengths(links, w, (a, b) => Math.sqrt(unionCount(a, b) - intersectionCount(a, b)), la);\n    }\n\n    /** modify the specified links lengths based on the jaccard difference between their neighbours\n     * @class jaccardLinkLengths\n     */\n    export function jaccardLinkLengths<Link>(links: Link[], la: LinkLengthAccessor<Link>, w: number = 1) {\n        computeLinkLengths(links, w, (a, b) =>\n            Math.min(Object.keys(a).length, Object.keys(b).length) < 1.1 ? 0 : intersectionCount(a, b) / unionCount(a, b)\n            , la);\n    }\n\n    export interface IConstraint {\n        left: number;\n        right: number;\n        gap: number;\n    }\n\n    export interface DirectedEdgeConstraints {\n        axis: string;\n        gap: number;\n    }\n\n    export interface LinkSepAccessor<Link> extends LinkAccessor<Link> {\n        getMinSeparation(l: Link): number;\n    }\n\n    /** generate separation constraints for all edges unless both their source and sink are in the same strongly connected component\n     * @class generateDirectedEdgeConstraints\n     */\n    export function generateDirectedEdgeConstraints<Link>(n: number, links: Link[], axis: string,\n        la: LinkSepAccessor<Link>): IConstraint[]\n    {\n        var components = stronglyConnectedComponents(n, links, la);\n        var nodes = {};\n        components.forEach((c,i) =>\n            c.forEach(v => nodes[v] = i)\n        );\n        var constraints: any[] = [];\n        links.forEach(l => {\n            var ui = la.getSourceIndex(l), vi = la.getTargetIndex(l),\n                u = nodes[ui], v = nodes[vi];\n            if (u !== v) {\n                constraints.push({\n                    axis: axis,\n                    left: ui,\n                    right: vi,\n                    gap: la.getMinSeparation(l)\n                });\n            }\n        });\n        return constraints;\n    }\n\n    /**\n     * Tarjan's strongly connected components algorithm for directed graphs\n     * returns an array of arrays of node indicies in each of the strongly connected components.\n     * a vertex not in a SCC of two or more nodes is it's own SCC.\n     * adaptation of https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n     */\n    export function stronglyConnectedComponents<Link>(numVertices: number, edges: Link[], la: LinkAccessor<Link>): number[][]{\n        var nodes = [];\n        var index = 0;\n        var stack = [];\n        var components = [];\n        function strongConnect(v) {\n            // Set the depth index for v to the smallest unused index\n            v.index = v.lowlink = index++;\n            stack.push(v);\n            v.onStack = true;\n\n            // Consider successors of v\n            for (var w of v.out) {\n                if (typeof w.index === 'undefined') {\n                    // Successor w has not yet been visited; recurse on it\n                    strongConnect(w);\n                    v.lowlink = Math.min(v.lowlink, w.lowlink);\n                } else if (w.onStack) {\n                    // Successor w is in stack S and hence in the current SCC\n                    v.lowlink = Math.min(v.lowlink, w.index);\n                }\n            }\n\n            // If v is a root node, pop the stack and generate an SCC\n            if (v.lowlink === v.index) {\n                // start a new strongly connected component\n                var component = [];\n                while (stack.length) {\n                    w = stack.pop();\n                    w.onStack = false;\n                    //add w to current strongly connected component\n                    component.push(w);\n                    if (w === v) break;\n                }\n                // output the current strongly connected component\n                components.push(component.map(v => v.id));\n            }\n        }\n        for (var i = 0; i < numVertices; i++) {\n            nodes.push({id: i, out: []});\n        }\n        for (var e of edges) {\n            let v = nodes[la.getSourceIndex(e)],\n                w = nodes[la.getTargetIndex(e)];\n            v.out.push(w);\n        }\n        for (var v of nodes) if (typeof v.index === 'undefined') strongConnect(v);\n        return components;\n    }\n","import type { DerivativeComputerWasmInst } from \"wasmEngine\";\n\n    /**\n     * Descent respects a collection of locks over nodes that should not move\n     * @class Locks\n     */\n    export class Locks {\n        locks: { [key:number]:number[]} = {};\n        /**\n         * add a lock on the node at index id\n         * @method add\n         * @param id index of node to be locked\n         * @param x required position for node\n         */\n        add(id: number, x: number[]) {\n/* DEBUG\n            if (isNaN(x[0]) || isNaN(x[1])) debugger;\nDEBUG */\n            this.locks[id] = x;\n        }\n        /**\n         * @method clear clear all locks\n         */\n        clear() {\n            this.locks = {};\n        }\n        /**\n         * @isEmpty\n         * @returns false if no locks exist\n         */\n        isEmpty(): boolean {\n            for (var l in this.locks) return false;\n            return true;\n        }\n        /**\n         * perform an operation on each lock\n         * @apply\n         */\n        apply(f: (id: number, x: number[]) => void) {\n            for (var l in this.locks) {\n                f(Number(l), this.locks[l]);\n            }\n        }\n    }\n\n    const BYTES_PER_F32 = 32 / 8;\n\n    /**\n     * Uses a gradient descent approach to reduce a stress or p-stress goal function over a graph with specified ideal edge lengths or a square matrix of dissimilarities.\n     * The standard stress function over a graph nodes with position vectors x,y,z is (mathematica input):\n     *   stress[x_,y_,z_,D_,w_]:=Sum[w[[i,j]] (length[x[[i]],y[[i]],z[[i]],x[[j]],y[[j]],z[[j]]]-d[[i,j]])^2,{i,Length[x]-1},{j,i+1,Length[x]}]\n     * where: D is a square matrix of ideal separations between nodes, w is matrix of weights for those separations\n     *        length[x1_, y1_, z1_, x2_, y2_, z2_] = Sqrt[(x1 - x2)^2 + (y1 - y2)^2 + (z1 - z2)^2]\n     * below, we use wij = 1/(Dij^2)\n     *\n     * @class Descent\n     */\n    export class Descent {\n        private wasm: DerivativeComputerWasmInst;\n        private ctxPtr: number;\n\n        public threshold: number = 0.0001;\n        /** gradient vector\n         * @property g {Float32Array[]}\n         */\n        public get g(): Float32Array[] {\n            const memory: WebAssembly.Memory = this.wasm.get_memory();\n            const memoryView = new Float32Array(memory.buffer);\n\n            const gPtr = this.k === 2 ? this.wasm.get_g_2d(this.ctxPtr) : this.wasm.get_g_3d(this.ctxPtr);\n            const gOffset = gPtr / BYTES_PER_F32;\n            return new Array(this.k)\n                .fill(null)\n                .map((_, i) => memoryView.subarray(gOffset + i * this.n, gOffset + i * this.n + this.n));\n        }\n        public set G(newG: Float32Array[] | null)  {\n            const allG = (() => {\n                if (newG) {\n                    const allG = new Float32Array(this.n * this.n);\n                    newG.forEach((Gn, i) => allG.set(Gn, i * this.n));\n                    return allG;\n                } else {\n                    return new Float32Array();\n                }\n            })();\n\n            if (this.k === 2) {\n                this.wasm.set_G_2d(this.ctxPtr, allG);\n            } else if (this.k === 3) {\n                this.wasm.set_G_3d(this.ctxPtr, allG);\n            } else {\n                throw new Error('Invalid dimensionality');\n            }\n        }\n       /** positions vector\n         * @property x {number[][]}\n         */\n        public x: Float32Array[];\n        /**\n         * @property k {number} dimensionality\n         */\n        public k: number;\n        /**\n         * number of data-points / nodes / size of vectors/matrices\n         * @property n {number}\n         */\n        public n: number;\n        /**\n         * matrix of desired distances between pairs of nodes\n         */\n         public get D(): Float32Array[] {\n            const memory: WebAssembly.Memory = this.wasm.get_memory();\n            const memoryView = new Float32Array(memory.buffer);\n\n            const DPtr = this.k === 2 ? this.wasm.get_D_2d(this.ctxPtr) : this.wasm.get_D_3d(this.ctxPtr);\n            const DOffset = DPtr / BYTES_PER_F32;\n            return new Array(this.n)\n                .fill(null)\n                .map((_, i) => memoryView.subarray(DOffset + i * this.n, DOffset + i * this.n + this.n));\n        }\n\n        public computeDerivatives(x: Float32Array[]) {\n            if (this.k === 2) {\n                const packedX = (() => {\n                    const packed = new Float32Array(x[0].length * this.k);\n                    x.forEach((xn, i) => packed.set(xn, i * this.n));\n                    return packed;\n                })();\n                const outX = this.wasm.compute_2d(this.ctxPtr, packedX);\n\n                if (x) {\n                    x.forEach((xn, i) => {\n                        const slice = outX.subarray(i * this.n, i * this.n + this.n);\n                        xn.set(slice);\n                    })\n                }\n            } else if (this.k === 3) {\n                const packedX = (() => {\n                    const packed = new Float32Array(x[0].length * this.k);\n                    x.forEach((xn, i) => packed.set(xn, i * this.n));\n                    return packed;\n                })();\n                const outX = this.wasm.compute_3d(this.ctxPtr, packedX);\n\n                if (x) {\n                    x.forEach((xn, i) => {\n                        const slice = outX.subarray(i * this.n, i * this.n + this.n);\n                        xn.set(slice);\n                    })\n                }\n            } else {\n                throw new Error('Invalid dimensionality');\n            }\n\n            if (!this.locks.isEmpty()) {\n                this.locks.apply((u, p) => {\n                    if (this.k === 2) {\n                        this.wasm.apply_lock_2d(this.ctxPtr, u, p[0], p[1], x[0][u], x[1][u]);\n                    } else if (this.k === 3) {\n                        this.wasm.apply_lock_3d(this.ctxPtr, u, p[0], p[1], p[2], x[0][u], x[1][u], x[2][u]);\n                    } else {\n                        throw new Error('Invalid dimensionality');\n                    }\n                });\n            }\n        }\n\n        public locks: Locks;\n\n        private static zeroDistance: number = 1e-10;\n        private minD: number;\n\n        // pool of arrays of size n used internally, allocated in constructor\n        private a: Float32Array[];\n        private b: Float32Array[];\n        private c: Float32Array[];\n        private d: Float32Array[];\n        private e: Float32Array[];\n        private ia: Float32Array[];\n        private ib: Float32Array[];\n        private xtmp: number[][];\n\n\n        // Parameters for grid snap stress.\n        // TODO: Make a pluggable \"StressTerm\" class instead of this\n        // mess.\n        public numGridSnapNodes: number = 0;\n        public snapGridSize: number = 100;\n        public snapStrength: number = 1000;\n        public scaleSnapByMaxH: boolean = false;\n\n        private random = new PseudoRandom();\n\n        public project: { (x0: Float32Array, y0: Float32Array, r: Float32Array): void }[] = null;\n\n        private setupWasm(D: number[][], G: number[][] | null = null) {\n            const allD = new Float32Array(this.n * this.n);\n            const allG = G ? new Float32Array(this.n * this.k) : new Float32Array(0);\n            D.forEach((dn, i) => {\n                allD.set(dn, i * this.n);\n            });\n            if (G) {\n                G.forEach((gn, i) => {\n                    allG.set(gn, i * this.n);\n                });\n            }\n\n            allD.forEach((d, i) => {\n                if (d === Infinity) {\n                    allD[i] = -10000000; // ideal distance\n                    allG[i] = 1000.; // weight\n                }\n            });\n\n            const createrFn = this.k === 2 ? this.wasm.create_derivative_computer_ctx_2d : this.wasm.create_derivative_computer_ctx_3d;\n            this.ctxPtr = createrFn(this.n, allD, allG);\n        }\n\n        /**\n         * @method constructor\n         * @param x {number[][]} initial coordinates for nodes\n         * @param D {number[][]} matrix of desired distances between pairs of nodes\n         * @param G {number[][]} [default=null] if specified, G is a matrix of weights for goal terms between pairs of nodes.\n         * If G[i][j] > 1 and the separation between nodes i and j is greater than their ideal distance, then there is no contribution for this pair to the goal\n         * If G[i][j] <= 1 then it is used as a weighting on the contribution of the variance between ideal and actual separation between i and j to the goal function\n         */\n        constructor(x: number[][], D: number[][], G: number[][] = null, wasm: DerivativeComputerWasmInst) {\n            this.wasm = wasm;\n            this.x = x.map(xn => new Float32Array(xn));\n            this.k = x.length; // dimensionality\n            var n = this.n = x[0].length; // number of nodes\n\n            // Set up Wasm context\n            this.setupWasm(D, G);\n\n            this.a = new Array(this.k);\n            this.b = new Array(this.k);\n            this.c = new Array(this.k);\n            this.d = new Array(this.k);\n            this.e = new Array(this.k);\n            this.ia = new Array(this.k);\n            this.ib = new Array(this.k);\n            this.xtmp = new Array(this.k);\n            this.locks = new Locks();\n            this.minD = Number.MAX_VALUE;\n            var i = n, j;\n            while (i--) {\n                j = n;\n                while (--j > i) {\n                    var d = D[i][j];\n                    if (d > 0 && d < this.minD) {\n                        this.minD = d;\n                    }\n                }\n            }\n            if (this.minD === Number.MAX_VALUE) this.minD = 1;\n            i = this.k;\n            while (i--) {\n                j = n;\n                this.a[i] = new Float32Array(n);\n                this.b[i] = new Float32Array(n);\n                this.c[i] = new Float32Array(n);\n                this.d[i] = new Float32Array(n);\n                this.e[i] = new Float32Array(n);\n                this.ia[i] = new Float32Array(n);\n                this.ib[i] = new Float32Array(n);\n                this.xtmp[i] = new Array(n);\n            }\n        }\n\n        public static createSquareMatrix(n: number, f: (i: number, j: number) => number): number[][] {\n            var M = new Array(n);\n            for (var i = 0; i < n; ++i) {\n                M[i] = new Array(n);\n                for (var j = 0; j < n; ++j) {\n                    M[i][j] = f(i, j);\n                }\n            }\n            return M;\n        }\n\n        private offsetDir(): number[] {\n            var u = new Array(this.k);\n            var l = 0;\n            for (var i = 0; i < this.k; ++i) {\n                var x = u[i] = this.random.getNextBetween(0.01, 1) - 0.5;\n                l += x * x;\n            }\n            l = Math.sqrt(l);\n            return u.map(x=> x *= this.minD / l);\n        }\n\n        private static dotProd(a: Float32Array, b: Float32Array): number {\n            var x = 0, i = a.length;\n            while (i--) x += a[i] * b[i];\n            return x;\n        }\n\n        // result r = matrix m * vector v\n        private static rightMultiply(m: Float32Array[], v: Float32Array, r: Float32Array) {\n            var i = m.length;\n            while (i--) r[i] = Descent.dotProd(m[i], v);\n        }\n\n        // computes the optimal step size to take in direction d using the\n        // derivative information in this.g and this.H\n        // returns the scalar multiplier to apply to d to get the optimal step\n        public computeStepSize(): number {\n            if (this.k === 2) {\n                return this.wasm.compute_step_size_2d(this.ctxPtr);\n            } else if (this.k === 3) {\n                return this.wasm.compute_step_size_3d(this.ctxPtr);\n            } else {\n                throw new Error('Invalid dimensionality');\n            }\n        }\n\n        public reduceStress(): number {\n            this.computeDerivatives(this.x);\n            var alpha = this.computeStepSize();\n            const thisG = this.g;\n            for (var i = 0; i < this.k; ++i) {\n                this.takeDescentStep(this.x[i], thisG[i], alpha);\n            }\n            return this.computeStress();\n        }\n\n        private static copy(a: Float32Array[], b: Float32Array[]): void {\n            var m = a.length, n = b[0].length;\n            for (var i = 0; i < m; ++i) {\n                for (var j = 0; j < n; ++j) {\n                    b[i][j] = a[i][j];\n                }\n            }\n        }\n\n        // takes a step of stepSize * d from x0, and then project against any constraints.\n        // result is returned in r.\n        // x0: starting positions\n        // r: result positions will be returned here\n        // d: unconstrained descent vector\n        // stepSize: amount to step along d\n        private stepAndProject(x0: Float32Array[], r: Float32Array[], d: Float32Array[], stepSize: number): void {\n            Descent.copy(x0, r);\n            this.takeDescentStep(r[0], d[0], stepSize);\n            if (this.project) this.project[0](x0[0], x0[1], r[0]);\n            this.takeDescentStep(r[1], d[1], stepSize);\n            if (this.project) this.project[1](r[0], x0[1], r[1]);\n\n            // todo: allow projection against constraints in higher dimensions\n            for (var i = 2; i < this.k; i++)\n                this.takeDescentStep(r[i], d[i], stepSize);\n\n            // the following makes locks extra sticky... but hides the result of the projection from the consumer\n            //if (!this.locks.isEmpty()) {\n            //    this.locks.apply((u, p) => {\n            //        for (var i = 0; i < this.k; i++) {\n            //            r[i][u] = p[i];\n            //        }\n            //    });\n            //}\n        }\n\n        private static mApply(m: number, n: number, f: (i: number, j: number) => any) {\n            var i = m; while (i-- > 0) {\n                var j = n; while (j-- > 0) f(i, j);\n            }\n        }\n        private matrixApply(f: (i: number, j: number) => any) {\n            Descent.mApply(this.k, this.n, f);\n        }\n\n        private computeNextPosition(x0: Float32Array[], r: Float32Array[]): void {\n            this.computeDerivatives(x0);\n            const alpha = this.computeStepSize();\n            this.stepAndProject(x0, r, this.g, alpha);\n/* DEBUG\n            for (var u: number = 0; u < this.n; ++u)\n                for (var i = 0; i < this.k; ++i)\n                    if (isNaN(r[i][u])) debugger;\nDEBUG */\n            if (this.project) {\n                // This functionality is not yet implemented with the Wasm port\n                throw new Error('Computing step with with `this.project` set is not yet implemented in Wasm port');\n                // this.matrixApply((i, j) => this.e[i][j] = x0[i][j] - r[i][j]);\n                // var beta = this.computeStepSize(this.e);\n                // beta = Math.max(0.2, Math.min(beta, 1));\n                // this.stepAndProject(x0, r, this.e, beta);\n            }\n        }\n\n        public run(iterations: number): number {\n            var stress = Number.MAX_VALUE, converged = false;\n            while (!converged && iterations-- > 0) {\n                var s = this.rungeKutta();\n                converged = Math.abs(stress / s - 1) < this.threshold;\n                stress = s;\n            }\n            return stress;\n        }\n\n        public rungeKutta(): number {\n            this.computeNextPosition(this.x, this.a);\n            Descent.mid(this.x, this.a, this.ia);\n            this.computeNextPosition(this.ia, this.b);\n            Descent.mid(this.x, this.b, this.ib);\n            this.computeNextPosition(this.ib, this.c);\n            this.computeNextPosition(this.c, this.d);\n            var disp = 0;\n            this.matrixApply((i, j) => {\n                var x = (this.a[i][j] + 2.0 * this.b[i][j] + 2.0 * this.c[i][j] + this.d[i][j]) / 6.0,\n                    d = this.x[i][j] - x;\n                disp += d * d;\n                this.x[i][j] = x;\n            });\n            return disp;\n        }\n\n        private static mid(a: Float32Array[], b: Float32Array[], m: Float32Array[]): void {\n            Descent.mApply(a.length, a[0].length, (i, j) =>\n                m[i][j] = a[i][j] + (b[i][j] - a[i][j]) / 2.0);\n        }\n\n        public takeDescentStep(x: Float32Array, d: Float32Array, stepSize: number): void {\n            for (var i = 0; i < this.n; ++i) {\n                x[i] = x[i] - stepSize * d[i];\n            }\n        }\n\n        public computeStress(): number {\n            var stress = 0;\n            for (var u = 0, nMinus1 = this.n - 1; u < nMinus1; ++u) {\n                for (var v = u + 1, n = this.n; v < n; ++v) {\n                    var l = 0;\n                    for (var i = 0; i < this.k; ++i) {\n                        var dx = this.x[i][u] - this.x[i][v];\n                        l += dx * dx;\n                    }\n                    l = Math.sqrt(l);\n                    var d = this.D[u][v];\n                    if (!isFinite(d)) continue;\n                    var rl = d - l;\n                    var d2 = d * d;\n                    stress += rl * rl / d2;\n                }\n            }\n            return stress;\n        }\n    }\n\n    // Linear congruential pseudo random number generator\n    export class PseudoRandom {\n        private a: number = 214013;\n        private c: number = 2531011;\n        private m: number = 2147483648;\n        private range: number = 32767;\n\n        constructor(public seed: number = 1) { }\n\n        // random real between 0 and 1\n        getNext(): number {\n            this.seed = (this.seed * this.a + this.c) % this.m;\n            return (this.seed >> 16) / this.range;\n        }\n\n        // random real between min and max\n        getNextBetween(min: number, max: number) {\n            return min + this.getNext() * (max - min);\n        }\n    }\n","    export class PositionStats {\n        AB: number = 0;\n        AD: number = 0;\n        A2: number = 0;\n\n        constructor(public scale: number) {}\n\n        addVariable(v: Variable): void {\n            var ai = this.scale / v.scale;\n            var bi = v.offset / v.scale;\n            var wi = v.weight;\n            this.AB += wi * ai * bi;\n            this.AD += wi * ai * v.desiredPosition;\n            this.A2 += wi * ai * ai;\n        }\n\n        getPosn(): number {\n            return (this.AD - this.AB) / this.A2;\n        }\n    }\n\n    export class Constraint {\n        lm: number;\n        active: boolean = false;\n        unsatisfiable: boolean = false;\n\n        constructor(public left: Variable, public right: Variable, public gap: number, public equality: boolean = false) {\n            this.left = left;\n            this.right = right;\n            this.gap = gap;\n            this.equality = equality;\n        }\n\n        slack(): number {\n            return this.unsatisfiable ? Number.MAX_VALUE\n                : this.right.scale * this.right.position() - this.gap\n                - this.left.scale * this.left.position();\n        }\n    }\n\n    export class Variable {\n        offset: number = 0;\n        block: Block;\n        cIn: Constraint[];\n        cOut: Constraint[];\n\n        constructor(public desiredPosition: number, public weight: number = 1, public scale: number = 1) {}\n\n        dfdv(): number {\n            return 2.0 * this.weight * (this.position() - this.desiredPosition);\n        }\n\n        position(): number {\n            return (this.block.ps.scale * this.block.posn + this.offset) / this.scale;\n        }\n\n        // visit neighbours by active constraints within the same block\n        visitNeighbours(prev: Variable, f: (c: Constraint, next: Variable) => void ): void {\n            var ff = (c, next) => c.active && prev !== next && f(c, next);\n            this.cOut.forEach(c=> ff(c, c.right));\n            this.cIn.forEach(c=> ff(c, c.left));\n        }\n    }\n\n    export class Block {\n        vars: Variable[] = [];\n        posn: number;\n        ps: PositionStats;\n        blockInd: number;\n\n        constructor(v: Variable) {\n            v.offset = 0;\n            this.ps = new PositionStats(v.scale);\n            this.addVariable(v);\n        }\n\n        private addVariable(v: Variable): void {\n            v.block = this;\n            this.vars.push(v);\n            this.ps.addVariable(v);\n            this.posn = this.ps.getPosn();\n        }\n\n        // move the block where it needs to be to minimize cost\n        updateWeightedPosition(): void {\n            this.ps.AB = this.ps.AD = this.ps.A2 = 0;\n            for (var i = 0, n = this.vars.length; i < n; ++i)\n                this.ps.addVariable(this.vars[i]);\n            this.posn = this.ps.getPosn();\n        }\n\n        private compute_lm(v: Variable, u: Variable, postAction: (c: Constraint)=>void): number {\n            var dfdv = v.dfdv();\n            v.visitNeighbours(u, (c, next) => {\n                var _dfdv = this.compute_lm(next, v, postAction);\n                if (next === c.right) {\n                    dfdv += _dfdv * c.left.scale;\n                    c.lm = _dfdv;\n                } else {\n                    dfdv += _dfdv * c.right.scale;\n                    c.lm = -_dfdv;\n                }\n                postAction(c);\n            });\n            return dfdv / v.scale;\n        }\n\n        private populateSplitBlock(v: Variable, prev: Variable): void {\n            v.visitNeighbours(prev, (c, next) => {\n                next.offset = v.offset + (next === c.right ? c.gap : -c.gap);\n                this.addVariable(next);\n                this.populateSplitBlock(next, v);\n            });\n        }\n\n        // traverse the active constraint tree applying visit to each active constraint\n        traverse(visit: (c: Constraint) => any, acc: any[], v: Variable = this.vars[0], prev: Variable=null) {\n            v.visitNeighbours(prev, (c, next) => {\n                acc.push(visit(c));\n                this.traverse(visit, acc, next, v);\n            });\n        }\n\n        // calculate lagrangian multipliers on constraints and\n        // find the active constraint in this block with the smallest lagrangian.\n        // if the lagrangian is negative, then the constraint is a split candidate.\n        findMinLM(): Constraint {\n            var m: Constraint = null;\n            this.compute_lm(this.vars[0], null, c=> {\n                if (!c.equality && (m === null || c.lm < m.lm)) m = c;\n            });\n            return m;\n        }\n\n        private findMinLMBetween(lv: Variable, rv: Variable): Constraint {\n            this.compute_lm(lv, null, () => {});\n            var m = null;\n            this.findPath(lv, null, rv, (c, next)=> {\n                if (!c.equality && c.right === next && (m === null || c.lm < m.lm)) m = c;\n            });\n            return m;\n        }\n\n        private findPath(v: Variable, prev: Variable, to: Variable, visit: (c: Constraint, next:Variable)=>void): boolean {\n            var endFound = false;\n            v.visitNeighbours(prev, (c, next) => {\n                if (!endFound && (next === to || this.findPath(next, v, to, visit)))\n                {\n                    endFound = true;\n                    visit(c, next);\n                }\n            });\n            return endFound;\n        }\n\n        // Search active constraint tree from u to see if there is a directed path to v.\n        // Returns true if path is found.\n        isActiveDirectedPathBetween(u: Variable, v: Variable) : boolean {\n            if (u === v) return true;\n            var i = u.cOut.length;\n            while(i--) {\n                var c = u.cOut[i];\n                if (c.active && this.isActiveDirectedPathBetween(c.right, v))\n                    return true;\n            }\n            return false;\n        }\n\n        // split the block into two by deactivating the specified constraint\n        static split(c: Constraint): Block[]{\n/* DEBUG\n            console.log(\"split on \" + c);\n            console.assert(c.active, \"attempt to split on inactive constraint\");\nDEBUG */\n            c.active = false;\n            return [Block.createSplitBlock(c.left), Block.createSplitBlock(c.right)];\n        }\n\n        private static createSplitBlock(startVar: Variable): Block {\n            var b = new Block(startVar);\n            b.populateSplitBlock(startVar, null);\n            return b;\n        }\n\n        // find a split point somewhere between the specified variables\n        splitBetween(vl: Variable, vr: Variable): { constraint: Constraint; lb: Block; rb: Block } {\n/* DEBUG\n            console.assert(vl.block === this);\n            console.assert(vr.block === this);\nDEBUG */\n            var c = this.findMinLMBetween(vl, vr);\n            if (c !== null) {\n                var bs = Block.split(c);\n                return { constraint: c, lb: bs[0], rb: bs[1] };\n            }\n            // couldn't find a split point - for example the active path is all equality constraints\n            return null;\n        }\n\n        mergeAcross(b: Block, c: Constraint, dist: number): void {\n            c.active = true;\n            for (var i = 0, n = b.vars.length; i < n; ++i) {\n                var v = b.vars[i];\n                v.offset += dist;\n                this.addVariable(v);\n            }\n            this.posn = this.ps.getPosn();\n        }\n\n        cost(): number {\n            var sum = 0, i = this.vars.length;\n            while (i--) {\n                var v = this.vars[i],\n                    d = v.position() - v.desiredPosition;\n                sum += d * d * v.weight;\n            }\n            return sum;\n        }\n\n/* DEBUG\n        toString(): string {\n            var cs = [];\n            this.traverse(c=> c.toString() + \"\\n\", cs)\n            return \"b\"+this.blockInd + \"@\" + this.posn + \": vars=\" + this.vars.map(v=> v.toString()+\":\"+v.offset) + \";\\n cons=\\n\" + cs;\n        }\nDEBUG */\n    }\n\n    export class Blocks {\n        private list: Block[];\n\n        constructor(public vs: Variable[]) {\n            var n = vs.length;\n            this.list = new Array(n);\n            while (n--) {\n                var b = new Block(vs[n]);\n                this.list[n] = b;\n                b.blockInd = n;\n            }\n        }\n\n        cost(): number {\n            var sum = 0, i = this.list.length;\n            while (i--) sum += this.list[i].cost();\n            return sum;\n        }\n\n        insert(b: Block) {\n/* DEBUG\n            console.assert(!this.contains(b), \"blocks error: tried to reinsert block \" + b.blockInd)\nDEBUG */\n            b.blockInd = this.list.length;\n            this.list.push(b);\n/* DEBUG\n            console.log(\"insert block: \" + b.blockInd);\n            this.contains(b);\nDEBUG */\n        }\n\n        remove(b: Block) {\n/* DEBUG\n            console.log(\"remove block: \" + b.blockInd);\n            console.assert(this.contains(b));\nDEBUG */\n            var last = this.list.length - 1;\n            var swapBlock = this.list[last];\n            this.list.length = last;\n            if (b !== swapBlock) {\n                this.list[b.blockInd] = swapBlock;\n                swapBlock.blockInd = b.blockInd;\n/* DEBUG\n                console.assert(this.contains(swapBlock));\nDEBUG */\n            }\n        }\n\n        // merge the blocks on either side of the specified constraint, by copying the smaller block into the larger\n        // and deleting the smaller.\n        merge(c: Constraint): void {\n            var l = c.left.block, r = c.right.block;\n/* DEBUG\n            console.assert(l!==r, \"attempt to merge within the same block\");\nDEBUG */\n            var dist = c.right.offset - c.left.offset - c.gap;\n            if (l.vars.length < r.vars.length) {\n                r.mergeAcross(l, c, dist);\n                this.remove(l);\n            } else {\n                l.mergeAcross(r, c, -dist);\n                this.remove(r);\n            }\n/* DEBUG\n            console.assert(Math.abs(c.slack()) < 1e-6, \"Error: Constraint should be at equality after merge!\");\n            console.log(\"merged on \" + c);\nDEBUG */\n        }\n\n        forEach(f: (b: Block, i: number) => void ) {\n            this.list.forEach(f);\n        }\n\n        // useful, for example, after variable desired positions change.\n        updateBlockPositions(): void {\n            this.list.forEach(b=> b.updateWeightedPosition());\n        }\n\n        // split each block across its constraint with the minimum lagrangian\n        split(inactive: Constraint[]): void {\n            this.updateBlockPositions();\n            this.list.forEach(b=> {\n                var v = b.findMinLM();\n                if (v !== null && v.lm < Solver.LAGRANGIAN_TOLERANCE) {\n                    b = v.left.block;\n                    Block.split(v).forEach(nb=>this.insert(nb));\n                    this.remove(b);\n                    inactive.push(v);\n/* DEBUG\n                    console.assert(this.contains(v.left.block));\n                    console.assert(this.contains(v.right.block));\nDEBUG */\n                }\n            });\n        }\n\n/* DEBUG\n        // checks b is in the block, and does a sanity check over list index integrity\n        contains(b: Block): boolean {\n            var result = false;\n            this.list.forEach((bb, i) => {\n                if (bb.blockInd !== i) {\n                    console.error(\"blocks error, blockInd \" + b.blockInd + \" found at \" + i);\n                    return false;\n                }\n                result = result || b === bb;\n            });\n            return result;\n        }\n\n        toString(): string {\n            return this.list.toString();\n        }\nDEBUG */\n    }\n\n    export class Solver {\n        bs: Blocks;\n        inactive: Constraint[];\n\n        static LAGRANGIAN_TOLERANCE = -1e-4;\n        static ZERO_UPPERBOUND = -1e-10;\n\n        constructor(public vs: Variable[], public cs: Constraint[]) {\n            this.vs = vs;\n            vs.forEach(v => {\n                v.cIn = [], v.cOut = [];\n/* DEBUG\n                v.toString = () => \"v\" + vs.indexOf(v);\nDEBUG */\n            });\n            this.cs = cs;\n            cs.forEach(c => {\n                c.left.cOut.push(c);\n                c.right.cIn.push(c);\n/* DEBUG\n                c.toString = () => c.left + \"+\" + c.gap + \"<=\" + c.right + \" slack=\" + c.slack() + \" active=\" + c.active;\nDEBUG */\n            });\n            this.inactive = cs.map(c=> { c.active = false; return c; });\n            this.bs = null;\n        }\n\n        cost(): number {\n            return this.bs.cost();\n        }\n\n        // set starting positions without changing desired positions.\n        // Note: it throws away any previous block structure.\n        setStartingPositions(ps: Float32Array): void {\n            this.inactive = this.cs.map(c=> { c.active = false; return c; });\n            this.bs = new Blocks(this.vs);\n            this.bs.forEach((b, i) => b.posn = ps[i]);\n        }\n\n        setDesiredPositions(ps: Float32Array): void {\n            this.vs.forEach((v, i) => v.desiredPosition = ps[i]);\n        }\n\n/* DEBUG\n        private getId(v: Variable): number {\n            return this.vs.indexOf(v);\n        }\n\n        // sanity check of the index integrity of the inactive list\n        checkInactive(): void {\n            var inactiveCount = 0;\n            this.cs.forEach(c=> {\n                var i = this.inactive.indexOf(c);\n                console.assert(!c.active && i >= 0 || c.active && i < 0, \"constraint should be in the inactive list if it is not active: \" + c);\n                if (i >= 0) {\n                    inactiveCount++;\n                } else {\n                    console.assert(c.active, \"inactive constraint not found in inactive list: \" + c);\n                }\n            });\n            console.assert(inactiveCount === this.inactive.length, inactiveCount + \" inactive constraints found, \" + this.inactive.length + \"in inactive list\");\n        }\n        // after every call to satisfy the following should check should pass\n        checkSatisfied(): void {\n            this.cs.forEach(c=>console.assert(c.slack() >= vpsc.Solver.ZERO_UPPERBOUND, \"Error: Unsatisfied constraint! \"+c));\n        }\nDEBUG */\n\n        private mostViolated(): Constraint {\n            var minSlack = Number.MAX_VALUE,\n                v: Constraint = null,\n                l = this.inactive,\n                n = l.length,\n                deletePoint = n;\n            for (var i = 0; i < n; ++i) {\n                var c = l[i];\n                if (c.unsatisfiable) continue;\n                var slack = c.slack();\n                if (c.equality || slack < minSlack) {\n                    minSlack = slack;\n                    v = c;\n                    deletePoint = i;\n                    if (c.equality) break;\n                }\n            }\n            if (deletePoint !== n &&\n                (minSlack < Solver.ZERO_UPPERBOUND && !v.active || v.equality))\n            {\n                l[deletePoint] = l[n - 1];\n                l.length = n - 1;\n            }\n            return v;\n        }\n\n        // satisfy constraints by building block structure over violated constraints\n        // and moving the blocks to their desired positions\n        satisfy(): void {\n            if (this.bs == null) {\n                this.bs = new Blocks(this.vs);\n            }\n/* DEBUG\n            console.log(\"satisfy: \" + this.bs);\nDEBUG */\n            this.bs.split(this.inactive);\n            var v: Constraint = null;\n            while ((v = this.mostViolated()) && (v.equality || v.slack() < Solver.ZERO_UPPERBOUND && !v.active)) {\n                var lb = v.left.block, rb = v.right.block;\n/* DEBUG\n                console.log(\"most violated is: \" + v);\n                this.bs.contains(lb);\n                this.bs.contains(rb);\nDEBUG */\n                if (lb !== rb) {\n                    this.bs.merge(v);\n                } else {\n                    if (lb.isActiveDirectedPathBetween(v.right, v.left)) {\n                        // cycle found!\n                        v.unsatisfiable = true;\n                        continue;\n                    }\n                    // constraint is within block, need to split first\n                    var split = lb.splitBetween(v.left, v.right);\n                    if (split !== null) {\n                        this.bs.insert(split.lb);\n                        this.bs.insert(split.rb);\n                        this.bs.remove(lb);\n                        this.inactive.push(split.constraint);\n                    } else {\n/* DEBUG\n                        console.log(\"unsatisfiable constraint found\");\nDEBUG */\n                        v.unsatisfiable = true;\n                        continue;\n                    }\n                    if (v.slack() >= 0) {\n/* DEBUG\n                        console.log(\"violated constraint indirectly satisfied: \" + v);\nDEBUG */\n                        // v was satisfied by the above split!\n                        this.inactive.push(v);\n                    } else {\n/* DEBUG\n                        console.log(\"merge after split:\");\nDEBUG */\n                        this.bs.merge(v);\n                    }\n                }\n/* DEBUG\n                this.bs.contains(v.left.block);\n                this.bs.contains(v.right.block);\n                this.checkInactive();\nDEBUG */\n            }\n/* DEBUG\n            this.checkSatisfied();\nDEBUG */\n        }\n\n        // repeatedly build and split block structure until we converge to an optimal solution\n        solve(): number {\n            this.satisfy();\n            var lastcost = Number.MAX_VALUE, cost = this.bs.cost();\n            while (Math.abs(lastcost - cost) > 0.0001) {\n                this.satisfy();\n                lastcost = cost;\n                cost = this.bs.cost();\n            }\n            return cost;\n        }\n    }\n    /**\n      * Remove overlap between spans while keeping their centers as close as possible to the specified desiredCenters.\n      * Lower and upper bounds will be respected if the spans physically fit between them\n      * (otherwise they'll be moved and their new position returned).\n      * If no upper/lower bound is specified then the bounds of the moved spans will be returned.\n      * returns a new center for each span.\n      */\n    export function removeOverlapInOneDimension(spans: { size: number, desiredCenter: number }[], lowerBound?: number, upperBound?: number)\n        : { newCenters: number[], lowerBound: number, upperBound: number }\n    {\n        const vs: Variable[] = spans.map(s => new Variable(s.desiredCenter));\n        const cs: Constraint[] = [];\n        const n = spans.length;\n        for (var i = 0; i < n - 1; i++) {\n            const left = spans[i], right = spans[i + 1];\n            cs.push(new Constraint(vs[i], vs[i + 1], (left.size + right.size) / 2));\n        }\n        const leftMost = vs[0],\n            rightMost = vs[n - 1],\n            leftMostSize = spans[0].size / 2,\n            rightMostSize = spans[n - 1].size / 2;\n        let vLower: Variable = null, vUpper: Variable = null;\n        if (lowerBound) {\n            vLower = new Variable(lowerBound, leftMost.weight * 1000);\n            vs.push(vLower);\n            cs.push(new Constraint(vLower, leftMost, leftMostSize));\n        }\n        if (upperBound) {\n            vUpper = new Variable(upperBound, rightMost.weight * 1000);\n            vs.push(vUpper);\n            cs.push(new Constraint(rightMost, vUpper, rightMostSize));\n        }\n        var solver = new Solver(vs, cs);\n        solver.solve();\n        return {\n            newCenters: vs.slice(0, spans.length).map(v => v.position()),\n            lowerBound: vLower ? vLower.position() : leftMost.position() - leftMostSize,\n            upperBound: vUpper ? vUpper.position() : rightMost.position() + rightMostSize\n        };\n    }\n","    //Based on js_es:\n    //\n    //https://github.com/vadimg/js_bintrees\n    //\n    //Copyright (C) 2011 by Vadim Graboys\n    //\n    //Permission is hereby granted, free of charge, to any person obtaining a copy\n    //of this software and associated documentation files (the \"Software\"), to deal\n    //in the Software without restriction, including without limitation the rights\n    //to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    //copies of the Software, and to permit persons to whom the Software is\n    //furnished to do so, subject to the following conditions:\n    //\n    //The above copyright notice and this permission notice shall be included in\n    //all copies or substantial portions of the Software.\n    //\n    //THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    //IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    //FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    //AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    //LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    //OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n    //THE SOFTWARE.\n    export class TreeBase {\n        _root;\n        size;\n        _comparator;\n        // removes all nodes from the tree\n        clear() {\n            this._root = null;\n            this.size = 0;\n        };\n\n        // returns node data if found, null otherwise\n        find(data) {\n            var res = this._root;\n\n            while (res !== null) {\n                var c = this._comparator(data, res.data);\n                if (c === 0) {\n                    return res.data;\n                }\n                else {\n                    res = res.get_child(c > 0);\n                }\n            }\n\n            return null;\n        };\n\n        // returns iterator to node if found, null otherwise\n        findIter = function (data) {\n            var res = this._root;\n            var iter = this.iterator();\n\n            while (res !== null) {\n                var c = this._comparator(data, res.data);\n                if (c === 0) {\n                    iter._cursor = res;\n                    return iter;\n                }\n                else {\n                    iter._ancestors.push(res);\n                    res = res.get_child(c > 0);\n                }\n            }\n\n            return null;\n        };\n\n        // Returns an interator to the tree node immediately before (or at) the element\n        lowerBound(data) {\n            return this._bound(data, this._comparator);\n        };\n\n        // Returns an interator to the tree node immediately after (or at) the element\n        upperBound(data) {\n            var cmp = this._comparator;\n\n            function reverse_cmp(a, b) {\n                return cmp(b, a);\n            }\n\n            return this._bound(data, reverse_cmp);\n        };\n\n        // returns null if tree is empty\n        min() {\n            var res = this._root;\n            if (res === null) {\n                return null;\n            }\n\n            while (res.left !== null) {\n                res = res.left;\n            }\n\n            return res.data;\n        };\n\n        // returns null if tree is empty\n        max() {\n            var res = this._root;\n            if (res === null) {\n                return null;\n            }\n\n            while (res.right !== null) {\n                res = res.right;\n            }\n\n            return res.data;\n        };\n\n        // returns a null iterator\n        // call next() or prev() to point to an element\n        iterator(): Iterator {\n            return new Iterator(this);\n        };\n\n        // calls cb on each node's data, in order\n        each(cb) {\n            var it = this.iterator(), data;\n            while ((data = it.next()) !== null) {\n                cb(data);\n            }\n        };\n\n        // calls cb on each node's data, in reverse order\n        reach(cb) {\n            var it = this.iterator(), data;\n            while ((data = it.prev()) !== null) {\n                cb(data);\n            }\n        };\n\n        // used for lowerBound and upperBound\n        _bound(data, cmp) {\n            var cur = this._root;\n            var iter = this.iterator();\n\n            while (cur !== null) {\n                var c = this._comparator(data, cur.data);\n                if (c === 0) {\n                    iter._cursor = cur;\n                    return iter;\n                }\n                iter._ancestors.push(cur);\n                cur = cur.get_child(c > 0);\n            }\n\n            for (var i = iter._ancestors.length - 1; i >= 0; --i) {\n                cur = iter._ancestors[i];\n                if (cmp(data, cur.data) > 0) {\n                    iter._cursor = cur;\n                    iter._ancestors.length = i;\n                    return iter;\n                }\n            }\n\n            iter._ancestors.length = 0;\n            return iter;\n        };\n    }\n    export class Iterator {\n        _tree;\n        _ancestors;\n        _cursor;\n        constructor(tree) {\n            this._tree = tree;\n            this._ancestors = [];\n            this._cursor = null;\n        }\n\n        data() {\n            return this._cursor !== null ? this._cursor.data : null;\n        };\n\n        // if null-iterator, returns first node\n        // otherwise, returns next node\n        next() {\n            if (this._cursor === null) {\n                var root = this._tree._root;\n                if (root !== null) {\n                    this._minNode(root);\n                }\n            }\n            else {\n                if (this._cursor.right === null) {\n                    // no greater node in subtree, go up to parent\n                    // if coming from a right child, continue up the stack\n                    var save;\n                    do {\n                        save = this._cursor;\n                        if (this._ancestors.length) {\n                            this._cursor = this._ancestors.pop();\n                        }\n                        else {\n                            this._cursor = null;\n                            break;\n                        }\n                    } while (this._cursor.right === save);\n                }\n                else {\n                    // get the next node from the subtree\n                    this._ancestors.push(this._cursor);\n                    this._minNode(this._cursor.right);\n                }\n            }\n            return this._cursor !== null ? this._cursor.data : null;\n        };\n\n        // if null-iterator, returns last node\n        // otherwise, returns previous node\n        prev() {\n            if (this._cursor === null) {\n                var root = this._tree._root;\n                if (root !== null) {\n                    this._maxNode(root);\n                }\n            }\n            else {\n                if (this._cursor.left === null) {\n                    var save;\n                    do {\n                        save = this._cursor;\n                        if (this._ancestors.length) {\n                            this._cursor = this._ancestors.pop();\n                        }\n                        else {\n                            this._cursor = null;\n                            break;\n                        }\n                    } while (this._cursor.left === save);\n                }\n                else {\n                    this._ancestors.push(this._cursor);\n                    this._maxNode(this._cursor.left);\n                }\n            }\n            return this._cursor !== null ? this._cursor.data : null;\n        };\n\n        _minNode(start) {\n            while (start.left !== null) {\n                this._ancestors.push(start);\n                start = start.left;\n            }\n            this._cursor = start;\n        };\n\n        _maxNode(start) {\n            while (start.right !== null) {\n                this._ancestors.push(start);\n                start = start.right;\n            }\n            this._cursor = start;\n        };\n    }\n\n    class Node {\n        data;\n        left;\n        right;\n        red;\n        constructor(data) {\n            this.data = data;\n            this.left = null;\n            this.right = null;\n            this.red = true;\n        }\n\n        get_child(dir) {\n            return dir ? this.right : this.left;\n        };\n\n        set_child(dir, val) {\n            if (dir) {\n                this.right = val;\n            }\n            else {\n                this.left = val;\n            }\n        };\n    }\n\n    export class RBTree<T> extends TreeBase {\n\n        _root;\n        _comparator;\n        size;\n        constructor(comparator: (a: T, b: T) => number) {\n            super();\n            this._root = null;\n            this._comparator = comparator;\n            this.size = 0;\n        }\n\n        // returns true if inserted, false if duplicate\n        insert(data) {\n            var ret = false;\n\n            if (this._root === null) {\n                // empty tree\n                this._root = new Node(data);\n                ret = true;\n                this.size++;\n            }\n            else {\n                var head = new Node(undefined); // fake tree root\n\n                var dir = false;\n                var last = false;\n\n                // setup\n                var gp = null; // grandparent\n                var ggp = head; // grand-grand-parent\n                var p = null; // parent\n                var node = this._root;\n                ggp.right = this._root;\n\n                // search down\n                while (true) {\n                    if (node === null) {\n                        // insert new node at the bottom\n                        node = new Node(data);\n                        p.set_child(dir, node);\n                        ret = true;\n                        this.size++;\n                    }\n                    else if (RBTree.is_red(node.left) && RBTree.is_red(node.right)) {\n                        // color flip\n                        node.red = true;\n                        node.left.red = false;\n                        node.right.red = false;\n                    }\n\n                    // fix red violation\n                    if (RBTree.is_red(node) && RBTree.is_red(p)) {\n                        var dir2 = ggp.right === gp;\n\n                        if (node === p.get_child(last)) {\n                            ggp.set_child(dir2, RBTree.single_rotate(gp, !last));\n                        }\n                        else {\n                            ggp.set_child(dir2, RBTree.double_rotate(gp, !last));\n                        }\n                    }\n\n                    var cmp = this._comparator(node.data, data);\n\n                    // stop if found\n                    if (cmp === 0) {\n                        break;\n                    }\n\n                    last = dir;\n                    dir = cmp < 0;\n\n                    // update helpers\n                    if (gp !== null) {\n                        ggp = gp;\n                    }\n                    gp = p;\n                    p = node;\n                    node = node.get_child(dir);\n                }\n\n                // update root\n                this._root = head.right;\n            }\n\n            // make root black\n            this._root.red = false;\n\n            return ret;\n        };\n\n        // returns true if removed, false if not found\n        remove(data) {\n            if (this._root === null) {\n                return false;\n            }\n\n            var head = new Node(undefined); // fake tree root\n            var node = head;\n            node.right = this._root;\n            var p = null; // parent\n            var gp = null; // grand parent\n            var found = null; // found item\n            var dir = true;\n\n            while (node.get_child(dir) !== null) {\n                var last = dir;\n\n                // update helpers\n                gp = p;\n                p = node;\n                node = node.get_child(dir);\n\n                var cmp = this._comparator(data, node.data);\n\n                dir = cmp > 0;\n\n                // save found node\n                if (cmp === 0) {\n                    found = node;\n                }\n\n                // push the red node down\n                if (!RBTree.is_red(node) && !RBTree.is_red(node.get_child(dir))) {\n                    if (RBTree.is_red(node.get_child(!dir))) {\n                        var sr = RBTree.single_rotate(node, dir);\n                        p.set_child(last, sr);\n                        p = sr;\n                    }\n                    else if (!RBTree.is_red(node.get_child(!dir))) {\n                        var sibling = p.get_child(!last);\n                        if (sibling !== null) {\n                            if (!RBTree.is_red(sibling.get_child(!last)) && !RBTree.is_red(sibling.get_child(last))) {\n                                // color flip\n                                p.red = false;\n                                sibling.red = true;\n                                node.red = true;\n                            }\n                            else {\n                                var dir2 = gp.right === p;\n\n                                if (RBTree.is_red(sibling.get_child(last))) {\n                                    gp.set_child(dir2, RBTree.double_rotate(p, last));\n                                }\n                                else if (RBTree.is_red(sibling.get_child(!last))) {\n                                    gp.set_child(dir2, RBTree.single_rotate(p, last));\n                                }\n\n                                // ensure correct coloring\n                                var gpc = gp.get_child(dir2);\n                                gpc.red = true;\n                                node.red = true;\n                                gpc.left.red = false;\n                                gpc.right.red = false;\n                            }\n                        }\n                    }\n                }\n            }\n\n            // replace and remove if found\n            if (found !== null) {\n                found.data = node.data;\n                p.set_child(p.right === node, node.get_child(node.left === null));\n                this.size--;\n            }\n\n            // update root and make it black\n            this._root = head.right;\n            if (this._root !== null) {\n                this._root.red = false;\n            }\n\n            return found !== null;\n        };\n\n        static is_red(node) {\n            return node !== null && node.red;\n        }\n\n        static single_rotate(root, dir) {\n            var save = root.get_child(!dir);\n\n            root.set_child(!dir, save.get_child(dir));\n            save.set_child(dir, root);\n\n            root.red = true;\n            save.red = false;\n\n            return save;\n        }\n\n        static double_rotate(root, dir) {\n            root.set_child(!dir, RBTree.single_rotate(root.get_child(!dir), !dir));\n            return RBTree.single_rotate(root, dir);\n        }\n    }\n","import {Constraint, Variable, Solver} from './vpsc'\nimport {RBTree} from './rbtree'\nimport {Point} from './geom'\n\n    export interface Leaf {\n        bounds: Rectangle;\n        variable: Variable;\n    }\n\n    export interface ProjectionGroup {\n        bounds: Rectangle;\n        padding: number;\n        stiffness: number;\n        leaves: Leaf[];\n        groups: ProjectionGroup[];\n        minVar: Variable;\n        maxVar: Variable;\n    }\n\n    export function computeGroupBounds(g: ProjectionGroup): Rectangle {\n        g.bounds = typeof g.leaves !== \"undefined\" ?\n            g.leaves.reduce((r: Rectangle, c) => c.bounds.union(r), Rectangle.empty()) :\n            Rectangle.empty();\n        if (typeof g.groups !== \"undefined\")\n            g.bounds = <Rectangle>g.groups.reduce((r: Rectangle, c) => computeGroupBounds(c).union(r), g.bounds);\n        g.bounds = g.bounds.inflate(g.padding);\n        return g.bounds;\n    }\n\n    export class Rectangle {\n        constructor(\n            public x: number,\n            public X: number,\n            public y: number,\n            public Y: number) { }\n\n        static empty(): Rectangle { return new Rectangle(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY); }\n\n        cx(): number { return (this.x + this.X) / 2; }\n\n        cy(): number { return (this.y + this.Y) / 2; }\n\n        overlapX(r: Rectangle): number {\n            var ux = this.cx(), vx = r.cx();\n            if (ux <= vx && r.x < this.X) return this.X - r.x;\n            if (vx <= ux && this.x < r.X) return r.X - this.x;\n            return 0;\n        }\n\n        overlapY(r: Rectangle): number {\n            var uy = this.cy(), vy = r.cy();\n            if (uy <= vy && r.y < this.Y) return this.Y - r.y;\n            if (vy <= uy && this.y < r.Y) return r.Y - this.y;\n            return 0;\n        }\n\n        setXCentre(cx: number): void {\n            var dx = cx - this.cx();\n            this.x += dx;\n            this.X += dx;\n        }\n\n        setYCentre(cy: number): void {\n            var dy = cy - this.cy();\n            this.y += dy;\n            this.Y += dy;\n        }\n\n        width(): number {\n            return this.X - this.x;\n        }\n\n        height(): number {\n            return this.Y - this.y;\n        }\n\n        union(r: Rectangle): Rectangle {\n            return new Rectangle(Math.min(this.x, r.x), Math.max(this.X, r.X), Math.min(this.y, r.y), Math.max(this.Y, r.Y));\n        }\n\n        /**\n         * return any intersection points between the given line and the sides of this rectangle\n         * @method lineIntersection\n         * @param x1 number first x coord of line\n         * @param y1 number first y coord of line\n         * @param x2 number second x coord of line\n         * @param y2 number second y coord of line\n         * @return any intersection points found\n         */\n        lineIntersections(x1: number, y1: number, x2: number, y2: number): Array<Point> {\n            var sides = [[this.x, this.y, this.X, this.y],\n                    [this.X, this.y, this.X, this.Y],\n                    [this.X, this.Y, this.x, this.Y],\n                [this.x, this.Y, this.x, this.y]];\n            var intersections = [];\n            for (var i = 0; i < 4; ++i) {\n                var r = Rectangle.lineIntersection(x1, y1, x2, y2, sides[i][0], sides[i][1], sides[i][2], sides[i][3]);\n                if (r !== null) intersections.push({ x: r.x, y: r.y });\n            }\n            return intersections;\n        }\n\n        /**\n         * return any intersection points between a line extending from the centre of this rectangle to the given point,\n         *  and the sides of this rectangle\n         * @method lineIntersection\n         * @param x2 number second x coord of line\n         * @param y2 number second y coord of line\n         * @return any intersection points found\n         */\n        rayIntersection(x2: number, y2: number): Point {\n            var ints = this.lineIntersections(this.cx(), this.cy(), x2, y2);\n            return ints.length > 0 ? ints[0] : null;\n        }\n\n        vertices(): Point[] {\n            return [\n                { x: this.x, y: this.y },\n                { x: this.X, y: this.y },\n                { x: this.X, y: this.Y },\n                { x: this.x, y: this.Y }];\n        }\n\n        static lineIntersection(\n            x1: number, y1: number,\n            x2: number, y2: number,\n            x3: number, y3: number,\n            x4: number, y4: number): Point {\n            var dx12 = x2 - x1, dx34 = x4 - x3,\n                dy12 = y2 - y1, dy34 = y4 - y3,\n                denominator = dy34 * dx12 - dx34 * dy12;\n            if (denominator == 0) return null;\n            var dx31 = x1 - x3, dy31 = y1 - y3,\n                numa = dx34 * dy31 - dy34 * dx31,\n                a = numa / denominator,\n                numb = dx12 * dy31 - dy12 * dx31,\n                b = numb / denominator;\n            if (a >= 0 && a <= 1 && b >= 0 && b <= 1) {\n                return {\n                    x: x1 + a * dx12,\n                    y: y1 + a * dy12\n                };\n            }\n            return null;\n        }\n\n        inflate(pad: number): Rectangle {\n            return new Rectangle(this.x - pad, this.X + pad, this.y - pad, this.Y + pad);\n        }\n    }\n\n    /**\n     * Returns the endpoints of a line that connects the centre of two rectangles.\n     * @param {Rectangle} [source] The source Rectangle.\n     * @param {Rectangle} [target] The target Rectangle.\n     * @param {number} [ah] The size of the arrow head, a distance to shorten the\n     *                      line by.\n     * @return An object with three point properties, the intersection with the\n     *         source rectangle (sourceIntersection), the intersection with then\n     *         target rectangle (targetIntersection), and the point an arrow\n     *         head of the specified size would need to start (arrowStart).\n     */\n    export function makeEdgeBetween(source: Rectangle, target: Rectangle, ah: number)\n        : { sourceIntersection: Point; targetIntersection: Point; arrowStart: Point } {\n        const si = source.rayIntersection(target.cx(), target.cy()) || { x: source.cx(), y: source.cy() },\n            ti = target.rayIntersection(source.cx(), source.cy()) || { x: target.cx(), y: target.cy() },\n            dx = ti.x - si.x,\n            dy = ti.y - si.y,\n            l = Math.sqrt(dx * dx + dy * dy), al = l - ah;\n        return {\n            sourceIntersection: si,\n            targetIntersection: ti,\n            arrowStart: { x: si.x + al * dx / l, y: si.y + al * dy / l }\n        }\n    }\n\n    /**\n     * Returns the intersection of a line from the given point to the centre\n     * of the target rectangle where it intersects the rectanngle.\n     * @param [source] The source point.\n     * @param {Rectangle} [target] The target Rectangle.\n     * @param {number} [ah] The size of the arrow head, a distance to shorten the\n     *                      line by.\n     * @return The point an arrow head of the specified size would need to start.\n     */\n    export function makeEdgeTo(s: { x: number; y: number }, target: Rectangle, ah: number): Point {\n        var ti = target.rayIntersection(s.x, s.y);\n        if (!ti) ti = { x: target.cx(), y: target.cy() };\n        var dx = ti.x - s.x,\n            dy = ti.y - s.y,\n            l = Math.sqrt(dx * dx + dy * dy);\n        return { x: ti.x - ah * dx / l, y: ti.y - ah * dy / l };\n    }\n\n    class Node {\n        prev: RBTree<Node>;\n        next: RBTree<Node>;\n\n        constructor(public v: Variable, public r: Rectangle, public pos: number) {\n            this.prev = makeRBTree();\n            this.next = makeRBTree();\n        }\n    }\n\n    class Event {\n        constructor(public isOpen: boolean, public v: Node, public pos: number) {}\n    }\n\n    function compareEvents(a: Event, b: Event): number {\n        if (a.pos > b.pos) {\n            return 1;\n        }\n        if (a.pos < b.pos) {\n            return -1;\n        }\n        if (a.isOpen) {\n            // open must come before close\n            return -1;\n        }\n        if (b.isOpen) {\n            // open must come before close\n            return 1;\n        }\n        return 0;\n    }\n\n    function makeRBTree(): RBTree<Node> {\n        return new RBTree<Node>((a, b) => a.pos - b.pos);\n    }\n\n    interface RectAccessors {\n        getCentre: (r: Rectangle) => number;\n        getOpen: (r: Rectangle) => number;\n        getClose: (r: Rectangle) => number;\n        getSize: (r: Rectangle) => number;\n        makeRect: (open: number, close: number, center: number, size: number) => Rectangle;\n        findNeighbours: (v: Node, scanline: RBTree<Node>) => void;\n    }\n\n    var xRect: RectAccessors = {\n        getCentre: r=> r.cx(),\n        getOpen: r=> r.y,\n        getClose: r=> r.Y,\n        getSize: r=> r.width(),\n        makeRect: (open, close, center, size) => new Rectangle(center - size / 2, center + size / 2, open, close) ,\n        findNeighbours: findXNeighbours\n    };\n\n    var yRect: RectAccessors = {\n        getCentre: r=> r.cy(),\n        getOpen: r=> r.x,\n        getClose: r=> r.X,\n        getSize: r=> r.height(),\n        makeRect: (open, close, center, size) => new Rectangle(open, close, center - size / 2, center + size / 2),\n        findNeighbours: findYNeighbours\n    };\n\n    function generateGroupConstraints(root: ProjectionGroup, f: RectAccessors, minSep: number, isContained: boolean = false): Constraint[]\n    {\n        var padding = root.padding,\n            gn = typeof root.groups !== 'undefined' ? root.groups.length : 0,\n            ln = typeof root.leaves !== 'undefined' ? root.leaves.length : 0,\n            childConstraints: Constraint[] = !gn ? []\n            : root.groups.reduce((ccs: Constraint[], g) => ccs.concat(generateGroupConstraints(g, f, minSep, true)), []),\n            n = (isContained ? 2 : 0) + ln + gn,\n            vs: Variable[] = new Array(n),\n            rs: Rectangle[] = new Array(n),\n            i = 0,\n            add = (r, v) => { rs[i] = r; vs[i++] = v };\n        if (isContained) {\n            // if this group is contained by another, then we add two dummy vars and rectangles for the borders\n            var b: Rectangle = root.bounds,\n                c = f.getCentre(b), s = f.getSize(b) / 2,\n                open = f.getOpen(b), close = f.getClose(b),\n                min = c - s + padding / 2, max = c + s - padding / 2;\n            root.minVar.desiredPosition = min;\n            add(f.makeRect(open, close, min, padding), root.minVar);\n            root.maxVar.desiredPosition = max;\n            add(f.makeRect(open, close, max, padding), root.maxVar);\n        }\n        if (ln) root.leaves.forEach(l => add(l.bounds, l.variable));\n        if (gn) root.groups.forEach(g => {\n            var b: Rectangle = g.bounds;\n            add(f.makeRect(f.getOpen(b), f.getClose(b), f.getCentre(b), f.getSize(b)), g.minVar);\n        });\n        var cs = generateConstraints(rs, vs, f, minSep);\n        if (gn) {\n            vs.forEach(v => { v.cOut = [], v.cIn = [] });\n            cs.forEach(c => { c.left.cOut.push(c), c.right.cIn.push(c) });\n            root.groups.forEach(g => {\n                var gapAdjustment = (g.padding - f.getSize(g.bounds)) / 2;\n                g.minVar.cIn.forEach(c => c.gap += gapAdjustment);\n                g.minVar.cOut.forEach(c => { c.left = g.maxVar; c.gap += gapAdjustment; });\n            });\n        }\n        return childConstraints.concat(cs);\n    }\n\n    function generateConstraints(rs: Rectangle[], vars: Variable[],\n        rect: RectAccessors, minSep: number): Constraint[]\n    {\n        var i, n = rs.length;\n        var N = 2 * n;\n        console.assert(vars.length >= n);\n        var events = new Array<Event>(N);\n        for (i = 0; i < n; ++i) {\n            var r = rs[i];\n            var v = new Node(vars[i], r, rect.getCentre(r));\n            events[i] = new Event(true, v, rect.getOpen(r));\n            events[i + n] = new Event(false, v, rect.getClose(r));\n        }\n        events.sort(compareEvents);\n        var cs = new Array<Constraint>();\n        var scanline = makeRBTree();\n        for (i = 0; i < N; ++i) {\n            var e = events[i];\n            var v = e.v;\n            if (e.isOpen) {\n                scanline.insert(v);\n                rect.findNeighbours(v, scanline);\n            } else {\n                // close event\n                scanline.remove(v);\n                var makeConstraint = (l, r) => {\n                    var sep = (rect.getSize(l.r) + rect.getSize(r.r)) / 2 + minSep;\n                    cs.push(new Constraint(l.v, r.v, sep));\n                };\n                var visitNeighbours = (forward, reverse, mkcon) => {\n                    var u, it = v[forward].iterator();\n                    while ((u = it[forward]()) !== null) {\n                        mkcon(u, v);\n                        u[reverse].remove(v);\n                    }\n                };\n                visitNeighbours(\"prev\", \"next\", (u, v) => makeConstraint(u, v));\n                visitNeighbours(\"next\", \"prev\", (u, v) => makeConstraint(v, u));\n            }\n        }\n        console.assert(scanline.size === 0);\n        return cs;\n    }\n\n    function findXNeighbours(v: Node, scanline: RBTree<Node>): void {\n        var f = (forward, reverse) => {\n            var it = scanline.findIter(v);\n            var u;\n            while ((u = it[forward]()) !== null) {\n                var uovervX = u.r.overlapX(v.r);\n                if (uovervX <= 0 || uovervX <= u.r.overlapY(v.r)) {\n                    v[forward].insert(u);\n                    u[reverse].insert(v);\n                }\n                if (uovervX <= 0) {\n                    break;\n                }\n            }\n        }\n        f(\"next\", \"prev\");\n        f(\"prev\", \"next\");\n    }\n\n    function findYNeighbours(v: Node, scanline: RBTree<Node>): void {\n        var f = (forward, reverse) => {\n            var u = scanline.findIter(v)[forward]();\n            if (u !== null && u.r.overlapX(v.r) > 0) {\n                v[forward].insert(u);\n                u[reverse].insert(v);\n            }\n        }\n        f(\"next\", \"prev\");\n        f(\"prev\", \"next\");\n    }\n\n    export function generateXConstraints(rs: Rectangle[], vars: Variable[]): Constraint[] {\n        return generateConstraints(rs, vars, xRect, 1e-6);\n    }\n\n    export function generateYConstraints(rs: Rectangle[], vars: Variable[]): Constraint[] {\n        return generateConstraints(rs, vars, yRect, 1e-6);\n    }\n\n    export function generateXGroupConstraints(root: ProjectionGroup): Constraint[] {\n        return generateGroupConstraints(root, xRect, 1e-6);\n    }\n\n    export function generateYGroupConstraints(root: ProjectionGroup): Constraint[] {\n        return generateGroupConstraints(root, yRect, 1e-6);\n    }\n\n    export function removeOverlaps(rs: Rectangle[]): void {\n        var vs = rs.map(r => new Variable(r.cx()));\n        var cs = generateXConstraints(rs, vs);\n        var solver = new Solver(vs, cs);\n        solver.solve();\n        vs.forEach((v, i) => rs[i].setXCentre(v.position()));\n        vs = rs.map(r=> new Variable(r.cy()));\n        cs = generateYConstraints(rs, vs);\n        solver = new Solver(vs, cs);\n        solver.solve();\n        vs.forEach((v, i) => rs[i].setYCentre(v.position()));\n    }\n\n    export interface GraphNode extends Leaf {\n        fixed: boolean;\n        fixedWeight?: number;\n        width: number;\n        height: number;\n        x: number;\n        y: number;\n        px: number;\n        py: number;\n    }\n\n    export class IndexedVariable extends Variable {\n        constructor(public index: number, w: number) {\n            super(0, w);\n        }\n    }\n\n    export class Projection {\n        private xConstraints: Constraint[];\n        private yConstraints: Constraint[];\n        private variables: Variable[];\n\n        constructor(private nodes: GraphNode[],\n            private groups: ProjectionGroup[],\n            private rootGroup: ProjectionGroup = null,\n            constraints: any[]= null,\n            private avoidOverlaps: boolean = false)\n        {\n            this.variables = nodes.map((v, i) => {\n                return v.variable = new IndexedVariable(i, 1);\n            });\n\n            if (constraints) this.createConstraints(constraints);\n\n            if (avoidOverlaps && rootGroup && typeof rootGroup.groups !== 'undefined') {\n                nodes.forEach(v => {\n\t\t\t\t\tif (!v.width || !v.height)\n\t\t\t\t\t{\n\t\t\t\t\t\t//If undefined, default to nothing\n\t\t\t\t\t\tv.bounds = new Rectangle(v.x, v.x, v.y, v.y);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n                    var w2 = v.width / 2, h2 = v.height / 2;\n                    v.bounds = new Rectangle(v.x - w2, v.x + w2, v.y - h2, v.y + h2);\n                });\n                computeGroupBounds(rootGroup);\n                var i = nodes.length;\n                groups.forEach(g => {\n                    this.variables[i] = g.minVar = new IndexedVariable(i++, typeof g.stiffness !== \"undefined\" ? g.stiffness : 0.01);\n                    this.variables[i] = g.maxVar = new IndexedVariable(i++, typeof g.stiffness !== \"undefined\" ? g.stiffness : 0.01);\n                });\n            }\n        }\n\n\n        private createSeparation(c: any) : Constraint {\n            return new Constraint(\n                this.nodes[c.left].variable,\n                this.nodes[c.right].variable,\n                c.gap,\n                typeof c.equality !== \"undefined\" ? c.equality : false);\n        }\n\n        // simple satisfaction of alignment constraints to ensure initial feasibility\n        private makeFeasible(c: any) {\n            if (!this.avoidOverlaps) return;\n            // sort nodes in constraint by position (along \"guideline\")\n            var axis = 'x', dim = 'width';\n            if (c.axis === 'x') axis = 'y', dim = 'height';\n            var vs: GraphNode[] = c.offsets.map(o => this.nodes[o.node]).sort((a, b) => a[axis] - b[axis]);\n            var p: GraphNode = null;\n            vs.forEach(v => {\n                // if two nodes overlap then shove the second one along\n                if (p) {\n                    let nextPos = p[axis] + p[dim];\n                    if (nextPos > v[axis]) {\n                        v[axis] = nextPos;\n                    }\n                }\n                p = v;\n            });\n        }\n\n        private createAlignment(c: any) {\n            var u = this.nodes[c.offsets[0].node].variable;\n            this.makeFeasible(c);\n            var cs = c.axis === 'x' ? this.xConstraints : this.yConstraints;\n            c.offsets.slice(1).forEach(o => {\n                var v = this.nodes[o.node].variable;\n                cs.push(new Constraint(u, v, o.offset, true));\n            });\n        }\n\n        private createConstraints(constraints: any[]) {\n            var isSep = c => typeof c.type === 'undefined' || c.type === 'separation';\n            this.xConstraints = constraints\n                .filter(c => c.axis === \"x\" && isSep(c))\n                .map(c => this.createSeparation(c));\n            this.yConstraints = constraints\n                .filter(c => c.axis === \"y\" && isSep(c))\n                .map(c => this.createSeparation(c));\n            constraints\n                .filter(c => c.type === 'alignment')\n                .forEach(c => this.createAlignment(c));\n        }\n\n        private setupVariablesAndBounds(x0: Float32Array, y0: Float32Array, desired: Float32Array, getDesired: (v: GraphNode) => number) {\n            this.nodes.forEach((v, i) => {\n                if (v.fixed) {\n                    v.variable.weight = v.fixedWeight ? v.fixedWeight : 1000;\n                    desired[i] = getDesired(v);\n                } else {\n                    v.variable.weight = 1;\n                }\n                var w = (v.width || 0) / 2, h = (v.height || 0) / 2;\n                var ix = x0[i], iy = y0[i];\n                v.bounds = new Rectangle(ix - w, ix + w, iy - h, iy + h);\n            });\n        }\n\n        xProject(x0: Float32Array, y0: Float32Array, x: Float32Array) {\n            if (!this.rootGroup && !(this.avoidOverlaps || this.xConstraints)) return;\n            this.project(x0, y0, x0, x, v=> v.px, this.xConstraints, generateXGroupConstraints,\n                v => v.bounds.setXCentre(x[(<IndexedVariable>v.variable).index] = v.variable.position()),\n                g => {\n                    var xmin = x[(<IndexedVariable>g.minVar).index] = g.minVar.position();\n                    var xmax = x[(<IndexedVariable>g.maxVar).index] = g.maxVar.position();\n                    var p2 = g.padding / 2;\n                    g.bounds.x = xmin - p2;\n                    g.bounds.X = xmax + p2;\n                });\n        }\n\n        yProject(x0: Float32Array, y0: Float32Array, y: Float32Array) {\n            if (!this.rootGroup && !this.yConstraints) return;\n            this.project(x0, y0, y0, y, v=> v.py, this.yConstraints, generateYGroupConstraints,\n                v => v.bounds.setYCentre(y[(<IndexedVariable>v.variable).index] = v.variable.position()),\n                g => {\n                    var ymin = y[(<IndexedVariable>g.minVar).index] = g.minVar.position();\n                    var ymax = y[(<IndexedVariable>g.maxVar).index] = g.maxVar.position();\n                    var p2 = g.padding / 2;\n                    g.bounds.y = ymin - p2;;\n                    g.bounds.Y = ymax + p2;\n                });\n        }\n\n        projectFunctions(): { (x0: Float32Array, y0: Float32Array, r: Float32Array): void }[]{\n            return [\n                (x0, y0, x) => this.xProject(x0, y0, x),\n                (x0, y0, y) => this.yProject(x0, y0, y)\n            ];\n        }\n\n        private project(x0: Float32Array, y0: Float32Array, start: Float32Array, desired: Float32Array,\n            getDesired: (v: GraphNode) => number,\n            cs: Constraint[],\n            generateConstraints: (g: ProjectionGroup) => Constraint[],\n            updateNodeBounds: (v: GraphNode) => any,\n            updateGroupBounds: (g: ProjectionGroup) => any)\n        {\n            this.setupVariablesAndBounds(x0, y0, desired, getDesired);\n            if (this.rootGroup && this.avoidOverlaps) {\n                computeGroupBounds(this.rootGroup);\n                cs = cs.concat(generateConstraints(this.rootGroup));\n            }\n            this.solve(this.variables, cs, start, desired);\n            this.nodes.forEach(updateNodeBounds);\n            if (this.rootGroup && this.avoidOverlaps) {\n                this.groups.forEach(updateGroupBounds);\n                computeGroupBounds(this.rootGroup);\n            }\n        }\n\n        private solve(vs: Variable[], cs: Constraint[], starting: Float32Array, desired: Float32Array) {\n            var solver = new Solver(vs, cs);\n            solver.setStartingPositions(starting);\n            solver.setDesiredPositions(desired);\n            solver.solve();\n        }\n    }\n","\nexport class PairingHeap<T> {\n    private subheaps : PairingHeap<T>[];\n    // from: https://gist.github.com/nervoussystem\n    //{elem:object, subheaps:[array of heaps]}\n    constructor(public elem: T) {\n        this.subheaps = [];\n    }\n\n    public toString(selector) : string {\n        var str = \"\", needComma = false;\n        for (var i = 0; i < this.subheaps.length; ++i) {\n            var subheap: PairingHeap<T> = this.subheaps[i];\n            if (!subheap.elem) {\n                needComma = false;\n                continue;\n            }\n            if (needComma) {\n                str = str + \",\";\n            }\n            str = str + subheap.toString(selector);\n            needComma = true;\n        }\n        if (str !== \"\") {\n            str = \"(\" + str + \")\";\n        }\n        return (this.elem ? selector(this.elem) : \"\") + str;\n    }\n\n    public forEach(f) {\n        if (!this.empty()) {\n            f(this.elem, this);\n            this.subheaps.forEach(s => s.forEach(f));\n        }\n    }\n\n    public count(): number {\n        return this.empty() ? 0 : 1 + this.subheaps.reduce((n: number, h: PairingHeap<T>) => {\n            return n + h.count();\n        }, 0);\n    }\n\n    public min() : T {\n        return this.elem;\n    }\n\n    public empty() : boolean {\n        return this.elem == null;\n    }\n\n    public contains(h: PairingHeap<T>): boolean {\n        if (this === h) return true;\n        for (var i = 0; i < this.subheaps.length; i++) {\n            if (this.subheaps[i].contains(h)) return true;\n        }\n        return false;\n    }\n\n    public isHeap(lessThan: (a: T, b: T) => boolean): boolean {\n        return this.subheaps.every(h=> lessThan(this.elem, h.elem) && h.isHeap(lessThan));\n    }\n\n    public insert(obj : T, lessThan) : PairingHeap<T> {\n        return this.merge(new PairingHeap<T>(obj), lessThan);\n    }\n\n    public merge(heap2: PairingHeap<T>, lessThan): PairingHeap<T> {\n        if (this.empty()) return heap2;\n        else if (heap2.empty()) return this;\n        else if (lessThan(this.elem, heap2.elem)) {\n            this.subheaps.push(heap2);\n            return this;\n        } else {\n            heap2.subheaps.push(this);\n            return heap2;\n        }\n    }\n\n    public removeMin(lessThan: (a: T, b: T) => boolean): PairingHeap<T> {\n        if (this.empty()) return null;\n        else return this.mergePairs(lessThan);\n    }\n\n    public mergePairs(lessThan: (a: T, b: T) => boolean) : PairingHeap<T> {\n        if (this.subheaps.length == 0) return new PairingHeap<T>(null);\n        else if (this.subheaps.length == 1) { return this.subheaps[0]; }\n        else {\n            var firstPair = this.subheaps.pop().merge(this.subheaps.pop(), lessThan);\n            var remaining = this.mergePairs(lessThan);\n            return firstPair.merge(remaining, lessThan);\n        }\n    }\n    public decreaseKey(subheap: PairingHeap<T>, newValue: T, setHeapNode: (e: T, h: PairingHeap<T>)=>void, lessThan: (a: T, b: T) => boolean): PairingHeap<T> {\n        var newHeap = subheap.removeMin(lessThan);\n        //reassign subheap values to preserve tree\n        subheap.elem = newHeap.elem;\n        subheap.subheaps = newHeap.subheaps;\n        if (setHeapNode !== null && newHeap.elem !== null) {\n            setHeapNode(subheap.elem, subheap);\n        }\n        var pairingNode = new PairingHeap(newValue);\n        if (setHeapNode !== null) {\n            setHeapNode(newValue, pairingNode);\n        }\n        return this.merge(pairingNode, lessThan);\n    }\n}\n\n/**\n * @class PriorityQueue a min priority queue backed by a pairing heap\n */\nexport class PriorityQueue<T> {\n    private root : PairingHeap<T>;\n    constructor(private lessThan: (a: T, b: T) => boolean) { }\n    /**\n     * @method top\n     * @return the top element (the min element as defined by lessThan)\n     */\n    public top() : T {\n        if (this.empty()) { return null; }\n        return this.root.elem;\n    }\n    /**\n     * @method push\n     * put things on the heap\n     */\n    public push(...args: T[]): PairingHeap<T> {\n        var pairingNode;\n        for (var i = 0, arg; arg=args[i]; ++i) {\n            pairingNode = new PairingHeap(arg);\n            this.root = this.empty() ?\n                pairingNode : this.root.merge(pairingNode, this.lessThan);\n        }\n        return pairingNode;\n    }\n    /**\n     * @method empty\n     * @return true if no more elements in queue\n     */\n    public empty(): boolean {\n        return !this.root || !this.root.elem;\n    }\n    /**\n     * @method isHeap check heap condition (for testing)\n     * @return true if queue is in valid state\n     */\n    public isHeap(): boolean {\n        return this.root.isHeap(this.lessThan);\n    }\n    /**\n     * @method forEach apply f to each element of the queue\n     * @param f function to apply\n     */\n    public forEach(f) {\n        this.root.forEach(f);\n    }\n    /**\n     * @method pop remove and return the min element from the queue\n     */\n    public pop(): T {\n        if (this.empty()) {\n            return null;\n        }\n        var obj = this.root.min();\n        this.root = this.root.removeMin(this.lessThan);\n        return obj;\n    }\n    /**\n     * @method reduceKey reduce the key value of the specified heap node\n     */\n    public reduceKey(heapNode: PairingHeap<T>, newKey: T, setHeapNode: (e: T, h: PairingHeap<T>)=>void = null): void {\n        this.root = this.root.decreaseKey(heapNode, newKey, setHeapNode, this.lessThan);\n    }\n    public toString(selector) {\n        return this.root.toString(selector);\n    }\n    /**\n     * @method count\n     * @return number of elements in queue\n     */\n    public count() {\n        return this.root.count();\n    }\n}\n","import {PairingHeap, PriorityQueue} from './pqueue'\n\nclass Neighbour {\n    constructor(public id: number, public distance: number) { }\n}\n\nclass Node {\n    constructor(public id: number) {\n        this.neighbours = [];\n    }\n    neighbours: Neighbour[];\n    d: number;\n    prev: Node;\n    q: PairingHeap<Node>;\n}\n\nclass QueueEntry {\n    constructor(public node: Node, public prev: QueueEntry, public d: number) {}\n}\n\n/**\n * calculates all-pairs shortest paths or shortest paths from a single node\n * @class Calculator\n * @constructor\n * @param n {number} number of nodes\n * @param es {Edge[]} array of edges\n */\nexport class Calculator<Link> {\n    private neighbours: Node[];\n\n    constructor(public n: number, public es: Link[], getSourceIndex: (l: Link) => number, getTargetIndex: (l: Link) => number, getLength: (l: Link) => number) {\n        this.neighbours = new Array(this.n);\n        var i = this.n; while (i--) this.neighbours[i] = new Node(i);\n\n        i = this.es.length; while (i--) {\n            var e = this.es[i];\n            var u: number = getSourceIndex(e), v: number = getTargetIndex(e);\n            var d = getLength(e);\n            this.neighbours[u].neighbours.push(new Neighbour(v, d));\n            this.neighbours[v].neighbours.push(new Neighbour(u, d));\n        }\n    }\n\n    /**\n     * compute shortest paths for graph over n nodes with edges an array of source/target pairs\n     * edges may optionally have a length attribute.  1 is the default.\n     * Uses Johnson's algorithm.\n     *\n     * @method DistanceMatrix\n     * @return the distance matrix\n     */\n    DistanceMatrix(): number[][] {\n        var D = new Array(this.n);\n        for (var i = 0; i < this.n; ++i) {\n            D[i] = this.dijkstraNeighbours(i);\n        }\n        return D;\n    }\n\n    /**\n     * get shortest paths from a specified start node\n     * @method DistancesFromNode\n     * @param start node index\n     * @return array of path lengths\n     */\n    DistancesFromNode(start: number): number[] {\n        return this.dijkstraNeighbours(start);\n    }\n\n    PathFromNodeToNode(start: number, end: number): number[] {\n        return this.dijkstraNeighbours(start, end);\n    }\n\n    // find shortest path from start to end, with the opportunity at\n    // each edge traversal to compute a custom cost based on the\n    // previous edge.  For example, to penalise bends.\n    PathFromNodeToNodeWithPrevCost(\n        start: number,\n        end: number,\n        prevCost: (u:number,v:number,w:number)=>number): number[]\n    {\n        var q = new PriorityQueue<QueueEntry>((a, b) => a.d <= b.d),\n            u: Node = this.neighbours[start],\n            qu: QueueEntry = new QueueEntry(u,null,0),\n            visitedFrom = {};\n        q.push(qu);\n        while(!q.empty()) {\n            qu = q.pop();\n            u = qu.node;\n            if (u.id === end) {\n                break;\n            }\n            var i = u.neighbours.length; while (i--) {\n                var neighbour = u.neighbours[i],\n                    v = this.neighbours[neighbour.id];\n\n                // don't double back\n                if (qu.prev && v.id === qu.prev.node.id) continue;\n\n                // don't retraverse an edge if it has already been explored\n                // from a lower cost route\n                var viduid = v.id + ',' + u.id;\n                if(viduid in visitedFrom && visitedFrom[viduid] <= qu.d)\n                    continue;\n\n                var cc = qu.prev ? prevCost(qu.prev.node.id, u.id, v.id) : 0,\n                    t = qu.d + neighbour.distance + cc;\n\n                // store cost of this traversal\n                visitedFrom[viduid] = t;\n                q.push(new QueueEntry(v, qu, t));\n            }\n        }\n        var path:number[] = [];\n        while (qu.prev) {\n            qu = qu.prev;\n            path.push(qu.node.id);\n        }\n        return path;\n    }\n\n    private dijkstraNeighbours(start: number, dest: number = -1): number[] {\n        var q = new PriorityQueue<Node>((a, b) => a.d <= b.d),\n            i = this.neighbours.length,\n            d: number[] = new Array(i);\n        while (i--) {\n            var node: Node = this.neighbours[i];\n            node.d = i === start ? 0 : Number.POSITIVE_INFINITY;\n            node.q = q.push(node);\n        }\n        while (!q.empty()) {\n            // console.log(q.toString(function (u) { return u.id + \"=\" + (u.d === Number.POSITIVE_INFINITY ? \"\\u221E\" : u.d.toFixed(2) )}));\n            var u = q.pop();\n            d[u.id] = u.d;\n            if (u.id === dest) {\n                var path: number[] = [];\n                var v = u;\n                while (typeof v.prev !== 'undefined') {\n                    path.push(v.prev.id);\n                    v = v.prev;\n                }\n                return path;\n            }\n            i = u.neighbours.length; while (i--) {\n                var neighbour = u.neighbours[i];\n                var v = this.neighbours[neighbour.id];\n                var t = u.d + neighbour.distance;\n                if (u.d !== Number.MAX_VALUE && v.d > t) {\n                    v.d = t;\n                    v.prev = u;\n                    q.reduceKey(v.q, v, (e,q)=>e.q = q);\n                }\n            }\n        }\n        return d;\n    }\n}\n","import {Rectangle} from './rectangle'\n    export class Point {\n        x: number;\n        y: number;\n    }\n\n    export class LineSegment {\n        constructor(public x1: number, public y1: number, public x2: number, public y2: number) { }\n    }\n\n    export class PolyPoint extends Point {\n        polyIndex: number;\n    }\n\n    /** tests if a point is Left|On|Right of an infinite line.\n     * @param points P0, P1, and P2\n     * @return >0 for P2 left of the line through P0 and P1\n     *            =0 for P2 on the line\n     *            <0 for P2 right of the line\n     */\n    export function isLeft(P0: Point, P1: Point, P2: Point): number {\n        return (P1.x - P0.x) * (P2.y - P0.y) - (P2.x - P0.x) * (P1.y - P0.y);\n    }\n\n    function above(p: Point, vi: Point, vj: Point): boolean {\n        return isLeft(p, vi, vj) > 0;\n    }\n\n    function below(p: Point, vi: Point, vj: Point): boolean {\n        return isLeft(p, vi, vj) < 0;\n    }\n\n\n    /**\n     * returns the convex hull of a set of points using Andrew's monotone chain algorithm\n     * see: http://geomalgorithms.com/a10-_hull-1.html#Monotone%20Chain\n     * @param S array of points\n     * @return the convex hull as an array of points\n     */\n    export function ConvexHull(S: Point[]): Point[] {\n        var P = S.slice(0).sort((a, b) => a.x !== b.x ? b.x - a.x : b.y - a.y);\n        var n = S.length, i;\n        var minmin = 0;\n        var xmin = P[0].x;\n        for (i = 1; i < n; ++i) {\n            if (P[i].x !== xmin) break;\n        }\n        var minmax = i - 1;\n        var H: Point[] = [];\n        H.push(P[minmin]); // push minmin point onto stack\n        if (minmax === n - 1) { // degenerate case: all x-coords == xmin\n            if (P[minmax].y !== P[minmin].y) // a  nontrivial segment\n                H.push(P[minmax]);\n        } else {\n            // Get the indices of points with max x-coord and min|max y-coord\n            var maxmin, maxmax = n - 1;\n            var xmax = P[n - 1].x;\n            for (i = n - 2; i >= 0; i--)\n                if (P[i].x !== xmax) break;\n            maxmin = i + 1;\n\n            // Compute the lower hull on the stack H\n            i = minmax;\n            while (++i <= maxmin) {\n                // the lower line joins P[minmin]  with P[maxmin]\n                if (isLeft(P[minmin], P[maxmin], P[i]) >= 0 && i < maxmin)\n                    continue; // ignore P[i] above or on the lower line\n\n                while (H.length > 1) // there are at least 2 points on the stack\n                {\n                    // test if  P[i] is left of the line at the stack top\n                    if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)\n                        break; // P[i] is a new hull  vertex\n                    else\n                        H.length -= 1; // pop top point off  stack\n                }\n                if (i != minmin) H.push(P[i]);\n            }\n\n            // Next, compute the upper hull on the stack H above the bottom hull\n            if (maxmax != maxmin) // if  distinct xmax points\n                H.push(P[maxmax]); // push maxmax point onto stack\n            var bot = H.length; // the bottom point of the upper hull stack\n            i = maxmin;\n            while (--i >= minmax) {\n                // the upper line joins P[maxmax]  with P[minmax]\n                if (isLeft(P[maxmax], P[minmax], P[i]) >= 0 && i > minmax)\n                    continue; // ignore P[i] below or on the upper line\n\n                while (H.length > bot) // at least 2 points on the upper stack\n                {\n                    // test if  P[i] is left of the line at the stack top\n                    if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)\n                        break; // P[i] is a new hull  vertex\n                    else\n                        H.length -= 1; // pop top point off  stack\n                }\n                if (i != minmin) H.push(P[i]); // push P[i] onto stack\n            }\n        }\n        return H;\n    }\n\n    // apply f to the points in P in clockwise order around the point p\n    export function clockwiseRadialSweep(p: Point, P: Point[], f: (p: Point) => void) {\n        P.slice(0).sort(\n            (a, b) => Math.atan2(a.y - p.y, a.x - p.x) - Math.atan2(b.y - p.y, b.x - p.x)\n            ).forEach(f);\n    }\n\n    function nextPolyPoint(p: PolyPoint, ps: PolyPoint[]): PolyPoint {\n        if (p.polyIndex === ps.length - 1) return ps[0];\n        return ps[p.polyIndex + 1];\n    }\n\n    function prevPolyPoint(p: PolyPoint, ps: PolyPoint[]): PolyPoint {\n        if (p.polyIndex === 0) return ps[ps.length - 1];\n        return ps[p.polyIndex - 1];\n    }\n\n    // tangent_PointPolyC(): fast binary search for tangents to a convex polygon\n    //    Input:  P = a 2D point (exterior to the polygon)\n    //            n = number of polygon vertices\n    //            V = array of vertices for a 2D convex polygon\n    //    Output: rtan = index of rightmost tangent point V[rtan]\n    //            ltan = index of leftmost tangent point V[ltan]\n    function tangent_PointPolyC(P: Point, V: Point[]): { rtan: number; ltan: number } {\n        // Rtangent_PointPolyC and Ltangent_PointPolyC require polygon to be\n        // \"closed\" with the first vertex duplicated at end, so V[n-1] = V[0].\n        let Vclosed = V.slice(0);  // Copy V\n        Vclosed.push(V[0]);        // Add V[0] at end\n\n        return { rtan: Rtangent_PointPolyC(P, Vclosed), ltan: Ltangent_PointPolyC(P, Vclosed) };\n    }\n\n\n    // Rtangent_PointPolyC(): binary search for convex polygon right tangent\n    //    Input:  P = a 2D point (exterior to the polygon)\n    //            n = number of polygon vertices\n    //            V = array of vertices for a 2D convex polygon with first\n    //                vertex duplicated as last, so V[n-1] = V[0]\n    //    Return: index \"i\" of rightmost tangent point V[i]\n    function Rtangent_PointPolyC(P: Point, V: Point[]): number {\n        var n = V.length - 1;\n\n        // use binary search for large convex polygons\n        var a: number, b: number, c: number;            // indices for edge chain endpoints\n        var upA: boolean, dnC: boolean;           // test for up direction of edges a and c\n\n        // rightmost tangent = maximum for the isLeft() ordering\n        // test if V[0] is a local maximum\n        if (below(P, V[1], V[0]) && !above(P, V[n - 1], V[0]))\n            return 0;               // V[0] is the maximum tangent point\n\n        for (a = 0, b = n; ;) {          // start chain = [0,n] with V[n]=V[0]\n            if (b - a === 1)\n                if (above(P, V[a], V[b]))\n                    return a;\n                else\n                    return b;\n\n            c = Math.floor((a + b) / 2);        // midpoint of [a,b], and 0<c<n\n            dnC = below(P, V[c + 1], V[c]);\n            if (dnC && !above(P, V[c - 1], V[c]))\n                return c;          // V[c] is the maximum tangent point\n\n            // no max yet, so continue with the binary search\n            // pick one of the two subchains [a,c] or [c,b]\n            upA = above(P, V[a + 1], V[a]);\n            if (upA) {                       // edge a points up\n                if (dnC)                         // edge c points down\n                    b = c;                           // select [a,c]\n                else {                           // edge c points up\n                    if (above(P, V[a], V[c]))     // V[a] above V[c]\n                        b = c;                       // select [a,c]\n                    else                          // V[a] below V[c]\n                        a = c;                       // select [c,b]\n                }\n            }\n            else {                           // edge a points down\n                if (!dnC)                        // edge c points up\n                    a = c;                           // select [c,b]\n                else {                           // edge c points down\n                    if (below(P, V[a], V[c]))     // V[a] below V[c]\n                        b = c;                       // select [a,c]\n                    else                          // V[a] above V[c]\n                        a = c;                       // select [c,b]\n                }\n            }\n        }\n    }\n\n    // Ltangent_PointPolyC(): binary search for convex polygon left tangent\n    //    Input:  P = a 2D point (exterior to the polygon)\n    //            n = number of polygon vertices\n    //            V = array of vertices for a 2D convex polygon with first\n    //                vertex duplicated as last, so V[n-1] = V[0]\n    //    Return: index \"i\" of leftmost tangent point V[i]\n    function Ltangent_PointPolyC(P: Point, V: Point[]): number {\n        var n = V.length - 1;\n        // use binary search for large convex polygons\n        var a: number, b: number, c: number;             // indices for edge chain endpoints\n        var dnA: boolean, dnC: boolean;           // test for down direction of edges a and c\n\n        // leftmost tangent = minimum for the isLeft() ordering\n        // test if V[0] is a local minimum\n        if (above(P, V[n - 1], V[0]) && !below(P, V[1], V[0]))\n            return 0;               // V[0] is the minimum tangent point\n\n        for (a = 0, b = n; ;) {          // start chain = [0,n] with V[n] = V[0]\n            if (b - a === 1)\n                if (below(P, V[a], V[b]))\n                    return a;\n                else\n                    return b;\n\n            c = Math.floor((a + b) / 2);        // midpoint of [a,b], and 0<c<n\n            dnC = below(P, V[c + 1], V[c]);\n            if (above(P, V[c - 1], V[c]) && !dnC)\n                return c;          // V[c] is the minimum tangent point\n\n            // no min yet, so continue with the binary search\n            // pick one of the two subchains [a,c] or [c,b]\n            dnA = below(P, V[a + 1], V[a]);\n            if (dnA) {                       // edge a points down\n                if (!dnC)                        // edge c points up\n                    b = c;                           // select [a,c]\n                else {                           // edge c points down\n                    if (below(P, V[a], V[c]))     // V[a] below V[c]\n                        b = c;                       // select [a,c]\n                    else                          // V[a] above V[c]\n                        a = c;                       // select [c,b]\n                }\n            }\n            else {                           // edge a points up\n                if (dnC)                         // edge c points down\n                    a = c;                           // select [c,b]\n                else {                           // edge c points up\n                    if (above(P, V[a], V[c]))     // V[a] above V[c]\n                        b = c;                       // select [a,c]\n                    else                          // V[a] below V[c]\n                        a = c;                       // select [c,b]\n                }\n            }\n        }\n    }\n\n    // RLtangent_PolyPolyC(): get the RL tangent between two convex polygons\n    //    Input:  m = number of vertices in polygon 1\n    //            V = array of vertices for convex polygon 1 with V[m]=V[0]\n    //            n = number of vertices in polygon 2\n    //            W = array of vertices for convex polygon 2 with W[n]=W[0]\n    //    Output: *t1 = index of tangent point V[t1] for polygon 1\n    //            *t2 = index of tangent point W[t2] for polygon 2\n    export function tangent_PolyPolyC(V: Point[], W: Point[], t1: (a: Point, b: Point[]) => number, t2: (a: Point, b: Point[]) => number, cmp1: (a: Point, b: Point, c: Point) => boolean, cmp2: (a: Point, b: Point, c: Point) => boolean): { t1: number; t2: number } {\n        var ix1: number, ix2: number;      // search indices for polygons 1 and 2\n\n        // first get the initial vertex on each polygon\n        ix1 = t1(W[0], V);   // right tangent from W[0] to V\n        ix2 = t2(V[ix1], W); // left tangent from V[ix1] to W\n\n        // ping-pong linear search until it stabilizes\n        var done = false;                    // flag when done\n        while (!done) {\n            done = true;                     // assume done until...\n            while (true) {\n                if (ix1 === V.length - 1) ix1 = 0;\n                if (cmp1(W[ix2], V[ix1], V[ix1 + 1])) break;\n                ++ix1;                       // get Rtangent from W[ix2] to V\n            }\n            while (true) {\n                if (ix2 === 0) ix2 = W.length - 1;\n                if (cmp2(V[ix1], W[ix2], W[ix2 - 1])) break;\n                --ix2;                       // get Ltangent from V[ix1] to W\n                done = false;                // not done if had to adjust this\n            }\n        }\n        return { t1: ix1, t2: ix2 };\n    }\n\n    export function LRtangent_PolyPolyC(V: Point[], W: Point[]): { t1: number; t2: number } {\n        var rl = RLtangent_PolyPolyC(W, V);\n        return { t1: rl.t2, t2: rl.t1 };\n    }\n\n    export function RLtangent_PolyPolyC(V: Point[], W: Point[]): { t1: number; t2: number } {\n        return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Ltangent_PointPolyC, above, below);\n    }\n\n    export function LLtangent_PolyPolyC(V: Point[], W: Point[]): { t1: number; t2: number } {\n        return tangent_PolyPolyC(V, W, Ltangent_PointPolyC, Ltangent_PointPolyC, below, below);\n    }\n\n    export function RRtangent_PolyPolyC(V: Point[], W: Point[]): { t1: number; t2: number } {\n        return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Rtangent_PointPolyC, above, above);\n    }\n\n    export class BiTangent {\n        constructor(public t1: number, public t2: number) { }\n    }\n\n    export class BiTangents {\n        rl: BiTangent;\n        lr: BiTangent;\n        ll: BiTangent;\n        rr: BiTangent;\n    }\n\n    export class TVGPoint extends Point {\n        vv: VisibilityVertex;\n    }\n\n    export class VisibilityVertex {\n        constructor(\n            public id: number,\n            public polyid: number,\n            public polyvertid: number,\n            public p: TVGPoint)\n        {\n            p.vv = this;\n        }\n    }\n\n    export class VisibilityEdge {\n        constructor(\n            public source: VisibilityVertex,\n            public target: VisibilityVertex) { }\n        length(): number {\n            var dx = this.source.p.x - this.target.p.x;\n            var dy = this.source.p.y - this.target.p.y;\n            return Math.sqrt(dx * dx + dy * dy);\n        }\n    }\n\n    export class TangentVisibilityGraph {\n        V: VisibilityVertex[] = [];\n        E: VisibilityEdge[] = [];\n        constructor(public P: TVGPoint[][], g0?: { V: VisibilityVertex[]; E: VisibilityEdge[] }) {\n            if (!g0) {\n                var n = P.length;\n                // For each node...\n                for (var i = 0; i < n; i++) {\n                    var p = P[i];\n                    // For each node vertex.\n                    for (var j = 0; j < p.length; ++j) {\n                        var pj = p[j],\n                            vv = new VisibilityVertex(this.V.length, i, j, pj);\n                        this.V.push(vv);\n                        // For the every iteration but the first, generate an\n                        // edge from the previous visibility vertex to the\n                        // current one.\n                        if (j > 0) this.E.push(new VisibilityEdge(p[j - 1].vv, vv));\n                    }\n                    // Add a visibility edge from the first vertex to the last.\n                    if (p.length > 1) this.E.push(new VisibilityEdge(p[0].vv, p[p.length - 1].vv));\n                }\n                for (var i = 0; i < n - 1; i++) {\n                    var Pi = P[i];\n                    for (var j = i + 1; j < n; j++) {\n                        var Pj = P[j],\n                            t = tangents(Pi, Pj);\n                        for (var q in t) {\n                            var c = t[q],\n                                source = Pi[c.t1], target = Pj[c.t2];\n                            this.addEdgeIfVisible(source, target, i, j);\n                        }\n                    }\n                }\n            } else {\n                this.V = g0.V.slice(0);\n                this.E = g0.E.slice(0);\n            }\n        }\n        addEdgeIfVisible(u: TVGPoint, v: TVGPoint, i1: number, i2: number) {\n            if (!this.intersectsPolys(new LineSegment(u.x, u.y, v.x, v.y), i1, i2)) {\n                this.E.push(new VisibilityEdge(u.vv, v.vv));\n            }\n        }\n        addPoint(p: TVGPoint, i1: number): VisibilityVertex {\n            var n = this.P.length;\n            this.V.push(new VisibilityVertex(this.V.length, n, 0, p));\n            for (var i = 0; i < n; ++i) {\n                if (i === i1) continue;\n                var poly = this.P[i],\n                    t = tangent_PointPolyC(p, poly);\n                this.addEdgeIfVisible(p, poly[t.ltan], i1, i);\n                this.addEdgeIfVisible(p, poly[t.rtan], i1, i);\n            }\n            return p.vv;\n        }\n        private intersectsPolys(l: LineSegment, i1: number, i2: number): boolean {\n            for (var i = 0, n = this.P.length; i < n; ++i) {\n                if (i != i1 && i != i2 && intersects(l, this.P[i]).length > 0) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    function intersects(l: LineSegment, P: Point[]) {\n        var ints = [];\n        for (var i = 1, n = P.length; i < n; ++i) {\n            var int = Rectangle.lineIntersection(\n                l.x1, l.y1,\n                l.x2, l.y2,\n                P[i - 1].x, P[i - 1].y,\n                P[i].x, P[i].y\n                );\n            if (int) ints.push(int);\n        }\n        return ints;\n    }\n\n    export function tangents(V: Point[], W: Point[]): BiTangents\n    {\n        var m = V.length - 1, n = W.length - 1;\n        var bt = new BiTangents();\n        for (var i = 0; i <= m; ++i) {\n            for (var j = 0; j <= n; ++j) {\n                var v1 = V[i == 0 ? m : i - 1];\n                var v2 = V[i];\n                var v3 = V[i == m ? 0 : i + 1];\n                var w1 = W[j == 0 ? n : j - 1];\n                var w2 = W[j];\n                var w3 = W[j == n ? 0 : j + 1];\n                var v1v2w2 = isLeft(v1, v2, w2);\n                var v2w1w2 = isLeft(v2, w1, w2);\n                var v2w2w3 = isLeft(v2, w2, w3);\n                var w1w2v2 = isLeft(w1, w2, v2);\n                var w2v1v2 = isLeft(w2, v1, v2);\n                var w2v2v3 = isLeft(w2, v2, v3);\n                if (v1v2w2 >= 0 && v2w1w2 >= 0 && v2w2w3 < 0\n                    && w1w2v2 >= 0 && w2v1v2 >= 0 && w2v2v3 < 0) {\n                        bt.ll = new BiTangent(i, j);\n                } else if (v1v2w2 <= 0 && v2w1w2 <= 0 && v2w2w3 > 0\n                    && w1w2v2 <= 0 && w2v1v2 <= 0 && w2v2v3 > 0) {\n                        bt.rr = new BiTangent(i, j);\n                } else if (v1v2w2 <= 0 && v2w1w2 > 0 && v2w2w3 <= 0\n                    && w1w2v2 >= 0 && w2v1v2 < 0 && w2v2v3 >= 0) {\n                        bt.rl = new BiTangent(i, j);\n                } else if (v1v2w2 >= 0 && v2w1w2 < 0 && v2w2w3 >= 0\n                    && w1w2v2 <= 0 && w2v1v2 > 0 && w2v2v3 <= 0) {\n                        bt.lr = new BiTangent(i, j);\n                }\n            }\n        }\n        return bt;\n    }\n\n    function isPointInsidePoly(p: Point, poly: Point[]): boolean {\n        for (var i = 1, n = poly.length; i < n; ++i)\n            if (below(poly[i - 1], poly[i], p)) return false;\n        return true;\n    }\n\n    function isAnyPInQ(p: Point[], q: Point[]): boolean {\n        return !p.every(v => !isPointInsidePoly(v, q));\n    }\n\n    export function polysOverlap(p: Point[], q: Point[]): boolean {\n        if (isAnyPInQ(p, q)) return true;\n        if (isAnyPInQ(q, p)) return true;\n        for (var i = 1, n = p.length; i < n; ++i) {\n            var v = p[i], u = p[i - 1];\n            if (intersects(new LineSegment(u.x, u.y, v.x, v.y), q).length > 0) return true;\n        }\n        return false;\n    }\n","    var packingOptions = {\n        PADDING: 10,\n        GOLDEN_SECTION: (1 + Math.sqrt(5)) / 2,\n        FLOAT_EPSILON: 0.0001,\n        MAX_INERATIONS: 100\n    };\n\n    // assign x, y to nodes while using box packing algorithm for disconnected graphs\n    export function applyPacking(graphs:Array<any>, w, h, node_size, desired_ratio = 1, centerGraph = true) {\n\n        var init_x = 0,\n            init_y = 0,\n\n            svg_width = w,\n            svg_height = h,\n\n            desired_ratio = typeof desired_ratio !== 'undefined' ? desired_ratio : 1,\n            node_size = typeof node_size !== 'undefined' ? node_size : 0,\n\n            real_width = 0,\n            real_height = 0,\n            min_width = 0,\n\n            global_bottom = 0,\n            line = [];\n\n        if (graphs.length == 0)\n            return;\n\n        /// that would take care of single nodes problem\n        // graphs.forEach(function (g) {\n        //     if (g.array.length == 1) {\n        //         g.array[0].x = 0;\n        //         g.array[0].y = 0;\n        //     }\n        // });\n\n        calculate_bb(graphs);\n        apply(graphs, desired_ratio);\n        if(centerGraph) {\n            put_nodes_to_right_positions(graphs);\n        }\n\n        // get bounding boxes for all separate graphs\n        function calculate_bb(graphs) {\n\n            graphs.forEach(function (g) {\n                calculate_single_bb(g)\n            });\n\n            function calculate_single_bb(graph) {\n                var min_x = Number.MAX_VALUE, min_y = Number.MAX_VALUE,\n                    max_x = 0, max_y = 0;\n\n                graph.array.forEach(function (v) {\n                    var w = typeof v.width !== 'undefined' ? v.width : node_size;\n                    var h = typeof v.height !== 'undefined' ? v.height : node_size;\n                    w /= 2;\n                    h /= 2;\n                    max_x = Math.max(v.x + w, max_x);\n                    min_x = Math.min(v.x - w, min_x);\n                    max_y = Math.max(v.y + h, max_y);\n                    min_y = Math.min(v.y - h, min_y);\n                });\n\n                graph.width = max_x - min_x;\n                graph.height = max_y - min_y;\n            }\n        }\n\n        //function plot(data, left, right, opt_x, opt_y) {\n        //    // plot the cost function\n        //    var plot_svg = d3.select(\"body\").append(\"svg\")\n        //        .attr(\"width\", function () { return 2 * (right - left); })\n        //        .attr(\"height\", 200);\n\n\n        //    var x = d3.time.scale().range([0, 2 * (right - left)]);\n\n        //    var xAxis = d3.svg.axis().scale(x).orient(\"bottom\");\n        //    plot_svg.append(\"g\").attr(\"class\", \"x axis\")\n        //        .attr(\"transform\", \"translate(0, 199)\")\n        //        .call(xAxis);\n\n        //    var lastX = 0;\n        //    var lastY = 0;\n        //    var value = 0;\n        //    for (var r = left; r < right; r += 1) {\n        //        value = step(data, r);\n        //        // value = 1;\n\n        //        plot_svg.append(\"line\").attr(\"x1\", 2 * (lastX - left))\n        //            .attr(\"y1\", 200 - 30 * lastY)\n        //            .attr(\"x2\", 2 * r - 2 * left)\n        //            .attr(\"y2\", 200 - 30 * value)\n        //            .style(\"stroke\", \"rgb(6,120,155)\");\n\n        //        lastX = r;\n        //        lastY = value;\n        //    }\n\n        //    plot_svg.append(\"circle\").attr(\"cx\", 2 * opt_x - 2 * left).attr(\"cy\", 200 - 30 * opt_y)\n        //        .attr(\"r\", 5).style('fill', \"rgba(0,0,0,0.5)\");\n\n        //}\n\n        // actual assigning of position to nodes\n        function put_nodes_to_right_positions(graphs) {\n            graphs.forEach(function (g) {\n                // calculate current graph center:\n                var center = { x: 0, y: 0 };\n\n                g.array.forEach(function (node) {\n                    center.x += node.x;\n                    center.y += node.y;\n                });\n\n                center.x /= g.array.length;\n                center.y /= g.array.length;\n\n                // calculate current top left corner:\n                var corner = { x: center.x - g.width / 2, y: center.y - g.height / 2 };\n                var offset = { x: g.x - corner.x + svg_width / 2 - real_width / 2, y: g.y - corner.y + svg_height / 2 - real_height / 2};\n\n                // put nodes:\n                g.array.forEach(function (node) {\n                    node.x += offset.x;\n                    node.y += offset.y;\n                });\n            });\n        }\n\n        // starts box packing algorithm\n        // desired ratio is 1 by default\n        function apply(data, desired_ratio) {\n            var curr_best_f = Number.POSITIVE_INFINITY;\n            var curr_best = 0;\n            data.sort(function (a, b) { return b.height - a.height; });\n\n            min_width = data.reduce(function (a, b) {\n                return a.width < b.width ? a.width : b.width;\n            });\n\n            var left = x1 = min_width;\n            var right = x2 = get_entire_width(data);\n            var iterationCounter = 0;\n\n            var f_x1 = Number.MAX_VALUE;\n            var f_x2 = Number.MAX_VALUE;\n            var flag = -1; // determines which among f_x1 and f_x2 to recompute\n\n\n            var dx = Number.MAX_VALUE;\n            var df = Number.MAX_VALUE;\n\n            while ((dx > min_width) || df > packingOptions.FLOAT_EPSILON) {\n\n                if (flag != 1) {\n                    var x1 = right - (right - left) / packingOptions.GOLDEN_SECTION;\n                    var f_x1 = step(data, x1);\n                }\n                if (flag != 0) {\n                    var x2 = left + (right - left) / packingOptions.GOLDEN_SECTION;\n                    var f_x2 = step(data, x2);\n                }\n\n                dx = Math.abs(x1 - x2);\n                df = Math.abs(f_x1 - f_x2);\n\n                if (f_x1 < curr_best_f) {\n                    curr_best_f = f_x1;\n                    curr_best = x1;\n                }\n\n                if (f_x2 < curr_best_f) {\n                    curr_best_f = f_x2;\n                    curr_best = x2;\n                }\n\n                if (f_x1 > f_x2) {\n                    left = x1;\n                    x1 = x2;\n                    f_x1 = f_x2;\n                    flag = 1;\n                } else {\n                    right = x2;\n                    x2 = x1;\n                    f_x2 = f_x1;\n                    flag = 0;\n                }\n\n                if (iterationCounter++ > 100) {\n                    break;\n                }\n            }\n            // plot(data, min_width, get_entire_width(data), curr_best, curr_best_f);\n            step(data, curr_best);\n        }\n\n        // one iteration of the optimization method\n        // (gives a proper, but not necessarily optimal packing)\n        function step(data, max_width) {\n            line = [];\n            real_width = 0;\n            real_height = 0;\n            global_bottom = init_y;\n\n            for (var i = 0; i < data.length; i++) {\n                var o = data[i];\n                put_rect(o, max_width);\n            }\n\n            return Math.abs(get_real_ratio() - desired_ratio);\n        }\n\n        // looking for a position to one box\n        function put_rect(rect, max_width) {\n\n\n            var parent = undefined;\n\n            for (var i = 0; i < line.length; i++) {\n                if ((line[i].space_left >= rect.height) && (line[i].x + line[i].width + rect.width + packingOptions.PADDING - max_width) <= packingOptions.FLOAT_EPSILON) {\n                    parent = line[i];\n                    break;\n                }\n            }\n\n            line.push(rect);\n\n            if (parent !== undefined) {\n                rect.x = parent.x + parent.width + packingOptions.PADDING;\n                rect.y = parent.bottom;\n                rect.space_left = rect.height;\n                rect.bottom = rect.y;\n                parent.space_left -= rect.height + packingOptions.PADDING;\n                parent.bottom += rect.height + packingOptions.PADDING;\n            } else {\n                rect.y = global_bottom;\n                global_bottom += rect.height + packingOptions.PADDING;\n                rect.x = init_x;\n                rect.bottom = rect.y;\n                rect.space_left = rect.height;\n            }\n\n            if (rect.y + rect.height - real_height > -packingOptions.FLOAT_EPSILON) real_height = rect.y + rect.height - init_y;\n            if (rect.x + rect.width - real_width > -packingOptions.FLOAT_EPSILON) real_width = rect.x + rect.width - init_x;\n        };\n\n        function get_entire_width(data) {\n            var width = 0;\n            data.forEach(function (d) { return width += d.width + packingOptions.PADDING; });\n            return width;\n        }\n\n        function get_real_ratio() {\n            return (real_width / real_height);\n        }\n    }\n\n    /**\n     * connected components of graph\n     * returns an array of {}\n     */\n    export function separateGraphs(nodes, links) {\n        var marks = {};\n        var ways = {};\n        var graphs = [];\n        var clusters = 0;\n\n        for (var i = 0; i < links.length; i++) {\n            var link = links[i];\n            var n1 = link.source;\n            var n2 = link.target;\n            if (ways[n1.index])\n                ways[n1.index].push(n2);\n            else\n                ways[n1.index] = [n2];\n\n            if (ways[n2.index])\n                ways[n2.index].push(n1);\n            else\n                ways[n2.index] = [n1];\n        }\n\n        for (var i = 0; i < nodes.length; i++) {\n            var node = nodes[i];\n            if (marks[node.index]) continue;\n            explore_node(node, true);\n        }\n\n        function explore_node(n, is_new) {\n            if (marks[n.index] !== undefined) return;\n            if (is_new) {\n                clusters++;\n                graphs.push({ array: [] });\n            }\n            marks[n.index] = clusters;\n            graphs[clusters - 1].array.push(n);\n            var adjacent = ways[n.index];\n            if (!adjacent) return;\n\n            for (var j = 0; j < adjacent.length; j++) {\n                explore_node(adjacent[j], false);\n            }\n        }\n\n        return graphs;\n    }\n","let wasm; export async function setWasm(wasmModule) { const inst = await WebAssembly.instantiate(wasmModule, { \"./derivative_computer_bg.js\": { __wbindgen_memory } }); wasm = inst.exports; }\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nlet cachegetFloat32Memory0 = null;\nfunction getFloat32Memory0() {\n    if (cachegetFloat32Memory0 === null || cachegetFloat32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetFloat32Memory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachegetFloat32Memory0;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArrayF32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4);\n    getFloat32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n* @param {number} node_count\n* @param {Float32Array} D\n* @param {Float32Array} G\n* @returns {number}\n*/\nexport function create_derivative_computer_ctx_2d(node_count, D, G) {\n    var ptr0 = passArrayF32ToWasm0(D, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ptr1 = passArrayF32ToWasm0(G, wasm.__wbindgen_malloc);\n    var len1 = WASM_VECTOR_LEN;\n    var ret = wasm.create_derivative_computer_ctx_2d(node_count, ptr0, len0, ptr1, len1);\n    return ret;\n}\n\n/**\n* @param {number} node_count\n* @param {Float32Array} D\n* @param {Float32Array} G\n* @returns {number}\n*/\nexport function create_derivative_computer_ctx_3d(node_count, D, G) {\n    var ptr0 = passArrayF32ToWasm0(D, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ptr1 = passArrayF32ToWasm0(G, wasm.__wbindgen_malloc);\n    var len1 = WASM_VECTOR_LEN;\n    var ret = wasm.create_derivative_computer_ctx_3d(node_count, ptr0, len0, ptr1, len1);\n    return ret;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nfunction getArrayF32FromWasm0(ptr, len) {\n    return getFloat32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n/**\n* @param {number} ctx_ptr\n* @param {Float32Array} x\n* @returns {Float32Array}\n*/\nexport function compute_2d(ctx_ptr, x) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        var ptr0 = passArrayF32ToWasm0(x, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.compute_2d(retptr, ctx_ptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v1 = getArrayF32FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 4);\n        return v1;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {number} ctx_ptr\n* @param {Float32Array} x\n* @returns {Float32Array}\n*/\nexport function compute_3d(ctx_ptr, x) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        var ptr0 = passArrayF32ToWasm0(x, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.compute_3d(retptr, ctx_ptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v1 = getArrayF32FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 4);\n        return v1;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {number} ctx_ptr\n* @param {number} u\n* @param {number} p_0\n* @param {number} p_1\n* @param {number} x_0_u\n* @param {number} x_1_u\n*/\nexport function apply_lock_2d(ctx_ptr, u, p_0, p_1, x_0_u, x_1_u) {\n    wasm.apply_lock_2d(ctx_ptr, u, p_0, p_1, x_0_u, x_1_u);\n}\n\n/**\n* @param {number} ctx_ptr\n* @param {number} u\n* @param {number} p_0\n* @param {number} p_1\n* @param {number} p_2\n* @param {number} x_0_u\n* @param {number} x_1_u\n* @param {number} x_2_u\n*/\nexport function apply_lock_3d(ctx_ptr, u, p_0, p_1, p_2, x_0_u, x_1_u, x_2_u) {\n    wasm.apply_lock_3d(ctx_ptr, u, p_0, p_1, p_2, x_0_u, x_1_u, x_2_u);\n}\n\n/**\n* @param {number} ctx_ptr\n* @returns {number}\n*/\nexport function compute_step_size_2d(ctx_ptr) {\n    var ret = wasm.compute_step_size_2d(ctx_ptr);\n    return ret;\n}\n\n/**\n* @param {number} ctx_ptr\n* @returns {number}\n*/\nexport function compute_step_size_3d(ctx_ptr) {\n    var ret = wasm.compute_step_size_3d(ctx_ptr);\n    return ret;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n/**\n* @returns {any}\n*/\nexport function get_memory() {\n    var ret = wasm.get_memory();\n    return takeObject(ret);\n}\n\n/**\n* @param {number} ctx\n* @returns {number}\n*/\nexport function get_D_2d(ctx) {\n    var ret = wasm.get_D_2d(ctx);\n    return ret;\n}\n\n/**\n* @param {number} ctx\n* @returns {number}\n*/\nexport function get_D_3d(ctx) {\n    var ret = wasm.get_D_2d(ctx);\n    return ret;\n}\n\n/**\n* @param {number} ctx\n* @returns {number}\n*/\nexport function get_g_2d(ctx) {\n    var ret = wasm.get_g_2d(ctx);\n    return ret;\n}\n\n/**\n* @param {number} ctx\n* @returns {number}\n*/\nexport function get_g_3d(ctx) {\n    var ret = wasm.get_g_2d(ctx);\n    return ret;\n}\n\n/**\n* @param {number} ctx\n* @param {Float32Array} new_G\n*/\nexport function set_G_2d(ctx, new_G) {\n    var ptr0 = passArrayF32ToWasm0(new_G, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    wasm.set_G_2d(ctx, ptr0, len0);\n}\n\n/**\n* @param {number} ctx\n* @param {Float32Array} new_G\n*/\nexport function set_G_3d(ctx, new_G) {\n    var ptr0 = passArrayF32ToWasm0(new_G, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    wasm.set_G_2d(ctx, ptr0, len0);\n}\n\nexport const __wbindgen_memory = function() {\n    var ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\n","let wasm; export async function setWasm(wasmModule) { const inst = await WebAssembly.instantiate(wasmModule, { \"./derivative_computer_bg.js\": { __wbindgen_memory } }); wasm = inst.exports; }\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nlet cachegetFloat32Memory0 = null;\nfunction getFloat32Memory0() {\n    if (cachegetFloat32Memory0 === null || cachegetFloat32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetFloat32Memory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachegetFloat32Memory0;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArrayF32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4);\n    getFloat32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n* @param {number} node_count\n* @param {Float32Array} D\n* @param {Float32Array} G\n* @returns {number}\n*/\nexport function create_derivative_computer_ctx_2d(node_count, D, G) {\n    var ptr0 = passArrayF32ToWasm0(D, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ptr1 = passArrayF32ToWasm0(G, wasm.__wbindgen_malloc);\n    var len1 = WASM_VECTOR_LEN;\n    var ret = wasm.create_derivative_computer_ctx_2d(node_count, ptr0, len0, ptr1, len1);\n    return ret;\n}\n\n/**\n* @param {number} node_count\n* @param {Float32Array} D\n* @param {Float32Array} G\n* @returns {number}\n*/\nexport function create_derivative_computer_ctx_3d(node_count, D, G) {\n    var ptr0 = passArrayF32ToWasm0(D, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ptr1 = passArrayF32ToWasm0(G, wasm.__wbindgen_malloc);\n    var len1 = WASM_VECTOR_LEN;\n    var ret = wasm.create_derivative_computer_ctx_3d(node_count, ptr0, len0, ptr1, len1);\n    return ret;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nfunction getArrayF32FromWasm0(ptr, len) {\n    return getFloat32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n/**\n* @param {number} ctx_ptr\n* @param {Float32Array} x\n* @returns {Float32Array}\n*/\nexport function compute_2d(ctx_ptr, x) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        var ptr0 = passArrayF32ToWasm0(x, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.compute_2d(retptr, ctx_ptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v1 = getArrayF32FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 4);\n        return v1;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {number} ctx_ptr\n* @param {Float32Array} x\n* @returns {Float32Array}\n*/\nexport function compute_3d(ctx_ptr, x) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        var ptr0 = passArrayF32ToWasm0(x, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.compute_3d(retptr, ctx_ptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v1 = getArrayF32FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 4);\n        return v1;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {number} ctx_ptr\n* @param {number} u\n* @param {number} p_0\n* @param {number} p_1\n* @param {number} x_0_u\n* @param {number} x_1_u\n*/\nexport function apply_lock_2d(ctx_ptr, u, p_0, p_1, x_0_u, x_1_u) {\n    wasm.apply_lock_2d(ctx_ptr, u, p_0, p_1, x_0_u, x_1_u);\n}\n\n/**\n* @param {number} ctx_ptr\n* @param {number} u\n* @param {number} p_0\n* @param {number} p_1\n* @param {number} p_2\n* @param {number} x_0_u\n* @param {number} x_1_u\n* @param {number} x_2_u\n*/\nexport function apply_lock_3d(ctx_ptr, u, p_0, p_1, p_2, x_0_u, x_1_u, x_2_u) {\n    wasm.apply_lock_3d(ctx_ptr, u, p_0, p_1, p_2, x_0_u, x_1_u, x_2_u);\n}\n\n/**\n* @param {number} ctx_ptr\n* @returns {number}\n*/\nexport function compute_step_size_2d(ctx_ptr) {\n    var ret = wasm.compute_step_size_2d(ctx_ptr);\n    return ret;\n}\n\n/**\n* @param {number} ctx_ptr\n* @returns {number}\n*/\nexport function compute_step_size_3d(ctx_ptr) {\n    var ret = wasm.compute_step_size_3d(ctx_ptr);\n    return ret;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n/**\n* @returns {any}\n*/\nexport function get_memory() {\n    var ret = wasm.get_memory();\n    return takeObject(ret);\n}\n\n/**\n* @param {number} ctx\n* @returns {number}\n*/\nexport function get_D_2d(ctx) {\n    var ret = wasm.get_D_2d(ctx);\n    return ret;\n}\n\n/**\n* @param {number} ctx\n* @returns {number}\n*/\nexport function get_D_3d(ctx) {\n    var ret = wasm.get_D_2d(ctx);\n    return ret;\n}\n\n/**\n* @param {number} ctx\n* @returns {number}\n*/\nexport function get_g_2d(ctx) {\n    var ret = wasm.get_g_2d(ctx);\n    return ret;\n}\n\n/**\n* @param {number} ctx\n* @returns {number}\n*/\nexport function get_g_3d(ctx) {\n    var ret = wasm.get_g_2d(ctx);\n    return ret;\n}\n\n/**\n* @param {number} ctx\n* @param {Float32Array} new_G\n*/\nexport function set_G_2d(ctx, new_G) {\n    var ptr0 = passArrayF32ToWasm0(new_G, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    wasm.set_G_2d(ctx, ptr0, len0);\n}\n\n/**\n* @param {number} ctx\n* @param {Float32Array} new_G\n*/\nexport function set_G_3d(ctx, new_G) {\n    var ptr0 = passArrayF32ToWasm0(new_G, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    wasm.set_G_2d(ctx, ptr0, len0);\n}\n\nexport const __wbindgen_memory = function() {\n    var ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\n","import * as powergraph from './powergraph'\nimport {LinkLengthAccessor, symmetricDiffLinkLengths, jaccardLinkLengths, generateDirectedEdgeConstraints} from './linklengths'\nimport {Descent} from './descent'\nimport {Rectangle, Projection, makeEdgeTo, makeEdgeBetween} from './rectangle'\nimport {Calculator} from './shortestpaths'\nimport {TangentVisibilityGraph, TVGPoint} from './geom'\nimport {separateGraphs, applyPacking} from './handledisconnected'\nimport { getDerivativeComputerWasm } from './wasmEngine'\n\n// Kick this off right away since we're going to need it eventually\nconst wasmInstPromise = getDerivativeComputerWasm();\n\n    /**\n     * The layout process fires three events:\n     *  - start: layout iterations started\n     *  - tick: fired once per iteration, listen to this to animate\n     *  - end: layout converged, you might like to zoom-to-fit or something at notification of this event\n     */\n    export enum EventType { start, tick, end };\n    export interface Event {\n        type: EventType;\n        alpha: number;\n        stress?: number;\n        listener?: () => void;\n    }\n    export interface InputNode {\n        /**\n         * index in nodes array, this is initialized by Layout.start()\n         */\n        index?: number;\n        /**\n         * x and y will be computed by layout as the Node's centroid\n         */\n        x?: number;\n        /**\n         * x and y will be computed by layout as the Node's centroid\n         */\n        y?: number;\n        /**\n         * specify a width and height of the node's bounding box if you turn on avoidOverlaps\n         */\n        width?: number;\n        /**\n         * specify a width and height of the node's bounding box if you turn on avoidOverlaps\n         */\n        height?: number;\n        /**\n         * selective bit mask.  !=0 means layout will not move.\n         */\n        fixed?: number;\n    }\n    export interface Node extends InputNode {\n      // Client-passed node may be missing these properties, which will be set\n      // upon ingestion\n      x: number;\n      y: number;\n    }\n\n    export interface Group {\n        bounds?: Rectangle;\n        leaves?: Node[];\n        groups?: Group[];\n        padding?: number;\n    }\n\n    function isGroup(g: any): g is Group {\n        return typeof g.leaves !== 'undefined' || typeof g.groups !== 'undefined';\n    }\n\n    export interface Link<NodeRefType> {\n        source: NodeRefType;\n        target: NodeRefType;\n\n        // ideal length the layout should try to achieve for this link\n        length?: number;\n\n        // how hard we should try to satisfy this link's ideal length\n        // must be in the range: 0 < weight <= 1\n        // if unspecified 1 is the default\n        weight?: number;\n    }\n\n    export type LinkNumericPropertyAccessor = (t: Link<Node | number>) => number;\n\n    export interface LinkLengthTypeAccessor extends LinkLengthAccessor<Link<Node | number>> {\n        getType: LinkNumericPropertyAccessor;\n    }\n    /**\n     * Main interface to cola layout.\n     * @class Layout\n     */\n    export class Layout {\n        private _canvasSize = [1, 1];\n        private _linkDistance: number | LinkNumericPropertyAccessor = 20;\n        private _defaultNodeSize: number = 10;\n        private _linkLengthCalculator = null;\n        private _linkType = null;\n        private _avoidOverlaps = false;\n        private _handleDisconnected = true;\n        private _alpha;\n        private _lastStress;\n        private _running = false;\n        private _nodes = [];\n        private _groups = [];\n        private _rootGroup = null;\n        private _links: Link<Node | number>[] = [];\n        private _constraints = [];\n        private _distanceMatrix = null;\n        private _descent: Descent = null;\n        private _directedLinkConstraints = null;\n        private _threshold = 0.01;\n        private _visibilityGraph = null;\n        private _groupCompactness = 1e-6;\n\n        // sub-class and override this property to replace with a more sophisticated eventing mechanism\n        protected event = null;\n\n        // subscribe a listener to an event\n        // sub-class and override this method to replace with a more sophisticated eventing mechanism\n        public on(e: EventType | string, listener: (event?: Event) => void): this {\n            // override me!\n            if (!this.event) this.event = {};\n            if (typeof e === 'string') {\n                this.event[EventType[e]] = listener;\n            } else {\n                this.event[e] = listener;\n            }\n            return this;\n        }\n\n        // a function that is notified of events like \"tick\"\n        // sub-classes can override this method to replace with a more sophisticated eventing mechanism\n        protected trigger(e: Event) {\n            if (this.event && typeof this.event[e.type] !== 'undefined') {\n                this.event[e.type](e);\n            }\n        }\n\n        // a function that kicks off the iteration tick loop\n        // it calls tick() repeatedly until tick returns true (is converged)\n        // subclass and override it with something fancier (e.g. dispatch tick on a timer)\n        protected kick(): void {\n            while (!this.tick());\n        }\n\n        /**\n         * iterate the layout.  Returns true when layout converged.\n         */\n        protected tick(): boolean {\n            if (this._alpha < this._threshold) {\n                this._running = false;\n                this.trigger({ type: EventType.end, alpha: this._alpha = 0, stress: this._lastStress });\n                return true;\n            }\n            const n = this._nodes.length,\n                  m = this._links.length;\n            let o, i;\n\n            this._descent.locks.clear();\n            for (i = 0; i < n; ++i) {\n                o = this._nodes[i];\n                if (o.fixed) {\n                    if (typeof o.px === 'undefined' || typeof o.py === 'undefined') {\n                        o.px = o.x;\n                        o.py = o.y;\n                    }\n                    var p = [o.px, o.py];\n                    this._descent.locks.add(i, p);\n                }\n            }\n\n            let s1 = this._descent.rungeKutta();\n            //var s1 = descent.reduceStress();\n            if (s1 === 0) {\n                this._alpha = 0;\n            } else if (typeof this._lastStress !== 'undefined') {\n                this._alpha = s1; //Math.abs(Math.abs(this._lastStress / s1) - 1);\n            }\n            this._lastStress = s1;\n\n            this.updateNodePositions();\n\n            this.trigger({ type: EventType.tick, alpha: this._alpha, stress: this._lastStress });\n            return false;\n        }\n\n        // copy positions out of descent instance into each of the nodes' center coords\n        private updateNodePositions(): void {\n            const x = this._descent.x[0], y = this._descent.x[1];\n            let o, i = this._nodes.length;\n            while (i--) {\n                o = this._nodes[i];\n                o.x = x[i];\n                o.y = y[i];\n            }\n        }\n\n        /**\n         * the list of nodes.\n         * If nodes has not been set, but links has, then we instantiate a nodes list here, of the correct size,\n         * before returning it.\n         * @property nodes {Array}\n         * @default empty list\n         */\n        nodes(): Array<Node>\n        nodes(v: Array<InputNode>): this\n        nodes(v?: any): any {\n            if (!v) {\n                if (this._nodes.length === 0 && this._links.length > 0) {\n                    // if we have links but no nodes, create the nodes array now with empty objects for the links to point at.\n                    // in this case the links are expected to be numeric indices for nodes in the range 0..n-1 where n is the number of nodes\n                    var n = 0;\n                    this._links.forEach(function (l) {\n                        n = Math.max(n, <number>l.source, <number>l.target);\n                    });\n                    this._nodes = new Array(++n);\n                    for (var i = 0; i < n; ++i) {\n                        this._nodes[i] = {};\n                    }\n                }\n                return this._nodes;\n            }\n            this._nodes = v;\n            return this;\n        }\n\n        /**\n         * a list of hierarchical groups defined over nodes\n         * @property groups {Array}\n         * @default empty list\n         */\n        groups(): Array<Group>\n        groups(x: Array<Group>): this\n        groups(x?: Array<Group>): any {\n            if (!x) return this._groups;\n            this._groups = x;\n            this._rootGroup = {};\n            this._groups.forEach(g => {\n                if (typeof g.padding === \"undefined\")\n                    g.padding = 1;\n                if (typeof g.leaves !== \"undefined\") {\n                    g.leaves.forEach((v, i) => {\n                        if (typeof v === 'number')\n                            (g.leaves[i] = this._nodes[v]).parent = g\n                    });\n                }\n                if (typeof g.groups !== \"undefined\") {\n                    g.groups.forEach((gi, i) => {\n                        if (typeof gi === 'number')\n                            (g.groups[i] = this._groups[gi]).parent = g\n                    });\n                }\n            });\n            this._rootGroup.leaves = this._nodes.filter(v => typeof v.parent === 'undefined');\n            this._rootGroup.groups = this._groups.filter(g => typeof g.parent === 'undefined');\n            return this;\n        }\n\n        powerGraphGroups(f: Function): this {\n            var g = powergraph.getGroups(this._nodes, this._links, this.linkAccessor, this._rootGroup);\n            this.groups(g.groups);\n            f(g);\n            return this;\n        }\n\n        /**\n         * if true, the layout will not permit overlaps of the node bounding boxes (defined by the width and height properties on nodes)\n         * @property avoidOverlaps\n         * @type bool\n         * @default false\n         */\n        avoidOverlaps(): boolean\n        avoidOverlaps(v: boolean): this\n        avoidOverlaps(v?: boolean): any {\n            if (!arguments.length) return this._avoidOverlaps;\n            this._avoidOverlaps = v;\n            return this;\n        }\n\n        /**\n         * if true, the final step of the start method will be to nicely pack connected components of the graph.\n         * works best if start() is called with a reasonable number of iterations specified and\n         * each node has a bounding box (defined by the width and height properties on nodes).\n         * @property handleDisconnected\n         * @type bool\n         * @default true\n         */\n        handleDisconnected(): boolean\n        handleDisconnected(v: boolean): this\n        handleDisconnected(v?: boolean): any {\n            if (!arguments.length) return this._handleDisconnected;\n            this._handleDisconnected = v;\n            return this;\n        }\n\n        /**\n         * causes constraints to be generated such that directed graphs are laid out either from left-to-right or top-to-bottom.\n         * a separation constraint is generated in the selected axis for each edge that is not involved in a cycle (part of a strongly connected component)\n         * @param axis {string} 'x' for left-to-right, 'y' for top-to-bottom\n         * @param minSeparation {number|link=>number} either a number specifying a minimum spacing required across all links or a function to return the minimum spacing for each link\n         */\n        flowLayout(axis: string, minSeparation: number|((t: any)=>number)): this {\n            if (!arguments.length) axis = 'y';\n            this._directedLinkConstraints = {\n                axis: axis,\n                getMinSeparation: typeof minSeparation === 'number' ? function () { return minSeparation } : minSeparation\n            };\n            return this;\n        }\n\n        /**\n         * links defined as source, target pairs over nodes\n         * @property links {array}\n         * @default empty list\n         */\n        links(): Array<Link<Node|number>>\n        links(x: Array<Link<Node|number>>): this\n        links(x?: Array<Link<Node|number>>): any {\n            if (!arguments.length) return this._links;\n            this._links = x;\n            return this;\n        }\n\n        /**\n         * list of constraints of various types\n         * @property constraints\n         * @type {array}\n         * @default empty list\n         */\n        constraints(): Array<any>\n        constraints(c: Array<any>): this\n        constraints(c?: Array<any>): any {\n            if (!arguments.length) return this._constraints;\n            this._constraints = c;\n            return this;\n        }\n\n        /**\n         * Matrix of ideal distances between all pairs of nodes.\n         * If unspecified, the ideal distances for pairs of nodes will be based on the shortest path distance between them.\n         * @property distanceMatrix\n         * @type {Array of Array of Number}\n         * @default null\n         */\n        distanceMatrix(): Array<Array<number>>\n        distanceMatrix(d: Array<Array<number>>): this\n        distanceMatrix(d?: any): any {\n            if (!arguments.length) return this._distanceMatrix;\n            this._distanceMatrix = d;\n            return this;\n        }\n\n        /**\n         * Size of the layout canvas dimensions [x,y]. Currently only used to determine the midpoint which is taken as the starting position\n         * for nodes with no preassigned x and y.\n         * @property size\n         * @type {Array of Number}\n         */\n        size(): Array<number>\n        size(x: Array<number>): this\n        size(x?: Array<number>): any {\n            if (!x) return this._canvasSize;\n            this._canvasSize = x;\n            return this;\n        }\n\n        /**\n         * Default size (assume nodes are square so both width and height) to use in packing if node width/height are not specified.\n         * @property defaultNodeSize\n         * @type {Number}\n         */\n        defaultNodeSize(): number\n        defaultNodeSize(x: number): this\n        defaultNodeSize(x?: any): any {\n            if (!x) return this._defaultNodeSize;\n            this._defaultNodeSize = x;\n            return this;\n        }\n\n        /**\n         * The strength of attraction between the group boundaries to each other.\n         * @property defaultNodeSize\n         * @type {Number}\n         */\n        groupCompactness(): number\n        groupCompactness(x: number): this\n        groupCompactness(x?: any): any {\n            if (!x) return this._groupCompactness;\n            this._groupCompactness = x;\n            return this;\n        }\n\n        /**\n         * links have an ideal distance, The automatic layout will compute layout that tries to keep links (AKA edges) as close as possible to this length.\n         */\n        linkDistance(): number\n        linkDistance(): LinkNumericPropertyAccessor\n        linkDistance(x: number): this\n        linkDistance(x: LinkNumericPropertyAccessor): this\n        linkDistance(x?: any): any {\n            if (!x) {\n                return this._linkDistance;\n            }\n            this._linkDistance = typeof x === \"function\" ? x : +x;\n            this._linkLengthCalculator = null;\n            return this;\n        }\n\n        linkType(f: Function | number): this {\n            this._linkType = f;\n            return this;\n        }\n\n        convergenceThreshold(): number\n        convergenceThreshold(x: number): this\n        convergenceThreshold(x?: number): any {\n            if (!x) return this._threshold;\n            this._threshold = typeof x === \"function\" ? x : +x;\n            return this;\n        }\n\n        alpha(): number\n        alpha(x: number): this\n        alpha(x?: number): any {\n            if (!arguments.length) return this._alpha;\n            else {\n                x = +x;\n                if (this._alpha) { // if we're already running\n                    if (x > 0) this._alpha = x; // we might keep it hot\n                    else this._alpha = 0; // or, next tick will dispatch \"end\"\n                } else if (x > 0) { // otherwise, fire it up!\n                    if (!this._running) {\n                        this._running = true;\n                        this.trigger({ type: EventType.start, alpha: this._alpha = x});\n                        this.kick();\n                    }\n                }\n                return this;\n            }\n        }\n\n        getLinkLength(link: Link<Node | number>): number {\n            return typeof this._linkDistance === \"function\" ? +((<LinkNumericPropertyAccessor>this._linkDistance)(link)) : <number>this._linkDistance;\n        }\n\n        static setLinkLength(link: Link<Node|number>, length: number) {\n            link.length = length;\n        }\n\n        getLinkType(link: Link<Node | number>): number {\n            return typeof this._linkType === \"function\" ? this._linkType(link) : 0;\n        }\n\n        linkAccessor: LinkLengthTypeAccessor = {\n            getSourceIndex: Layout.getSourceIndex,\n            getTargetIndex: Layout.getTargetIndex,\n            setLength: Layout.setLinkLength,\n            getType: l => typeof this._linkType === \"function\" ? this._linkType(l) : 0\n        };\n\n        /**\n         * compute an ideal length for each link based on the graph structure around that link.\n         * you can use this (for example) to create extra space around hub-nodes in dense graphs.\n         * In particular this calculation is based on the \"symmetric difference\" in the neighbour sets of the source and target:\n         * i.e. if neighbours of source is a and neighbours of target are b then calculation is: sqrt(|a union b| - |a intersection b|)\n         * Actual computation based on inspection of link structure occurs in start(), so links themselves\n         * don't have to have been assigned before invoking this function.\n         * @param {number} [idealLength] the base length for an edge when its source and start have no other common neighbours (e.g. 40)\n         * @param {number} [w] a multiplier for the effect of the length adjustment (e.g. 0.7)\n         */\n        symmetricDiffLinkLengths(idealLength: number, w: number = 1): this {\n            this.linkDistance(l => idealLength * l.length);\n            this._linkLengthCalculator = () => symmetricDiffLinkLengths(this._links, this.linkAccessor, w);\n            return this;\n        }\n\n        /**\n         * compute an ideal length for each link based on the graph structure around that link.\n         * you can use this (for example) to create extra space around hub-nodes in dense graphs.\n         * In particular this calculation is based on the \"symmetric difference\" in the neighbour sets of the source and target:\n         * i.e. if neighbours of source is a and neighbours of target are b then calculation is: |a intersection b|/|a union b|\n         * Actual computation based on inspection of link structure occurs in start(), so links themselves\n         * don't have to have been assigned before invoking this function.\n         * @param {number} [idealLength] the base length for an edge when its source and start have no other common neighbours (e.g. 40)\n         * @param {number} [w] a multiplier for the effect of the length adjustment (e.g. 0.7)\n         */\n        jaccardLinkLengths(idealLength: number, w: number = 1): this {\n            this.linkDistance(l => idealLength * l.length);\n            this._linkLengthCalculator = () => jaccardLinkLengths(this._links, this.linkAccessor, w);\n            return this;\n        }\n\n        /**\n         * start the layout process\n         * @method start\n         * @param {number} [initialUnconstrainedIterations=0] unconstrained initial layout iterations\n         * @param {number} [initialUserConstraintIterations=0] initial layout iterations with user-specified constraints\n         * @param {number} [initialAllConstraintsIterations=0] initial layout iterations with all constraints including non-overlap\n         * @param {number} [gridSnapIterations=0] iterations of \"grid snap\", which pulls nodes towards grid cell centers - grid of size node[0].width - only really makes sense if all nodes have the same width and height\n         * @param [keepRunning=true] keep iterating shronously via the tick method\n         * @param [centerGraph=true] Center graph on restart\n         */\n        async start(\n            initialUnconstrainedIterations: number = 0,\n            initialUserConstraintIterations: number = 0,\n            initialAllConstraintsIterations: number = 0,\n            gridSnapIterations: number = 0,\n            keepRunning = true,\n            centerGraph = true,\n        ): Promise<this> {\n            var i: number,\n                j: number,\n                n = (<Array<any>>this.nodes()).length,\n                N = n + 2 * this._groups.length,\n                m = this._links.length,\n                w = this._canvasSize[0],\n                h = this._canvasSize[1];\n\n            var x = new Array(N), y = new Array(N);\n\n            var G = null;\n\n            var ao = this._avoidOverlaps;\n\n            this._nodes.forEach((v, i) => {\n                v.index = i;\n                if (typeof v.x === 'undefined') {\n                    v.x = w / 2, v.y = h / 2;\n                }\n                x[i] = v.x, y[i] = v.y;\n            });\n\n            if (this._linkLengthCalculator) this._linkLengthCalculator();\n\n            //should we do this to clearly label groups?\n            //this._groups.forEach((g, i) => g.groupIndex = i);\n\n            var distances;\n            if (this._distanceMatrix) {\n                // use the user specified distanceMatrix\n                distances = this._distanceMatrix;\n            } else {\n                // construct an n X n distance matrix based on shortest paths through graph (with respect to edge.length).\n                distances = (new Calculator(N, this._links, Layout.getSourceIndex, Layout.getTargetIndex, l=> this.getLinkLength(l))).DistanceMatrix();\n\n                // G is a square matrix with G[i][j] = 1 iff there exists an edge between node i and node j\n                // otherwise 2. (\n                G = Descent.createSquareMatrix(N, () => 2);\n                this._links.forEach(l => {\n                    if (typeof l.source == \"number\") l.source = this._nodes[<number>l.source];\n                    if (typeof l.target == \"number\") l.target = this._nodes[<number>l.target];\n                });\n                this._links.forEach(e => {\n                    const u = Layout.getSourceIndex(e), v = Layout.getTargetIndex(e);\n                    G[u][v] = G[v][u] = e.weight || 1;\n                });\n            }\n\n            var D = Descent.createSquareMatrix(N, function (i, j) {\n                return distances[i][j];\n            });\n\n            if (this._rootGroup && typeof this._rootGroup.groups !== 'undefined') {\n                var i = n;\n                var addAttraction = (i, j, strength, idealDistance) => {\n                    G[i][j] = G[j][i] = strength;\n                    D[i][j] = D[j][i] = idealDistance;\n                };\n                this._groups.forEach(g => {\n                    addAttraction(i, i + 1, this._groupCompactness, 0.1);\n\n                    // todo: add terms here attracting children of the group to the group dummy nodes\n                    //if (typeof g.leaves !== 'undefined')\n                    //    g.leaves.forEach(l => {\n                    //        addAttraction(l.index, i, 1e-4, 0.1);\n                    //        addAttraction(l.index, i + 1, 1e-4, 0.1);\n                    //    });\n                    //if (typeof g.groups !== 'undefined')\n                    //    g.groups.forEach(g => {\n                    //        var gid = n + g.groupIndex * 2;\n                    //        addAttraction(gid, i, 0.1, 0.1);\n                    //        addAttraction(gid + 1, i, 0.1, 0.1);\n                    //        addAttraction(gid, i + 1, 0.1, 0.1);\n                    //        addAttraction(gid + 1, i + 1, 0.1, 0.1);\n                    //    });\n\n                    if (typeof g.bounds === 'undefined') {\n                        x[i] = w / 2, y[i++] = h / 2;\n                        x[i] = w / 2, y[i++] = h / 2;\n                    } else {\n                        x[i] = g.bounds.x, y[i++] = g.bounds.y;\n                        x[i] = g.bounds.X, y[i++] = g.bounds.Y;\n                    }\n                });\n            } else this._rootGroup = { leaves: this._nodes, groups: [] };\n\n            var curConstraints = this._constraints || [];\n            if (this._directedLinkConstraints) {\n                (<any>this.linkAccessor).getMinSeparation = this._directedLinkConstraints.getMinSeparation;\n                curConstraints = curConstraints.concat(generateDirectedEdgeConstraints(n, this._links, this._directedLinkConstraints.axis, <any>(this.linkAccessor)));\n\n                // todo: add containment constraints between group dummy nodes and their children\n            }\n\n            this.avoidOverlaps(false);\n            const wasmInst = await wasmInstPromise;\n            this._descent = new Descent([x, y], D, undefined, wasmInst);\n\n            this._descent.locks.clear();\n            for (var i = 0; i < n; ++i) {\n                var o = this._nodes[i];\n                if (o.fixed) {\n                    o.px = o.x;\n                    o.py = o.y;\n                    var p = [o.x, o.y];\n                    this._descent.locks.add(i, p);\n                }\n            }\n            this._descent.threshold = this._threshold;\n\n            // apply initialIterations without user constraints or nonoverlap constraints\n            // if groups are specified, dummy nodes and edges will be added to untangle\n            // with respect to group connectivity\n            this.initialLayout(initialUnconstrainedIterations, x, y);\n\n            // apply initialIterations with user constraints but no nonoverlap constraints\n            if (curConstraints.length > 0) this._descent.project = new Projection(this._nodes, this._groups, this._rootGroup, curConstraints).projectFunctions();\n            this._descent.run(initialUserConstraintIterations);\n            this.separateOverlappingComponents(w, h, centerGraph);\n\n            // subsequent iterations will apply all constraints\n            this.avoidOverlaps(ao);\n            if (ao) {\n                this._nodes.forEach(function (v, i) { v.x = x[i], v.y = y[i]; });\n                this._descent.project = new Projection(this._nodes, this._groups, this._rootGroup, curConstraints, true).projectFunctions();\n                this._nodes.forEach(function (v, i) { x[i] = v.x, y[i] = v.y; });\n            }\n\n            // allow not immediately connected nodes to relax apart (p-stress)\n            this._descent.G = G;\n            this._descent.run(initialAllConstraintsIterations);\n\n            // TODO\n            // if (gridSnapIterations) {\n            //     this._descent.snapStrength = 1000;\n            //     this._descent.snapGridSize = this._nodes[0].width;\n            //     this._descent.numGridSnapNodes = n;\n            //     this._descent.scaleSnapByMaxH = n != N; // if we have groups then need to scale hessian so grid forces still apply\n            //     var G0 = Descent.createSquareMatrix(N,(i, j) => {\n            //         if (i >= n || j >= n) return G[i][j];\n            //         return 0\n            //     });\n            //     this._descent.G = G0;\n            //     this._descent.run(gridSnapIterations);\n            // }\n\n            this.updateNodePositions();\n            this.separateOverlappingComponents(w, h, centerGraph);\n            return keepRunning ? this.resume() : this;\n        }\n\n        private initialLayout(iterations: number, x: number[], y: number[]) {\n            if (this._groups.length > 0 && iterations > 0) {\n                // construct a flat graph with dummy nodes for the groups and edges connecting group dummy nodes to their children\n                // todo: edges attached to groups are replaced with edges connected to the corresponding group dummy node\n                var n = this._nodes.length;\n                var edges = this._links.map(e => <any>{ source: (<Node>e.source).index, target: (<Node>e.target).index });\n                var vs = this._nodes.map(v => <any>{ index: v.index });\n                this._groups.forEach((g, i) => {\n                    vs.push(<any>{ index: g.index = n + i });\n                });\n                this._groups.forEach((g, i) => {\n                    if (typeof g.leaves !== 'undefined')\n                        g.leaves.forEach(v => edges.push({ source: g.index, target: v.index }));\n                    if (typeof g.groups !== 'undefined')\n                        g.groups.forEach(gg => edges.push({ source: g.index, target: gg.index }));\n                });\n\n                // layout the flat graph with dummy nodes and edges\n                new Layout()\n                    .size(this.size())\n                    .nodes(vs)\n                    .links(edges)\n                    .avoidOverlaps(false)\n                    .linkDistance(this.linkDistance())\n                    .symmetricDiffLinkLengths(5)\n                    .convergenceThreshold(1e-4)\n                    .start(iterations, 0, 0, 0, false);\n\n                this._nodes.forEach(v => {\n                    x[v.index] = vs[v.index].x;\n                    y[v.index] = vs[v.index].y;\n                });\n            } else {\n                this._descent.run(iterations);\n            }\n        }\n\n        // recalculate nodes position for disconnected graphs\n        private separateOverlappingComponents(width: number, height: number, centerGraph: boolean = true): void {\n            // recalculate nodes position for disconnected graphs\n            if (!this._distanceMatrix && this._handleDisconnected) {\n                let x = this._descent.x[0], y = this._descent.x[1];\n                this._nodes.forEach(function (v, i) { v.x = x[i], v.y = y[i]; });\n                var graphs = separateGraphs(this._nodes, this._links);\n                applyPacking(graphs, width, height, this._defaultNodeSize, 1, centerGraph);\n                this._nodes.forEach((v, i) => {\n                    this._descent.x[0][i] = v.x, this._descent.x[1][i] = v.y;\n                    if (v.bounds) {\n                        v.bounds.setXCentre(v.x);\n                        v.bounds.setYCentre(v.y);\n                    }\n                });\n            }\n        }\n\n        resume(): this {\n            return this.alpha(0.1);\n        }\n\n        stop(): this {\n            return this.alpha(0);\n        }\n\n        /// find a visibility graph over the set of nodes.  assumes all nodes have a\n        /// bounds property (a rectangle) and that no pair of bounds overlaps.\n        prepareEdgeRouting(nodeMargin: number = 0) {\n            this._visibilityGraph = new TangentVisibilityGraph(\n                this._nodes.map(function (v) {\n                    return v.bounds.inflate(-nodeMargin).vertices();\n                }));\n        }\n\n        /**\n         * find a route avoiding node bounds for the given edge.\n         * assumes the visibility graph has been created (by prepareEdgeRouting method)\n         * and also assumes that nodes have an index property giving their position in the\n         * node array.  This index property is created by the start() method.\n         * @param [edge] The edge to generate a route for.\n         * @param {number} [ah] The size of the arrow head, a distance to shorten the end\n         *                      of the edge by.  Defaults to 5.\n         */\n        routeEdge(edge, ah: number = 5, draw) {\n            var lineData = [];\n            //if (d.source.id === 10 && d.target.id === 11) {\n            //    debugger;\n            //}\n            var vg2 = new TangentVisibilityGraph(this._visibilityGraph.P, { V: this._visibilityGraph.V, E: this._visibilityGraph.E }),\n                port1 = <TVGPoint>{ x: edge.source.x, y: edge.source.y },\n                port2 = <TVGPoint>{ x: edge.target.x, y: edge.target.y },\n                start = vg2.addPoint(port1, edge.source.index),\n                end = vg2.addPoint(port2, edge.target.index);\n            vg2.addEdgeIfVisible(port1, port2, edge.source.index, edge.target.index);\n            if (typeof draw !== 'undefined') {\n                draw(vg2);\n            }\n            var sourceInd = e => e.source.id, targetInd = e => e.target.id, length = e => e.length(),\n                spCalc = new Calculator(vg2.V.length, vg2.E, sourceInd, targetInd, length),\n                shortestPath = spCalc.PathFromNodeToNode(start.id, end.id);\n            if (shortestPath.length === 1 || shortestPath.length === vg2.V.length) {\n                let route = makeEdgeBetween(edge.source.innerBounds, edge.target.innerBounds, ah);\n                lineData = [route.sourceIntersection, route.arrowStart];\n            } else {\n                var n = shortestPath.length - 2,\n                    p = vg2.V[shortestPath[n]].p,\n                    q = vg2.V[shortestPath[0]].p,\n                    lineData = [edge.source.innerBounds.rayIntersection(p.x, p.y)];\n                for (var i = n; i >= 0; --i)\n                    lineData.push(vg2.V[shortestPath[i]].p);\n                lineData.push(makeEdgeTo(q, edge.target.innerBounds, ah));\n            }\n            //lineData.forEach((v, i) => {\n            //    if (i > 0) {\n            //        var u = lineData[i - 1];\n            //        this._nodes.forEach(function (node) {\n            //            if (node.id === getSourceIndex(d) || node.id === getTargetIndex(d)) return;\n            //            var ints = node.innerBounds.lineIntersections(u.x, u.y, v.x, v.y);\n            //            if (ints.length > 0) {\n            //                debugger;\n            //            }\n            //        })\n            //    }\n            //})\n            return lineData;\n        }\n\n        //The link source and target may be just a node index, or they may be references to nodes themselves.\n        static getSourceIndex(e: Link<Node | number>): number {\n            return typeof e.source === 'number' ? <number>e.source : (<Node>e.source).index;\n        }\n\n        //The link source and target may be just a node index, or they may be references to nodes themselves.\n        static getTargetIndex(e: Link<Node | number>): number {\n            return typeof e.target === 'number' ? <number>e.target : (<Node>e.target).index;\n        }\n\n        // Get a string ID for a given link.\n        static linkId(e: Link<Node | number>): string {\n            return Layout.getSourceIndex(e) + \"-\" + Layout.getTargetIndex(e);\n        }\n\n        // The fixed property has three bits:\n        // Bit 1 can be set externally (e.g., d.fixed = true) and show persist.\n        // Bit 2 stores the dragging state, from mousedown to mouseup.\n        // Bit 3 stores the hover state, from mouseover to mouseout.\n        static dragStart(d: Node | Group) {\n            if (isGroup(d)) {\n                Layout.storeOffset(d, Layout.dragOrigin(d));\n            } else {\n                Layout.stopNode(d);\n                d.fixed |= 2; // set bit 2\n            }\n        }\n\n        // we clobber any existing desired positions for nodes\n        // in case another tick event occurs before the drag\n        private static stopNode(v: Node) {\n            (<any>v).px = v.x;\n            (<any>v).py = v.y;\n        }\n\n        // we store offsets for each node relative to the centre of the ancestor group\n        // being dragged in a pair of properties on the node\n        private static storeOffset(d: Group, origin: { x: number, y: number }) {\n            if (typeof d.leaves !== 'undefined') {\n                d.leaves.forEach(v => {\n                    v.fixed |= 2;\n                    Layout.stopNode(v);\n                    (<any>v)._dragGroupOffsetX = v.x - origin.x;\n                    (<any>v)._dragGroupOffsetY = v.y - origin.y;\n                });\n            }\n            if (typeof d.groups !== 'undefined') {\n                d.groups.forEach(g => Layout.storeOffset(g, origin));\n            }\n        }\n\n        // the drag origin is taken as the centre of the node or group\n        static dragOrigin(d: Node | Group): { x: number, y: number } {\n            if (isGroup(d)) {\n                return {\n                    x: d.bounds.cx(),\n                    y: d.bounds.cy()\n                };\n            } else {\n                return d;\n            }\n        }\n\n        // for groups, the drag translation is propagated down to all of the children of\n        // the group.\n        static drag(d: Node | Group, position: { x: number, y: number }) {\n            if (isGroup(d)) {\n                if (typeof d.leaves !== 'undefined') {\n                    d.leaves.forEach(v => {\n                        d.bounds.setXCentre(position.x);\n                        d.bounds.setYCentre(position.y);\n                        (<any>v).px = (<any>v)._dragGroupOffsetX + position.x;\n                        (<any>v).py = (<any>v)._dragGroupOffsetY + position.y;\n                    });\n                }\n                if (typeof d.groups !== 'undefined') {\n                    d.groups.forEach(g => Layout.drag(g, position));\n                }\n            } else {\n                (<any>d).px = position.x;\n                (<any>d).py = position.y;\n            }\n        }\n\n        // we unset only bits 2 and 3 so that the user can fix nodes with another a different\n        // bit such that the lock persists between drags\n        static dragEnd(d) {\n            if (isGroup(d)) {\n                if (typeof d.leaves !== 'undefined') {\n                    d.leaves.forEach(v => {\n                        Layout.dragEnd(v);\n                        delete (<any>v)._dragGroupOffsetX;\n                        delete (<any>v)._dragGroupOffsetY;\n                    });\n                }\n                if (typeof d.groups !== 'undefined') {\n                    d.groups.forEach(Layout.dragEnd);\n                }\n            } else {\n                d.fixed &= ~6; // unset bits 2 and 3\n                //d.fixed = 0;\n            }\n        }\n\n        // in d3 hover temporarily locks nodes, currently not used in cola\n        static mouseOver(d) {\n            d.fixed |= 4; // set bit 3\n            d.px = d.x, d.py = d.y; // set velocity to zero\n        }\n\n        // in d3 hover temporarily locks nodes, currently not used in cola\n        static mouseOut(d) {\n            d.fixed &= ~4; // unset bit 3\n        }\n    }\n","/**\n * Loads the WebAssembly module that performs the derivative computations for `descent.ts`\n */\n\nimport * as wasmSIMD from './wasm/build/simd/derivative_computer';\nimport wasmSIMD_bg from './wasm/build/simd/derivative_computer_bg.wasm';\nimport * as wasmNoSIMD from './wasm/build/no_simd/derivative_computer';\nimport wasmNoSIMD_bg from './wasm/build/no_simd/derivative_computer_bg.wasm';\n\n// prettier-ignore\nconst getHasSIMDSupport = async () => WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))\n\nclass AsyncOnce<T> {\n  private getter: () => Promise<T>;\n  private pending: Promise<T> | null = null;\n  private res: null | { value: T };\n\n  public constructor(getter: () => Promise<T>) {\n    this.getter = getter;\n  }\n\n  public async get(): Promise<T> {\n    if (this.res) {\n      return this.res.value;\n    }\n    if (this.pending) {\n      return this.pending;\n    }\n\n    this.pending = new Promise((resolve) =>\n      this.getter().then((res) => {\n        this.res = { value: res };\n        this.pending = null;\n        resolve(res);\n      })\n    );\n    return this.pending!;\n  }\n}\n\nconst WasmInst = new AsyncOnce(async () => {\n  const hasWasmSIMDSupport = await getHasSIMDSupport();\n  if (!window.location.href.includes('localhost')) {\n    console.log(\n      hasWasmSIMDSupport\n        ? 'Wasm SIMD support detected!'\n        : 'Wasm SIMD support NOT detected; using non-SIMD Wasm'\n    );\n  }\n\n  if (hasWasmSIMDSupport) {\n    const wasmModule = await (wasmSIMD_bg as any)();\n    (wasmSIMD as any).setWasm(wasmModule);\n    return wasmSIMD;\n  } else {\n    const wasmModule = await (wasmNoSIMD_bg as any)();\n    (wasmNoSIMD as any).setWasm(wasmModule);\n    return wasmNoSIMD;\n  }\n});\n\ntype PromiseResolveType<P> = P extends Promise<infer T> ? T : never;\n\nexport type DerivativeComputerWasmInst = PromiseResolveType<ReturnType<typeof WasmInst.get>>;\n\nexport const getDerivativeComputerWasm = (): Promise<DerivativeComputerWasmInst> => WasmInst.get();\n","import {Layout, EventType, Event} from './layout'\n\n    export class LayoutAdaptor extends Layout {\n\n        // dummy functions in case not defined by client\n        trigger(e: Event) {};\n        kick() {};\n        drag() {};\n        on(eventType: EventType | string, listener: () => void) : this { return this; };\n\n        dragstart: (d:any) => void;\n        dragStart: (d:any) => void;\n        dragend: (d:any) => void;\n        dragEnd: (d:any) => void;\n\n        constructor( options ) {\n            super();\n\n            // take in implementation as defined by client\n\n            var self = this;\n            var o = options;\n\n            if ( o.trigger ) {\n                this.trigger = o.trigger;\n            }\n\n            if ( o.kick ){\n                this.kick = o.kick;\n            }\n\n            if ( o.drag ){\n                this.drag = o.drag;\n            }\n\n            if ( o.on ){\n                this.on = o.on;\n            }\n\n            this.dragstart = this.dragStart = Layout.dragStart;\n            this.dragend = this.dragEnd = Layout.dragEnd;\n        }\n    }\n\n    /**\n     * provides an interface for use with any external graph system (e.g. Cytoscape.js):\n     */\n    export function adaptor( options ): LayoutAdaptor {\n        return new LayoutAdaptor( options );\n    }\n","////<reference path=\"../extern/d3v3.d.ts\"/>\n////commented out the reference, because the path ended up in the typings, which\n////makes it impossible import in other projects.\n// declare const d3;\n\n\nimport {Layout, EventType, Event} from './layout';\nimport {ID3StyleLayoutAdaptor} from './d3adaptor'\n\n    /**\n     * @internal\n     */\n    export class D3StyleLayoutAdaptor extends Layout implements ID3StyleLayoutAdaptor {\n        protected readonly event: any;\n\n        trigger(e: Event) {\n            var d3event = { type: EventType[e.type], alpha: e.alpha, stress: e.stress };\n            this.event[d3event.type](d3event); // via d3 dispatcher, e.g. event.start(e);\n        }\n\n        // iterate layout using a d3.timer, which queues calls to tick repeatedly until tick returns true\n        kick() {\n            this.d3Context.timer(() => super.tick());\n        }\n\n        // a function to allow for dragging of nodes\n        drag: () => any;\n\n        private d3Context: any;\n\n        constructor(d3Context: any = self.d3) {\n            super();\n            this.d3Context = d3Context;\n            this.event = d3Context.dispatch(EventType[EventType.start], EventType[EventType.tick], EventType[EventType.end]);\n            // bit of trickyness remapping 'this' so we can reference it in the function body.\n            var d3layout = this;\n            var drag;\n            this.drag = function () {\n                if (!drag) {\n                    var drag = d3Context.behavior.drag()\n                        .origin(Layout.dragOrigin)\n                        .on(\"dragstart.d3adaptor\", Layout.dragStart)\n                        .on(\"drag.d3adaptor\", d => {\n                            Layout.drag(d, <any>d3layout.d3Context.event);\n                            d3layout.resume(); // restart annealing\n                        })\n                        .on(\"dragend.d3adaptor\", Layout.dragEnd);\n                }\n\n                if (!arguments.length) return drag;\n\n                // this is the context of the function, i.e. the d3 selection\n                this//.on(\"mouseover.adaptor\", colaMouseover)\n                //.on(\"mouseout.adaptor\", colaMouseout)\n                    .call(drag);\n            }\n        }\n\n        // a function for binding to events on the adapter\n        on(eventType: EventType | string, listener: () => void): this {\n            if (typeof eventType === 'string') {\n                this.event.on(eventType, listener);\n            } else {\n                this.event.on(EventType[eventType], listener);\n            }\n            return this;\n        }\n    }\n","import {dispatch} from 'd3-dispatch'\nimport {timer} from 'd3-timer'\nimport {drag as d3drag} from 'd3-drag'\nimport {Layout, EventType, Event} from './layout'\nimport {ID3StyleLayoutAdaptor} from './d3adaptor'\n\nexport interface D3Context {\n    timer: typeof timer; \n    drag: typeof d3drag; \n    dispatch: typeof dispatch;\n    event: any;\n}\n\n/**\n * @internal\n */\nexport class D3v4StyleLayoutAdaptor extends Layout implements ID3StyleLayoutAdaptor {\n    event:any;\n    trigger(e: Event) {\n        var d3event = { type: EventType[e.type], alpha: e.alpha, stress: e.stress };\n        // the dispatcher is actually expecting something of type EventTarget as the second argument\n        // so passing the thing above is totally abusing the pattern... not sure what to do about this yet\n        this.event.call(d3event.type, <any>d3event); // via d3 dispatcher, e.g. event.start(e);\n    }\n\n    // iterate layout using a d3.timer, which queues calls to tick repeatedly until tick returns true\n    kick() {\n        var t = this.d3Context.timer(() => super.tick() && t.stop());\n    }\n\n    // a function to allow for dragging of nodes\n    drag: () => any;\n\n    /**\n     * @internal\n     */\n    private readonly d3Context: D3Context;\n\n    constructor(d3Context: D3Context) {\n        super();\n        this.d3Context = d3Context;\n        this.event = d3Context.dispatch(EventType[EventType.start], EventType[EventType.tick], EventType[EventType.end]);\n\n        // bit of trickyness remapping 'this' so we can reference it in the function body.\n        var d3layout = this;\n        var drag;\n        this.drag = function () {\n            if (!drag) {\n                var drag = d3Context.drag()\n                    .subject(Layout.dragOrigin)\n                    .on(\"start.d3adaptor\", Layout.dragStart)\n                    .on(\"drag.d3adaptor\", d => {\n                        Layout.drag(<any>d, d3Context.event);\n                        d3layout.resume(); // restart annealing\n                    })\n                    .on(\"end.d3adaptor\", Layout.dragEnd);\n            }\n\n            if (!arguments.length) return drag;\n\n            // this is the context of the function, i.e. the d3 selection\n            //this//.on(\"mouseover.adaptor\", colaMouseover)\n            //.on(\"mouseout.adaptor\", colaMouseout)\n            arguments[0].call(drag);\n        }\n    }\n\n    // a function for binding to events on the adapter\n    on(eventType: EventType | string, listener: () => void): this {\n        if (typeof eventType === 'string') {\n            this.event.on(eventType, listener);\n        } else {\n            this.event.on(EventType[eventType], listener);\n        }\n        return this;\n    }\n}\n","import {Point} from './geom'\nimport {Rectangle} from './rectangle'\nimport {Constraint, Solver, Variable} from './vpsc'\nimport {Calculator} from './shortestpaths'\n    export interface NodeAccessor<Node>{\n        getChildren(v:Node) : number[];\n        getBounds(v:Node) : Rectangle;\n    }\n    export class NodeWrapper {\n        leaf: boolean;\n        parent: NodeWrapper;\n        ports: Vert[];\n        constructor(public id: number, public rect: Rectangle, public children: number[]) {\n            this.leaf = typeof children === 'undefined' || children.length === 0;\n        }\n    }\n    export class Vert {\n        constructor(public id: number, public x:number, public y: number, public node: NodeWrapper = null, public line = null) {}\n    }\n\n    export class LongestCommonSubsequence<T> {\n        length: number;\n        si: number;\n        ti: number;\n        reversed: boolean;\n        constructor(public s: T[], public t: T[]) {\n            var mf = LongestCommonSubsequence.findMatch(s, t);\n            var tr = t.slice(0).reverse();\n            var mr = LongestCommonSubsequence.findMatch(s, tr);\n            if (mf.length >= mr.length) {\n                this.length = mf.length;\n                this.si = mf.si;\n                this.ti = mf.ti;\n                this.reversed = false;\n            } else {\n                this.length = mr.length;\n                this.si = mr.si;\n                this.ti = t.length - mr.ti - mr.length;\n                this.reversed = true;\n            }\n        }\n        private static findMatch<T>(s: T[], t: T[]) {\n            var m = s.length;\n            var n = t.length;\n            var match = { length: 0, si: -1, ti: -1 };\n            var l = new Array(m);\n            for (var i = 0; i < m; i++) {\n                l[i] = new Array(n);\n                for (var j = 0; j < n; j++)\n                    if (s[i] === t[j]) {\n                        var v = l[i][j] = (i === 0 || j === 0) ? 1 : l[i - 1][j - 1] + 1;\n                        if (v > match.length) {\n                            match.length = v;\n                            match.si = i - v + 1;\n                            match.ti = j - v + 1;\n                        };\n                    } else l[i][j] = 0;\n            }\n            return match;\n        }\n        getSequence(): T[]{\n            return this.length >= 0 ? this.s.slice(this.si, this.si + this.length) : [];\n        }\n    }\n    // a horizontal or vertical line of nodes\n    export interface GridLine {\n        nodes: NodeWrapper[];\n        pos: number;\n    }\n    export class GridRouter<Node> {\n        leaves: NodeWrapper[] = null;\n        groups: NodeWrapper[];\n        nodes: NodeWrapper[];\n        cols: GridLine[];\n        rows: GridLine[];\n        root;\n        verts: Vert[];\n        edges;\n        backToFront;\n        obstacles;\n        passableEdges;\n        private avg(a) { return a.reduce((x, y) => x + y) / a.length }\n\n        // in the given axis, find sets of leaves overlapping in that axis\n        // center of each GridLine is average of all nodes in column\n        private getGridLines(axis): GridLine[] {\n            var columns = [];\n            var ls = this.leaves.slice(0, this.leaves.length);\n            while (ls.length > 0) {\n                // find a column of all leaves overlapping in axis with the first leaf\n                let overlapping = ls.filter(v=> v.rect['overlap' + axis.toUpperCase()](ls[0].rect));\n                let col = {\n                    nodes: overlapping,\n                    pos: this.avg(overlapping.map(v=> v.rect['c' + axis]()))\n                };\n                columns.push(col);\n                col.nodes.forEach(v=> ls.splice(ls.indexOf(v), 1));\n            }\n            columns.sort((a, b) => a.pos - b.pos)\n            return columns;\n        }\n\n        // get the depth of the given node in the group hierarchy\n        private getDepth(v) {\n            var depth = 0;\n            while (v.parent !== this.root) {\n                depth++;\n                v = v.parent;\n            }\n            return depth;\n        }\n\n        // medial axes between node centres and also boundary lines for the grid\n        private midPoints(a) {\n            if (a.length === 1) {\n                return [a[0]]\n            }\n\n            var gap = a[1] - a[0];\n            var mids = [a[0] - gap / 2];\n            for (var i = 1; i < a.length; i++) {\n                mids.push((a[i] + a[i - 1]) / 2);\n            }\n            mids.push(a[a.length - 1] + gap / 2);\n            return mids;\n        }\n\n        constructor(public originalnodes: Node[], accessor: NodeAccessor<Node>, public groupPadding: number = 12) {\n            this.nodes = originalnodes.map((v, i) => new NodeWrapper(i, accessor.getBounds(v), accessor.getChildren(v)));\n            this.leaves = this.nodes.filter(v=> v.leaf);\n            this.groups = this.nodes.filter(g=> !g.leaf);\n            this.cols = this.getGridLines('x');\n            this.rows = this.getGridLines('y');\n\n            // create parents for each node or group that is a member of another's children\n            this.groups.forEach(v=>\n                v.children.forEach(c=> this.nodes[<number>c].parent = v));\n\n            // root claims the remaining orphans\n            this.root = { children: [] };\n            this.nodes.forEach(v=> {\n                if (typeof v.parent === 'undefined') {\n                    v.parent = this.root;\n                    this.root.children.push(v.id);\n                }\n\n                // each node will have grid vertices associated with it,\n                // some inside the node and some on the boundary\n                // leaf nodes will have exactly one internal node at the center\n                // and four boundary nodes\n                // groups will have potentially many of each\n                v.ports = []\n            });\n\n            // nodes ordered by their position in the group hierarchy\n            this.backToFront = this.nodes.slice(0);\n            this.backToFront.sort((x, y) => this.getDepth(x) - this.getDepth(y));\n\n            // compute boundary rectangles for each group\n            // has to be done from front to back, i.e. inside groups to outside groups\n            // such that each can be made large enough to enclose its interior\n            var frontToBackGroups = this.backToFront.slice(0).reverse().filter(g=> !g.leaf);\n            frontToBackGroups.forEach(v=> {\n                var r = Rectangle.empty();\n                v.children.forEach(c=> r = r.union(this.nodes[c].rect));\n                v.rect = r.inflate(this.groupPadding);\n            });\n\n            var colMids = this.midPoints(this.cols.map(r=> r.pos));\n            var rowMids = this.midPoints(this.rows.map(r=> r.pos));\n\n            // setup extents of lines\n            var rowx = colMids[0], rowX = colMids[colMids.length - 1];\n            var coly = rowMids[0], colY = rowMids[rowMids.length - 1];\n\n            // horizontal lines\n            var hlines = this.rows.map(r=> <any>{ x1: rowx, x2: rowX, y1: r.pos, y2: r.pos })\n                .concat(rowMids.map(m=> <any>{ x1: rowx, x2: rowX, y1: m, y2: m }));\n\n            // vertical lines\n            var vlines = this.cols.map(c=> <any>{ x1: c.pos, x2: c.pos, y1: coly, y2: colY })\n                .concat(colMids.map(m=> <any>{ x1: m, x2: m, y1: coly, y2: colY }));\n\n            // the full set of lines\n            var lines = hlines.concat(vlines);\n\n            // we record the vertices associated with each line\n            lines.forEach(l=> l.verts = []);\n\n            // the routing graph\n            this.verts = [];\n            this.edges = [];\n\n            // create vertices at the crossings of horizontal and vertical grid-lines\n            hlines.forEach(h=>\n                vlines.forEach(v=> {\n                    var p = new Vert(this.verts.length, v.x1, h.y1);\n                    h.verts.push(p);\n                    v.verts.push(p);\n                    this.verts.push(p);\n\n                    // assign vertices to the nodes immediately under them\n                    var i = this.backToFront.length;\n                    while (i-- > 0) {\n                        var node = this.backToFront[i],\n                            r = node.rect;\n                        var dx = Math.abs(p.x - r.cx()),\n                            dy = Math.abs(p.y - r.cy());\n                        if (dx < r.width() / 2 && dy < r.height() / 2) {\n                            (<any>p).node = node;\n                            break;\n                        }\n                    }\n                })\n                );\n\n            lines.forEach((l, li) => {\n                // create vertices at the intersections of nodes and lines\n                this.nodes.forEach((v, i) => {\n                    v.rect.lineIntersections(l.x1, l.y1, l.x2, l.y2).forEach((intersect, j) => {\n                        //console.log(li+','+i+','+j+':'+intersect.x + ',' + intersect.y);\n                        var p = new Vert(this.verts.length, intersect.x, intersect.y, v, l);\n                        this.verts.push(p);\n                        l.verts.push(p);\n                        v.ports.push(p);\n                    });\n                });\n\n                // split lines into edges joining vertices\n                var isHoriz = Math.abs(l.y1 - l.y2) < 0.1;\n                var delta = (a, b) => isHoriz ? b.x - a.x : b.y - a.y;\n                l.verts.sort(delta);\n                for (var i = 1; i < l.verts.length; i++) {\n                    var u = l.verts[i - 1], v = l.verts[i];\n                    if (u.node && u.node === v.node && u.node.leaf) continue;\n                    this.edges.push({ source: u.id, target: v.id, length: Math.abs(delta(u, v)) });\n                }\n            });\n\n\n\n        }\n\n        // find path from v to root including both v and root\n        private findLineage(v) {\n            var lineage = [v];\n            do {\n                v = v.parent;\n                lineage.push(v);\n            } while (v !== this.root);\n            return lineage.reverse();\n        }\n\n        // find path connecting a and b through their lowest common ancestor\n        private findAncestorPathBetween(a, b) {\n            var aa = this.findLineage(a), ba = this.findLineage(b), i = 0;\n            while (aa[i] === ba[i]) i++;\n            // i-1 to include common ancestor only once (as first element)\n            return { commonAncestor: aa[i - 1], lineages: aa.slice(i).concat(ba.slice(i)) };\n        }\n\n        // when finding a path between two nodes a and b, siblings of a and b on the\n        // paths from a and b to their least common ancestor are obstacles\n        siblingObstacles(a, b) {\n            var path = this.findAncestorPathBetween(a, b);\n            var lineageLookup = {};\n            path.lineages.forEach(v=> lineageLookup[v.id] = {});\n            var obstacles = path.commonAncestor.children.filter(v=> !(v in lineageLookup));\n\n            path.lineages\n                .filter(v=> v.parent !== path.commonAncestor)\n                .forEach(v=> obstacles = obstacles.concat(v.parent.children.filter(c=> c !== v.id)));\n\n            return obstacles.map(v=> this.nodes[v]);\n        }\n\n        // for the given routes, extract all the segments orthogonal to the axis x\n        // and return all them grouped by x position\n        static getSegmentSets(routes, x, y) {\n            // vsegments is a list of vertical segments sorted by x position\n            var vsegments = [];\n            for (var ei = 0; ei < routes.length; ei++) {\n                var route = routes[ei];\n                for (var si = 0; si < route.length; si++) {\n                    var s = <any>route[si];\n                    s.edgeid = ei;\n                    s.i = si;\n                    var sdx = s[1][x] - s[0][x];\n                    if (Math.abs(sdx) < 0.1) {\n                        vsegments.push(s);\n                    }\n                }\n            }\n            vsegments.sort((a, b) => a[0][x] - b[0][x]);\n\n            // vsegmentsets is a set of sets of segments grouped by x position\n            var vsegmentsets = [];\n            var segmentset = null;\n            for (var i = 0; i < vsegments.length; i++) {\n                var s = vsegments[i];\n                if (!segmentset || Math.abs(s[0][x] - segmentset.pos) > 0.1) {\n                    segmentset = { pos: s[0][x], segments: [] };\n                    vsegmentsets.push(segmentset);\n                }\n                segmentset.segments.push(s);\n            }\n            return vsegmentsets;\n        }\n\n        // for all segments in this bundle create a vpsc problem such that\n        // each segment's x position is a variable and separation constraints\n        // are given by the partial order over the edges to which the segments belong\n        // for each pair s1,s2 of segments in the open set:\n        //   e1 = edge of s1, e2 = edge of s2\n        //   if leftOf(e1,e2) create constraint s1.x + gap <= s2.x\n        //   else if leftOf(e2,e1) create cons. s2.x + gap <= s1.x\n        static nudgeSegs(x: string, y: string, routes, segments, leftOf, gap: number) {\n            var n = segments.length;\n            if (n <= 1) return;\n            var vs = segments.map(s => new Variable(s[0][x]));\n            var cs = [];\n            for (var i = 0; i < n; i++) {\n                for (var j = 0; j < n; j++) {\n                    if (i === j) continue;\n                    var s1 = segments[i],\n                        s2 = segments[j],\n                        e1 = s1.edgeid,\n                        e2 = s2.edgeid,\n                        lind = -1,\n                        rind = -1;\n                    // in page coordinates (not cartesian) the notion of 'leftof' is flipped in the horizontal axis from the vertical axis\n                    // that is, when nudging vertical segments, if they increase in the y(conj) direction the segment belonging to the\n                    // 'left' edge actually needs to be nudged to the right\n                    // when nudging horizontal segments, if the segments increase in the x direction\n                    // then the 'left' segment needs to go higher, i.e. to have y pos less than that of the right\n                    if (x == 'x') {\n                        if (leftOf(e1, e2)) {\n                            //console.log('s1: ' + s1[0][x] + ',' + s1[0][y] + '-' + s1[1][x] + ',' + s1[1][y]);\n                            if (s1[0][y] < s1[1][y]) {\n                                lind = j, rind = i;\n                            } else {\n                                lind = i, rind = j;\n                            }\n                        }\n                    } else {\n                        if (leftOf(e1, e2)) {\n                            if (s1[0][y] < s1[1][y]) {\n                                lind = i, rind = j;\n                            } else {\n                                lind = j, rind = i;\n                            }\n                        }\n                    }\n                    if (lind >= 0) {\n                        //console.log(x+' constraint: ' + lind + '<' + rind);\n                        cs.push(new Constraint(vs[lind], vs[rind], gap));\n                    }\n                }\n            }\n            var solver = new Solver(vs, cs);\n            solver.solve();\n            vs.forEach((v, i) => {\n                var s = segments[i];\n                var pos = v.position();\n                s[0][x] = s[1][x] = pos;\n                var route = routes[s.edgeid];\n                if (s.i > 0) route[s.i - 1][1][x] = pos;\n                if (s.i < route.length - 1) route[s.i + 1][0][x] = pos;\n            });\n        }\n\n        static nudgeSegments(routes, x: string, y: string, leftOf: (e1: number, e2: number) => boolean, gap: number) {\n            var vsegmentsets = GridRouter.getSegmentSets(routes, x, y);\n            // scan the grouped (by x) segment sets to find co-linear bundles\n            for (var i = 0; i < vsegmentsets.length; i++) {\n                var ss = vsegmentsets[i];\n                var events = [];\n                for (var j = 0; j < ss.segments.length; j++) {\n                    var s = ss.segments[j];\n                    events.push({ type: 0, s: s, pos: Math.min(s[0][y], s[1][y]) });\n                    events.push({ type: 1, s: s, pos: Math.max(s[0][y], s[1][y]) });\n                }\n                events.sort((a, b) => a.pos - b.pos + a.type - b.type);\n                var open = [];\n                var openCount = 0;\n                events.forEach(e=> {\n                    if (e.type === 0) {\n                        open.push(e.s);\n                        openCount++;\n                    } else {\n                        openCount--;\n                    }\n                    if (openCount == 0) {\n                        GridRouter.nudgeSegs(x, y, routes, open, leftOf, gap);\n                        open = [];\n                    }\n                });\n            }\n        }\n\n        // obtain routes for the specified edges, nicely nudged apart\n        // warning: edge paths may be reversed such that common paths are ordered consistently within bundles!\n        // @param edges list of edges\n        // @param nudgeGap how much to space parallel edge segements\n        // @param source function to retrieve the index of the source node for a given edge\n        // @param target function to retrieve the index of the target node for a given edge\n        // @returns an array giving, for each edge, an array of segments, each segment a pair of points in an array\n        routeEdges<Edge>(edges: Edge[], nudgeGap: number, source: (e: Edge) => number, target: (e: Edge) => number): Point[][][] {\n            var routePaths = edges.map(e=> this.route(source(e), target(e)));\n            var order = GridRouter.orderEdges(routePaths);\n            var routes = routePaths.map(function (e) { return GridRouter.makeSegments(e); });\n            GridRouter.nudgeSegments(routes, 'x', 'y', order, nudgeGap);\n            GridRouter.nudgeSegments(routes, 'y', 'x', order, nudgeGap);\n            GridRouter.unreverseEdges(routes, routePaths);\n            return routes;\n        }\n\n        // path may have been reversed by the subsequence processing in orderEdges\n        // so now we need to restore the original order\n        static unreverseEdges(routes, routePaths) {\n            routes.forEach((segments, i) => {\n                var path = routePaths[i];\n                if ((<any>path).reversed) {\n                    segments.reverse(); // reverse order of segments\n                    segments.forEach(function (segment) {\n                        segment.reverse();  // reverse each segment\n                    });\n                }\n            });\n        }\n\n        static angleBetween2Lines(line1: Point[], line2: Point[]): number {\n            var angle1 = Math.atan2(line1[0].y - line1[1].y,\n                line1[0].x - line1[1].x);\n            var angle2 = Math.atan2(line2[0].y - line2[1].y,\n                line2[0].x - line2[1].x);\n            var diff = angle1 - angle2;\n            if (diff > Math.PI || diff < -Math.PI) {\n                diff = angle2 - angle1;\n            }\n            return diff;\n        }\n\n        // does the path a-b-c describe a left turn?\n        private static isLeft(a, b, c) {\n            return ((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) <= 0;\n        }\n\n        // for the given list of ordered pairs, returns a function that (efficiently) looks-up a specific pair to\n        // see if it exists in the list\n        private static getOrder(pairs: { l: number; r: number }[]): (l: number, r: number) => boolean {\n            var outgoing = {};\n            for (var i = 0; i < pairs.length; i++) {\n                var p = pairs[i];\n                if (typeof outgoing[p.l] === 'undefined') outgoing[p.l] = {};\n                outgoing[p.l][p.r] = true;\n            }\n            return (l, r) => typeof outgoing[l] !== 'undefined' && outgoing[l][r];\n        }\n\n        // returns an ordering (a lookup function) that determines the correct order to nudge the\n        // edge paths apart to minimize crossings\n        static orderEdges(edges) {\n            var edgeOrder = [];\n            for (var i = 0; i < edges.length - 1; i++) {\n                for (var j = i + 1; j < edges.length; j++) {\n                    var e = edges[i],\n                        f = edges[j],\n                        lcs = new LongestCommonSubsequence(e, f);\n                    var u, vi, vj;\n                    if (lcs.length === 0)\n                        continue; // no common subpath\n                    if (lcs.reversed) {\n                        // if we found a common subpath but one of the edges runs the wrong way,\n                        // then reverse f.\n                        f.reverse();\n                        f.reversed = true;\n                        lcs = new LongestCommonSubsequence(e, f);\n                    }\n                    if ((lcs.si <= 0 || lcs.ti <= 0) &&\n                        (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length)) {\n                        // the paths do not diverge, so make an arbitrary ordering decision\n                        edgeOrder.push({ l: i, r: j });\n                        continue;\n                    }\n                    if (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length) {\n                        // if the common subsequence of the\n                        // two edges being considered goes all the way to the\n                        // end of one (or both) of the lines then we have to\n                        // base our ordering decision on the other end of the\n                        // common subsequence\n                        u = e[lcs.si + 1];\n                        vj = e[lcs.si - 1];\n                        vi = f[lcs.ti - 1];\n                    } else {\n                        u = e[lcs.si + lcs.length - 2];\n                        vi = e[lcs.si + lcs.length];\n                        vj = f[lcs.ti + lcs.length];\n                    }\n                    if (GridRouter.isLeft(u, vi, vj)) {\n                        edgeOrder.push({ l: j, r: i });\n                    } else {\n                        edgeOrder.push({ l: i, r: j });\n                    }\n                }\n            }\n            //edgeOrder.forEach(function (e) { console.log('l:' + e.l + ',r:' + e.r) });\n            return GridRouter.getOrder(edgeOrder);\n        }\n\n        // for an orthogonal path described by a sequence of points, create a list of segments\n        // if consecutive segments would make a straight line they are merged into a single segment\n        // segments are over cloned points, not the original vertices\n        static makeSegments(path: Point[]): Point[][] {\n            function copyPoint(p: Point) {\n                return <Point>{ x: p.x, y: p.y };\n            }\n            var isStraight = (a, b, c) => Math.abs((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) < 0.001;\n            var segments = [];\n            var a = copyPoint(path[0]);\n            for (var i = 1; i < path.length; i++) {\n                var b = copyPoint(path[i]), c = i < path.length - 1 ? path[i + 1] : null;\n                if (!c || !isStraight(a, b, c)) {\n                    segments.push([a, b]);\n                    a = b;\n                }\n            }\n            return segments;\n        }\n\n        // find a route between node s and node t\n        // returns an array of indices to verts\n        route(s: number, t: number): Point[] {\n            var source = this.nodes[<number>s], target = this.nodes[<number>t];\n            this.obstacles = this.siblingObstacles(source, target);\n\n            var obstacleLookup = {};\n            this.obstacles.forEach(o => obstacleLookup[o.id] = o);\n            this.passableEdges = this.edges.filter(e=> {\n                var u = this.verts[e.source],\n                    v = this.verts[e.target];\n                return !(u.node && u.node.id in obstacleLookup\n                    || v.node && v.node.id in obstacleLookup);\n            });\n\n            // add dummy segments linking ports inside source and target\n            for (var i = 1; i < source.ports.length; i++) {\n                var u = source.ports[0].id;\n                var v = source.ports[i].id;\n                this.passableEdges.push({\n                    source: u,\n                    target: v,\n                    length: 0\n                });\n            }\n            for (var i = 1; i < target.ports.length; i++) {\n                var u = target.ports[0].id;\n                var v = target.ports[i].id;\n                this.passableEdges.push({\n                    source: u,\n                    target: v,\n                    length: 0\n                });\n            }\n\n            var getSource = e=> e.source,\n                getTarget = e=> e.target,\n                getLength = e=> e.length;\n\n            var shortestPathCalculator = new Calculator(this.verts.length, this.passableEdges, getSource, getTarget, getLength);\n            var bendPenalty = (u, v, w) => {\n                var a = this.verts[u], b = this.verts[v], c = this.verts[w];\n                var dx = Math.abs(c.x - a.x), dy = Math.abs(c.y - a.y);\n                // don't count bends from internal node edges\n                if (a.node === source && a.node === b.node || b.node === target && b.node === c.node)\n                    return 0;\n                return dx > 1 && dy > 1 ? 1000 : 0;\n            };\n\n            // get shortest path\n            var shortestPath = shortestPathCalculator.PathFromNodeToNodeWithPrevCost(\n                source.ports[0].id, target.ports[0].id,\n                bendPenalty);\n\n            // shortest path is reversed and does not include the target port\n            var pathPoints = shortestPath.reverse().map(vi => this.verts[vi]);\n            pathPoints.push(this.nodes[target.id].ports[0]);\n\n            // filter out any extra end points that are inside the source or target (i.e. the dummy segments above)\n            return pathPoints.filter((v, i) =>\n                !(i < pathPoints.length - 1 && pathPoints[i + 1].node === source && v.node === source\n                    || i > 0 && v.node === target && pathPoints[i - 1].node === target));\n        }\n\n        static getRoutePath(route: Point[][], cornerradius: number, arrowwidth: number, arrowheight: number): { routepath: string; arrowpath: string } {\n            var result = {\n                routepath: 'M ' + route[0][0].x + ' ' + route[0][0].y + ' ',\n                arrowpath: ''\n            };\n            if (route.length > 1) {\n                for (var i = 0; i < route.length; i++) {\n                    var li = route[i];\n                    var x = li[1].x, y = li[1].y;\n                    var dx = x - li[0].x;\n                    var dy = y - li[0].y;\n                    if (i < route.length - 1) {\n                        if (Math.abs(dx) > 0) {\n                            x -= dx / Math.abs(dx) * cornerradius;\n                        } else {\n                            y -= dy / Math.abs(dy) * cornerradius;\n                        }\n                        result.routepath += 'L ' + x + ' ' + y + ' ';\n                        var l = route[i + 1];\n                        var x0 = l[0].x, y0 = l[0].y;\n                        var x1 = l[1].x;\n                        var y1 = l[1].y;\n                        dx = x1 - x0;\n                        dy = y1 - y0;\n                        var angle = GridRouter.angleBetween2Lines(li, l) < 0 ? 1 : 0;\n                        //console.log(cola.GridRouter.angleBetween2Lines(li, l))\n                        var x2, y2;\n                        if (Math.abs(dx) > 0) {\n                            x2 = x0 + dx / Math.abs(dx) * cornerradius;\n                            y2 = y0;\n                        } else {\n                            x2 = x0;\n                            y2 = y0 + dy / Math.abs(dy) * cornerradius;\n                        }\n                        var cx = Math.abs(x2 - x);\n                        var cy = Math.abs(y2 - y);\n                        result.routepath += 'A ' + cx + ' ' + cy + ' 0 0 ' + angle + ' ' + x2 + ' ' + y2 + ' ';\n                    } else {\n                        var arrowtip = [x, y];\n                        var arrowcorner1, arrowcorner2;\n                        if (Math.abs(dx) > 0) {\n                            x -= dx / Math.abs(dx) * arrowheight;\n                            arrowcorner1 = [x, y + arrowwidth];\n                            arrowcorner2 = [x, y - arrowwidth];\n                        } else {\n                            y -= dy / Math.abs(dy) * arrowheight;\n                            arrowcorner1 = [x + arrowwidth, y];\n                            arrowcorner2 = [x - arrowwidth, y];\n                        }\n                        result.routepath += 'L ' + x + ' ' + y + ' ';\n                        if (arrowheight > 0) {\n                            result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1]\n                            + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];\n                        }\n                    }\n                }\n            } else {\n                var li = route[0];\n                var x = li[1].x, y = li[1].y;\n                var dx = x - li[0].x;\n                var dy = y - li[0].y;\n                var arrowtip = [x, y];\n                var arrowcorner1, arrowcorner2;\n                if (Math.abs(dx) > 0) {\n                    x -= dx / Math.abs(dx) * arrowheight;\n                    arrowcorner1 = [x, y + arrowwidth];\n                    arrowcorner2 = [x, y - arrowwidth];\n                } else {\n                    y -= dy / Math.abs(dy) * arrowheight;\n                    arrowcorner1 = [x + arrowwidth, y];\n                    arrowcorner2 = [x - arrowwidth, y];\n                }\n                result.routepath += 'L ' + x + ' ' + y + ' ';\n                if (arrowheight > 0) {\n                    result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1]\n                    + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];\n                }\n            }\n            return result;\n        }\n    }\n","import {Calculator} from './shortestpaths'\nimport {Descent} from './descent'\nimport {Projection, GraphNode, Rectangle} from './rectangle'\nimport {Variable} from './vpsc'\nimport {jaccardLinkLengths, LinkLengthAccessor} from './linklengths'\nimport { getDerivativeComputerWasm } from './wasmEngine'\n\n// Kick this off right away since we're going to need it eventually\nconst wasmInstPromise = getDerivativeComputerWasm();\n\nexport class Link3D {\n        length: number;\n        constructor(public source: number, public target: number) { }\n        actualLength(x: number[][]) {\n            return Math.sqrt(\n                x.reduce((c: number, v: number[]) => {\n                    const dx = v[this.target] - v[this.source];\n                    return c + dx * dx;\n                }, 0));\n        }\n    }\n    export class Node3D implements GraphNode {\n        // if fixed, layout will not move the node from its specified starting position\n        fixed: boolean;\n        width: number;\n        height: number;\n        px: number;\n        py: number;\n        bounds: Rectangle;\n        variable: Variable;\n        constructor(\n            public x: number = 0,\n            public y: number = 0,\n            public z: number = 0) { }\n    }\n    export class Layout3D {\n        static dims = ['x', 'y', 'z'];\n        static k = Layout3D.dims.length;\n        result: number[][];\n        constraints: any[] = null;\n\n        constructor(public nodes: Node3D[], public links: Link3D[], public idealLinkLength: number = 1) {\n            this.result = new Array(Layout3D.k);\n            for (var i = 0; i < Layout3D.k; ++i) {\n                this.result[i] = new Array(nodes.length);\n            }\n            nodes.forEach((v, i) => {\n                for (var dim of Layout3D.dims) {\n                    if (typeof v[dim] == 'undefined') v[dim] = Math.random();\n                }\n                this.result[0][i] = v.x;\n                this.result[1][i] = v.y;\n                this.result[2][i] = v.z;\n            });\n        };\n\n        linkLength(l: Link3D): number {\n            return l.actualLength(this.result);\n        }\n\n        useJaccardLinkLengths: boolean = true;\n\n        descent: Descent;\n        async start(iterations: number = 100): Promise<Layout3D> {\n            const n = this.nodes.length;\n\n            var linkAccessor = new LinkAccessor();\n\n            if (this.useJaccardLinkLengths)\n                jaccardLinkLengths(this.links, linkAccessor, 1.5);\n\n            this.links.forEach(e => e.length *= this.idealLinkLength);\n\n            // Create the distance matrix that Cola needs\n            const distanceMatrix = (new Calculator(n, this.links,\n                e=> e.source, e=> e.target, e => e.length)).DistanceMatrix();\n\n            const D = Descent.createSquareMatrix(n, (i, j) => distanceMatrix[i][j]);\n\n            // G is a square matrix with G[i][j] = 1 iff there exists an edge between node i and node j\n            // otherwise 2.\n            var G = Descent.createSquareMatrix(n, function () { return 2 });\n            this.links.forEach(({ source, target }) => G[source][target] = G[target][source] = 1);\n\n            const wasmInst = await wasmInstPromise;\n            this.descent = new Descent(this.result, D, undefined, wasmInst);\n            this.descent.threshold = 1e-3;\n            this.descent.G = G.map(Gn => new Float32Array(Gn));\n            //let constraints = this.links.map(e=> <any>{\n            //    axis: 'y', left: e.source, right: e.target, gap: e.length*1.5\n            //});\n            if (this.constraints)\n                this.descent.project = new Projection(<GraphNode[]>this.nodes, null, null, this.constraints).projectFunctions();\n\n            for (var i = 0; i < this.nodes.length; i++) {\n                var v = this.nodes[i];\n                if (v.fixed) {\n                    this.descent.locks.add(i, [v.x, v.y, v.z]);\n                }\n            }\n\n            this.descent.run(iterations);\n            return this;\n        }\n\n        tick(): number {\n            this.descent.locks.clear();\n            for (var i = 0; i < this.nodes.length; i++) {\n                var v = this.nodes[i];\n                if (v.fixed) {\n                    this.descent.locks.add(i, [v.x, v.y, v.z]);\n                }\n            }\n            return this.descent.rungeKutta();\n        }\n    }\n\n    class LinkAccessor implements LinkLengthAccessor<any> {\n        getSourceIndex(e: any): number { return e.source; }\n        getTargetIndex(e: any): number { return e.target; }\n        getLength(e: any): number { return e.length; }\n        setLength(e: any, l: number) { e.length = l; }\n    }\n","import {D3StyleLayoutAdaptor} from './d3v3adaptor'\nimport {D3Context, D3v4StyleLayoutAdaptor} from './d3v4adaptor'\nimport { Layout, EventType, Event } from './layout';\n\nexport { D3Context } from './d3v4adaptor';\n\nexport interface D3v3Context { version: string };\n\nexport interface ID3StyleLayoutAdaptor {\n    trigger(e: Event): void;\n    kick(): void;\n    drag: () => any;\n\n    on(eventType: EventType | string, listener: () => void): ID3StyleLayoutAdaptor;\n}\n\n\n/**\n * provides an interface for use with d3:\n * Correct way to create way to construct the d3 cola object is to pass the d3 object into the adaptor function, like so:\n * \n *   `var d3cola = cola.d3adaptor(d3);`\n * \n * Internally, it will figure out if d3 is version 3 or 4 from the version tag and set up the right event forwarding. Defaults to version 3 if the d3 object is not passed.\n * - uses the d3 event system to dispatch layout events such as:\n *   o \"start\" (start layout process)\n *   o \"tick\" (after each layout iteration)\n *   o \"end\" (layout converged and complete).\n * - uses the d3 timer to queue layout iterations.\n * - sets up d3.behavior.drag to drag nodes\n *   o use `node.call(<the returned instance of Layout>.drag)` to make nodes draggable\n * returns an instance of the cola.Layout itself with which the user\n * can interact directly.\n */\nexport function d3adaptor(d3Context?: D3Context | D3v3Context): Layout & ID3StyleLayoutAdaptor {\n    if (!d3Context || isD3V3(d3Context)) {\n        return new D3StyleLayoutAdaptor(d3Context);\n    }\n    return new D3v4StyleLayoutAdaptor(d3Context);\n}\n\nfunction isD3V3(d3Context: D3Context | D3v3Context): d3Context is D3v3Context {\n    const v3exp = /^3\\./;\n    return (<any>d3Context).version && (<any>d3Context).version.match(v3exp) !== null;\n}\n","import {Node, Link, Layout} from './layout'\nimport {GridRouter} from './gridrouter'\nimport {Point} from './geom'\n\n/**\n * @property nudgeGap spacing between parallel edge segments\n * @property margin space around nodes\n * @property groupMargin space around groups\n */\nexport function gridify(pgLayout, nudgeGap: number, margin: number, groupMargin: number) {\n    pgLayout.cola.start(0, 0, 0, 10, false);\n    let gridrouter = route(pgLayout.cola.nodes(), pgLayout.cola.groups(), margin, groupMargin);\n    return gridrouter.routeEdges<any>(pgLayout.powerGraph.powerEdges, nudgeGap, e=> e.source.routerNode.id, e=> e.target.routerNode.id);\n}\n\nfunction route(nodes, groups, margin: number, groupMargin: number) {\n    nodes.forEach(d => {\n        d.routerNode = <any>{\n            name: d.name,\n            bounds: d.bounds.inflate(-margin)\n        };\n    });\n    groups.forEach(d => {\n        d.routerNode = <any>{\n            bounds: d.bounds.inflate(-groupMargin),\n            children: (typeof d.groups !== 'undefined' ? d.groups.map(c=> nodes.length + c.id) : [])\n                .concat(typeof d.leaves !== 'undefined' ? d.leaves.map(c=> c.index) : [])\n        };\n    });\n    let gridRouterNodes = nodes.concat(groups).map((d, i) => {\n        d.routerNode.id = i;\n        return d.routerNode;\n    });\n    return new GridRouter(gridRouterNodes, {\n        getChildren: (v: any) => v.children,\n        getBounds: v => v.bounds\n    }, margin - groupMargin);\n}\n\nexport function powerGraphGridLayout(\n    graph: { nodes: Node[], links: Link<Node>[] },\n    size: number[],\n    grouppadding: number)\n{\n    // compute power graph\n    var powerGraph;\n    graph.nodes.forEach((v,i) => (<any>v).index = i);\n    new Layout()\n        .avoidOverlaps(false)\n        .nodes(graph.nodes)\n        .links(graph.links)\n        .powerGraphGroups(function (d) {\n            powerGraph = d;\n            powerGraph.groups.forEach(v=> v.padding = grouppadding);\n        });\n\n    // construct a flat graph with dummy nodes for the groups and edges connecting group dummy nodes to their children\n    // power edges attached to groups are replaced with edges connected to the corresponding group dummy node\n    var n = graph.nodes.length;\n    var edges = [];\n    var vs = graph.nodes.slice(0);\n    vs.forEach((v, i) => (<any>v).index = i);\n    powerGraph.groups.forEach(g => {\n        var sourceInd = g.index = g.id + n;\n        vs.push(g);\n        if (typeof g.leaves !== 'undefined')\n            g.leaves.forEach(v => edges.push({ source: sourceInd, target: v.index }));\n        if (typeof g.groups !== 'undefined')\n            g.groups.forEach(gg => edges.push({ source: sourceInd, target: gg.id + n }));\n    });\n    powerGraph.powerEdges.forEach(e=> {\n        edges.push({ source: e.source.index, target: e.target.index });\n    });\n\n    // layout the flat graph with dummy nodes and edges\n    new Layout()\n        .size(size)\n        .nodes(vs)\n        .links(edges)\n        .avoidOverlaps(false)\n        .linkDistance(30)\n        .symmetricDiffLinkLengths(5)\n        .convergenceThreshold(1e-4)\n        .start(100, 0, 0, 0, false);\n\n    // final layout taking node positions from above as starting positions\n    // subject to group containment constraints\n    // and then gridifying the layout\n    return {\n        cola:\n            new Layout()\n            .convergenceThreshold(1e-3)\n            .size(size)\n            .avoidOverlaps(true)\n            .nodes(graph.nodes)\n            .links(graph.links)\n        //.flowLayout('y', 30)\n            .groupCompactness(1e-4)\n            .linkDistance(30)\n            .symmetricDiffLinkLengths(5)\n            .powerGraphGroups(function (d) {\n                powerGraph = d;\n                powerGraph.groups.forEach(function (v) {\n                    v.padding = grouppadding\n                });\n            }).start(50, 0, 100, 0, false),\n        powerGraph: powerGraph\n    };\n}\n"],"names":["PowerEdge","source","target","type","Configuration","n","edges","linkAccessor","rootGroup","modules","Array","roots","initModulesFromGroup","push","ModuleSet","i","add","this","Module","R","length","forEach","e","s","_this","getSourceIndex","t","getTargetIndex","getType","outgoing","incoming","group","moduleSet","leaves","node","module","id","groups","j","child","definition","prop","hasOwnProperty","LinkSets","merge","a","b","k","inInt","intersection","outInt","children","m","update","o","forAll","ms","linktype","nls","remove","count","rootMerges","rs","merges","ctr","i_","nEdges","greedyMerge","sort","getGroupHierarchy","retargetedEdges","toGroups","isLeaf","g","gid","isIsland","isPredefined","allEdges","_this2","es","getEdges","edgetype","_this3","Object","keys","table","other","result","v","intersectionCount","contains","f","mid","vs","forAllModules","sets","Number","lt","getGroups","nodes","links","la","c","powerEdges","end","unionCount","u","computeLinkLengths","w","neighbours","addNeighbours","getNeighbours","l","setLength","symmetricDiffLinkLengths","Math","sqrt","jaccardLinkLengths","min","generateDirectedEdgeConstraints","axis","components","stronglyConnectedComponents","constraints","ui","vi","left","right","gap","getMinSeparation","numVertices","index","stack","strongConnect","lowlink","onStack","out","component","pop","map","Locks","x","locks","clear","isEmpty","apply","Descent","D","G","wasm","PseudoRandom","xn","Float32Array","setupWasm","d","ia","ib","xtmp","minD","MAX_VALUE","computeDerivatives","packed","packedX","set","outX","compute_2d","ctxPtr","slice","subarray","Error","compute_3d","p","apply_lock_2d","apply_lock_3d","allD","allG","dn","gn","Infinity","create_derivative_computer_ctx_2d","create_derivative_computer_ctx_3d","createSquareMatrix","M","offsetDir","random","getNextBetween","dotProd","rightMultiply","r","computeStepSize","compute_step_size_2d","compute_step_size_3d","reduceStress","alpha","thisG","takeDescentStep","computeStress","copy","stepAndProject","x0","stepSize","project","mApply","matrixApply","computeNextPosition","run","iterations","stress","converged","rungeKutta","abs","threshold","disp","_this4","nMinus1","dx","isFinite","rl","memory","get_memory","memoryView","buffer","gOffset","get_g_2d","get_g_3d","fill","_","_this5","newG","_this6","Gn","set_G_2d","set_G_3d","DOffset","get_D_2d","get_D_3d","_this7","seed","getNext","range","max","PositionStats","scale","addVariable","ai","wi","weight","AB","offset","AD","desiredPosition","A2","getPosn","Constraint","equality","slack","unsatisfiable","position","Variable","dfdv","block","ps","posn","visitNeighbours","prev","ff","next","active","cOut","cIn","Block","vars","updateWeightedPosition","compute_lm","postAction","_dfdv","lm","populateSplitBlock","traverse","visit","acc","findMinLM","findMinLMBetween","lv","rv","findPath","to","endFound","isActiveDirectedPathBetween","split","createSplitBlock","startVar","splitBetween","vl","vr","bs","constraint","lb","rb","mergeAcross","dist","cost","sum","Blocks","list","blockInd","insert","last","swapBlock","updateBlockPositions","inactive","Solver","LAGRANGIAN_TOLERANCE","nb","cs","setStartingPositions","setDesiredPositions","mostViolated","minSlack","deletePoint","ZERO_UPPERBOUND","satisfy","solve","lastcost","TreeBase","data","res","_root","iter","iterator","_comparator","_cursor","_ancestors","get_child","size","find","lowerBound","_bound","upperBound","cmp","Iterator","each","cb","it","reach","cur","tree","_tree","root","_minNode","save","_maxNode","start","Node","red","dir","set_child","val","RBTree","comparator","ret","head","undefined","gp","ggp","is_red","dir2","single_rotate","double_rotate","found","sr","sibling","gpc","computeGroupBounds","bounds","reduce","union","Rectangle","empty","inflate","padding","X","y","Y","POSITIVE_INFINITY","NEGATIVE_INFINITY","cx","cy","overlapX","ux","vx","overlapY","uy","vy","setXCentre","setYCentre","dy","width","height","lineIntersections","x1","y1","x2","y2","sides","intersections","lineIntersection","rayIntersection","ints","vertices","x3","y3","x4","y4","dx12","dx34","dy12","dy34","denominator","dx31","dy31","pad","makeEdgeBetween","ah","si","ti","al","sourceIntersection","targetIntersection","arrowStart","makeEdgeTo","pos","makeRBTree","Event","isOpen","compareEvents","xRect","getCentre","getOpen","getClose","getSize","makeRect","open","close","center","findNeighbours","scanline","forward","reverse","findIter","uovervX","yRect","generateGroupConstraints","minSep","isContained","ln","childConstraints","ccs","concat","minVar","maxVar","variable","generateConstraints","gapAdjustment","rect","N","console","assert","events","makeConstraint","sep","mkcon","generateXConstraints","generateYConstraints","generateXGroupConstraints","generateYGroupConstraints","IndexedVariable","Projection","avoidOverlaps","variables","createConstraints","w2","h2","stiffness","createSeparation","makeFeasible","dim","offsets","nextPos","createAlignment","xConstraints","yConstraints","isSep","filter","setupVariablesAndBounds","y0","desired","getDesired","fixed","fixedWeight","h","ix","iy","xProject","px","xmin","xmax","p2","yProject","py","ymin","ymax","projectFunctions","updateNodeBounds","updateGroupBounds","starting","solver","PairingHeap","elem","subheaps","toString","selector","str","needComma","subheap","isHeap","lessThan","every","obj","heap2","removeMin","mergePairs","firstPair","remaining","decreaseKey","newValue","setHeapNode","newHeap","pairingNode","PriorityQueue","top","arg","reduceKey","heapNode","newKey","Neighbour","distance","QueueEntry","Calculator","getLength","DistanceMatrix","dijkstraNeighbours","DistancesFromNode","PathFromNodeToNode","PathFromNodeToNodeWithPrevCost","prevCost","q","qu","visitedFrom","neighbour","viduid","cc","path","dest","Point","LineSegment","PolyPoint","isLeft","P0","P1","P2","above","vj","below","Rtangent_PointPolyC","P","V","dnC","floor","Ltangent_PointPolyC","tangent_PolyPolyC","W","t1","t2","cmp1","cmp2","ix1","ix2","done","RLtangent_PolyPolyC","BiTangent","BiTangents","TVGPoint","VisibilityVertex","polyid","polyvertid","vv","VisibilityEdge","TangentVisibilityGraph","g0","E","Pi","Pj","tangents","addEdgeIfVisible","i1","i2","intersectsPolys","addPoint","Vclosed","poly","rtan","ltan","intersects","int","bt","v1","v2","v3","w1","w3","v1v2w2","v2w1w2","v2w2w3","w1w2v2","w2v1v2","w2v2v3","ll","rr","lr","isAnyPInQ","isPointInsidePoly","packingOptions","applyPacking","graphs","node_size","desired_ratio","centerGraph","svg_width","svg_height","real_width","real_height","min_width","global_bottom","line","step","max_width","put_rect","parent","space_left","bottom","graph","min_x","min_y","max_x","max_y","array","calculate_bb","curr_best_f","curr_best","get_entire_width","iterationCounter","f_x1","f_x2","flag","df","put_nodes_to_right_positions","separateGraphs","marks","ways","clusters","link","n1","n2","explore_node","is_new","adjacent","setWasm","wasmModule","WebAssembly","instantiate","__wbindgen_memory","inst","exports","heap","heap_next","cachegetFloat32Memory0","getFloat32Memory0","WASM_VECTOR_LEN","passArrayF32ToWasm0","malloc","ptr","cachegetInt32Memory0","getInt32Memory0","Int32Array","getArrayF32FromWasm0","len","idx","addHeapObject","node_count","ptr0","__wbindgen_malloc","len0","ptr1","ctx_ptr","retptr","__wbindgen_add_to_stack_pointer","r0","r1","__wbindgen_free","p_0","p_1","x_0_u","x_1_u","p_2","x_2_u","getObject","dropObject","ctx","new_G","EventType","WasmInst","getter","get","value","pending","Promise","resolve","then","validate","Uint8Array","getHasSIMDSupport","hasWasmSIMDSupport","window","location","href","includes","log","wasmSIMD","wasmNoSIMD_bg","wasmNoSIMD","getDerivativeComputerWasm","wasmInstPromise","isGroup","Layout","setLinkLength","_linkType","on","listener","event","trigger","kick","tick","_alpha","_threshold","_running","_lastStress","_nodes","_descent","s1","updateNodePositions","_links","_groups","_rootGroup","gi","powerGraphGroups","powergraph","arguments","_avoidOverlaps","handleDisconnected","_handleDisconnected","flowLayout","minSeparation","_directedLinkConstraints","_constraints","distanceMatrix","_distanceMatrix","_canvasSize","defaultNodeSize","_defaultNodeSize","groupCompactness","_groupCompactness","linkDistance","_linkDistance","_linkLengthCalculator","linkType","convergenceThreshold","getLinkLength","getLinkType","idealLength","initialUnconstrainedIterations","initialUserConstraintIterations","initialAllConstraintsIterations","gridSnapIterations","keepRunning","distances","ao","strength","idealDistance","addAttraction","curConstraints","wasmInst","initialLayout","separateOverlappingComponents","resume","gg","stop","prepareEdgeRouting","nodeMargin","_visibilityGraph","routeEdge","edge","draw","lineData","vg2","port1","port2","shortestPath","route","innerBounds","linkId","dragStart","storeOffset","dragOrigin","stopNode","origin","_dragGroupOffsetX","_dragGroupOffsetY","drag","dragEnd","mouseOver","mouseOut","LayoutAdaptor","options","dragstart","dragend","eventType","D3StyleLayoutAdaptor","d3Context","self","d3","dispatch","d3layout","behavior","call","d3event","timer","D3v4StyleLayoutAdaptor","subject","_Layout","NodeWrapper","leaf","Vert","LongestCommonSubsequence","mf","findMatch","tr","mr","reversed","match","getSequence","GridRouter","originalnodes","accessor","groupPadding","getBounds","getChildren","cols","getGridLines","rows","ports","backToFront","getDepth","colMids","midPoints","rowMids","rowx","rowX","coly","colY","hlines","vlines","lines","verts","li","intersect","isHoriz","delta","avg","columns","ls","overlapping","toUpperCase","col","splice","indexOf","depth","mids","findLineage","lineage","findAncestorPathBetween","aa","ba","commonAncestor","lineages","siblingObstacles","lineageLookup","obstacles","getSegmentSets","routes","vsegments","ei","edgeid","vsegmentsets","segmentset","segments","nudgeSegs","leftOf","e1","e2","lind","rind","nudgeSegments","ss","openCount","routeEdges","nudgeGap","routePaths","order","orderEdges","makeSegments","unreverseEdges","segment","angleBetween2Lines","line1","line2","angle1","atan2","angle2","diff","PI","getOrder","pairs","edgeOrder","lcs","copyPoint","isStraight","obstacleLookup","passableEdges","pathPoints","getRoutePath","cornerradius","arrowwidth","arrowheight","arrowcorner1","arrowcorner2","routepath","arrowpath","angle","arrowtip","Link3D","actualLength","Layout3D","idealLinkLength","dims","z","linkLength","LinkAccessor","useJaccardLinkLengths","descent","S","minmax","H","maxmin","maxmax","bot","version","isD3V3","pgLayout","margin","groupMargin","cola","routerNode","name","gridRouterNodes","powerGraph","grouppadding","sourceInd","spans","desiredCenter","leftMost","rightMost","leftMostSize","rightMostSize","vLower","vUpper","newCenters"],"mappings":"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"}