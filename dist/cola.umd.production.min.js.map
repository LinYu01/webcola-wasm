{"version":3,"file":"cola.umd.production.min.js","sources":["../src/powergraph.ts","../src/linklengths.ts","../src/descent.ts","../src/vpsc.ts","../src/rbtree.ts","../src/rectangle.ts","../src/pqueue.ts","../src/shortestpaths.ts","../src/geom.ts","../src/handledisconnected.ts","../src/wasm/build/simd/derivative_computer_bg.js","../src/wasm/build/no_simd/derivative_computer_bg.js","../src/layout.ts","../src/wasmEngine.ts","../src/adaptor.ts","../src/d3v3adaptor.ts","../src/d3v4adaptor.ts","../src/gridrouter.ts","../src/layout3d.ts","../src/d3adaptor.ts","../src/batch.ts"],"sourcesContent":["import {LinkAccessor} from './linklengths'\n\nexport interface LinkTypeAccessor<Link> extends LinkAccessor<Link> {\n        // return a unique identifier for the type of the link\n        getType(l: Link): number;\n    }\n\n    export class PowerEdge {\n        constructor(\n            public source: any,\n            public target: any,\n            public type: number) { }\n    }\n\n    export class Configuration<Link> {\n        // canonical list of modules.\n        // Initialized to a module for each leaf node, such that the ids and indexes of the module in the array match the indexes of the nodes in links\n        // Modules created through merges are appended to the end of this.\n        modules: Module[];\n        // top level modules and candidates for merges\n        roots: ModuleSet[];\n        // remaining edge count\n        R: number;\n        constructor(n: number, edges: Link[], private linkAccessor: LinkTypeAccessor<Link>, rootGroup?: any[]) {\n            this.modules = new Array(n);\n            this.roots = [];\n            if (rootGroup) {\n                this.initModulesFromGroup(rootGroup);\n            } else {\n                this.roots.push(new ModuleSet());\n                for (var i = 0; i < n; ++i)\n                    this.roots[0].add(this.modules[i] = new Module(i));\n            }\n            this.R = edges.length;\n            edges.forEach(e => {\n                var s = this.modules[linkAccessor.getSourceIndex(e)],\n                    t = this.modules[linkAccessor.getTargetIndex(e)],\n                    type = linkAccessor.getType(e);\n                s.outgoing.add(type, t);\n                t.incoming.add(type, s);\n            });\n        }\n\n        private initModulesFromGroup(group): ModuleSet {\n            var moduleSet = new ModuleSet();\n            this.roots.push(moduleSet);\n            for (var i = 0; i < group.leaves.length; ++i) {\n                var node = group.leaves[i];\n                var module = new Module(node.id);\n                this.modules[node.id] = module;\n                moduleSet.add(module);\n            }\n            if (group.groups) {\n                for (var j = 0; j < group.groups.length; ++j) {\n                    var child = group.groups[j];\n                    // Propagate group properties (like padding, stiffness, ...) as module definition so that the generated power graph group will inherit it\n                    var definition = {};\n                    for (var prop in child)\n                        if (prop !== \"leaves\" && prop !== \"groups\" && child.hasOwnProperty(prop))\n                            definition[prop] = child[prop];\n                    // Use negative module id to avoid clashes between predefined and generated modules\n                    moduleSet.add(new Module(-1-j, new LinkSets(), new LinkSets(), this.initModulesFromGroup(child), definition));\n                }\n            }\n            return moduleSet;\n         }\n\n        // merge modules a and b keeping track of their power edges and removing the from roots\n        merge(a: Module, b: Module, k: number = 0): Module {\n            var inInt = a.incoming.intersection(b.incoming),\n                outInt = a.outgoing.intersection(b.outgoing);\n            var children = new ModuleSet();\n            children.add(a);\n            children.add(b);\n            var m = new Module(this.modules.length, outInt, inInt, children);\n            this.modules.push(m);\n            var update = (s: LinkSets, i: string, o: string) => {\n                s.forAll((ms, linktype) => {\n                    ms.forAll(n => {\n                        var nls = <LinkSets>n[i];\n                        nls.add(linktype, m);\n                        nls.remove(linktype, a);\n                        nls.remove(linktype, b);\n                        (<LinkSets>a[o]).remove(linktype, n);\n                        (<LinkSets>b[o]).remove(linktype, n);\n                    });\n                });\n            };\n            update(outInt, \"incoming\", \"outgoing\");\n            update(inInt, \"outgoing\", \"incoming\");\n            this.R -= inInt.count() + outInt.count();\n            this.roots[k].remove(a);\n            this.roots[k].remove(b);\n            this.roots[k].add(m);\n            return m;\n        }\n\n        private rootMerges(k: number = 0): {\n            id: number;\n            nEdges: number;\n            a: Module;\n            b: Module;\n        }[] {\n            var rs = this.roots[k].modules();\n            var n = rs.length;\n            var merges = new Array(n * (n - 1));\n            var ctr = 0;\n            for (var i = 0, i_ = n - 1; i < i_; ++i) {\n                for (var j = i+1; j < n; ++j) {\n                    var a = rs[i], b = rs[j];\n                    merges[ctr] = { id: ctr, nEdges: this.nEdges(a, b), a: a, b: b };\n                    ctr++;\n                }\n            }\n            return merges;\n        }\n\n        greedyMerge(): boolean {\n            for (var i = 0; i < this.roots.length; ++i) {\n                // Handle single nested module case\n                if (this.roots[i].modules().length < 2) continue;\n\n                // find the merge that allows for the most edges to be removed.  secondary ordering based on arbitrary id (for predictability)\n                var ms = this.rootMerges(i).sort((a, b) => a.nEdges == b.nEdges ? a.id - b.id : a.nEdges - b.nEdges);\n                var m = ms[0];\n                if (m.nEdges >= this.R) continue;\n                this.merge(m.a, m.b, i);\n                return true;\n            }\n        }\n\n        private nEdges(a: Module, b: Module): number {\n            var inInt = a.incoming.intersection(b.incoming),\n                outInt = a.outgoing.intersection(b.outgoing);\n            return this.R - inInt.count() - outInt.count();\n        }\n\n        getGroupHierarchy(retargetedEdges: PowerEdge[]): any[]{\n            var groups = [];\n            var root = {};\n            toGroups(this.roots[0], root, groups);\n            var es = this.allEdges();\n            es.forEach(e => {\n                var a = this.modules[e.source];\n                var b = this.modules[e.target];\n                retargetedEdges.push(new PowerEdge(\n                    typeof a.gid === \"undefined\" ? e.source : groups[a.gid],\n                    typeof b.gid === \"undefined\" ? e.target : groups[b.gid],\n                    e.type\n                ));\n            });\n            return groups;\n        }\n\n        allEdges(): PowerEdge[] {\n            var es = [];\n            Configuration.getEdges(this.roots[0], es);\n            return es;\n        }\n\n        static getEdges(modules: ModuleSet, es: PowerEdge[]) {\n            modules.forAll(m => {\n                m.getEdges(es);\n                Configuration.getEdges(m.children, es);\n            });\n        }\n    }\n\n    function toGroups(modules: ModuleSet, group, groups) {\n        modules.forAll(m => {\n            if (m.isLeaf()) {\n                if (!group.leaves) group.leaves = [];\n                group.leaves.push(m.id);\n            } else {\n                var g = group;\n                m.gid = groups.length;\n                if (!m.isIsland() || m.isPredefined()) {\n                    g = { id: m.gid };\n                    if (m.isPredefined())\n                        // Apply original group properties\n                        for (var prop in m.definition)\n                            g[prop] = m.definition[prop];\n                    if (!group.groups) group.groups = [];\n                    group.groups.push(m.gid);\n                    groups.push(g);\n                }\n                toGroups(m.children, g, groups);\n            }\n        });\n    }\n\n    export class Module {\n        gid: number;\n\n        constructor(\n            public id: number,\n            public outgoing: LinkSets = new LinkSets(),\n            public incoming: LinkSets = new LinkSets(),\n            public children: ModuleSet = new ModuleSet(),\n            public definition?: any) { }\n\n        getEdges(es: PowerEdge[]) {\n            this.outgoing.forAll((ms, edgetype) => {\n                ms.forAll(target => {\n                    es.push(new PowerEdge(this.id, target.id, edgetype));\n                });\n            });\n        }\n\n        isLeaf() {\n            return this.children.count() === 0;\n        }\n\n        isIsland() {\n            return this.outgoing.count() === 0 && this.incoming.count() === 0;\n        }\n\n        isPredefined(): boolean {\n            return typeof this.definition !== \"undefined\";\n        }\n    }\n\n    function intersection(m: any, n: any): any {\n        var i = {};\n        for (var v in m) if (v in n) i[v] = m[v];\n        return i;\n    }\n\n    export class ModuleSet {\n        table: any = {};\n        count() {\n            return Object.keys(this.table).length;\n        }\n        intersection(other: ModuleSet): ModuleSet {\n            var result = new ModuleSet();\n            result.table = intersection(this.table, other.table);\n            return result;\n        }\n        intersectionCount(other: ModuleSet): number {\n            return this.intersection(other).count();\n        }\n        contains(id: number): boolean {\n            return id in this.table;\n        }\n        add(m: Module): void {\n            this.table[m.id] = m;\n        }\n        remove(m: Module): void {\n            delete this.table[m.id];\n        }\n        forAll(f: (m: Module) => void) {\n            for (var mid in this.table) {\n                f(this.table[mid]);\n            }\n        }\n        modules(): Module[] {\n            var vs = [];\n            this.forAll(m => {\n                if (!m.isPredefined())\n                    vs.push(m);\n            });\n            return vs;\n        }\n    }\n\n    export class LinkSets {\n        sets: any = {};\n        n: number = 0;\n        count(): number {\n            return this.n;\n        }\n        contains(id: number) {\n            var result = false;\n            this.forAllModules(m => {\n                if (!result && m.id == id) {\n                    result = true;\n                }\n            });\n            return result;\n        }\n        add(linktype: number, m: Module) {\n            var s: ModuleSet = linktype in this.sets ? this.sets[linktype] : this.sets[linktype] = new ModuleSet();\n            s.add(m);\n            ++this.n;\n        }\n        remove(linktype: number, m: Module) {\n            var ms = <ModuleSet>this.sets[linktype];\n            ms.remove(m);\n            if (ms.count() === 0) {\n                delete this.sets[linktype];\n            }\n            --this.n;\n        }\n        forAll(f: (ms: ModuleSet, linktype: number) => void) {\n            for (var linktype in this.sets) {\n                f(<ModuleSet>this.sets[linktype], Number(linktype));\n            }\n        }\n        forAllModules(f: (m: Module) => void) {\n            this.forAll((ms, lt) => ms.forAll(f));\n        }\n        intersection(other: LinkSets): LinkSets {\n            var result: LinkSets = new LinkSets();\n            this.forAll((ms, lt) => {\n                if (lt in other.sets) {\n                    var i = ms.intersection(other.sets[lt]),\n                        n = i.count();\n                    if (n > 0) {\n                        result.sets[lt] = i;\n                        result.n += n;\n                    }\n                }\n            });\n            return result;\n        }\n    }\n\n    function intersectionCount(m: any, n: any): number {\n        return Object.keys(intersection(m, n)).length\n    }\n\n    export function getGroups<Link>(nodes: any[], links: Link[], la: LinkTypeAccessor<Link>, rootGroup?: any[]): { groups: any[]; powerEdges: PowerEdge[] } {\n        var n = nodes.length,\n            c = new Configuration(n, links, la, rootGroup);\n        while (c.greedyMerge());\n        var powerEdges: PowerEdge[] = [];\n        var g = c.getGroupHierarchy(powerEdges);\n        powerEdges.forEach(function (e) {\n            var f = (end) => {\n                var g = e[end];\n                if (typeof g == \"number\") e[end] = nodes[g];\n            };\n            f(\"source\");\n            f(\"target\");\n        });\n        return { groups: g, powerEdges: powerEdges };\n    }\n","    export interface LinkAccessor<Link> {\n        getSourceIndex(l: Link): number;\n        getTargetIndex(l: Link): number;\n    }\n\n    export interface LinkLengthAccessor<Link> extends LinkAccessor<Link> {\n        setLength(l: Link, value: number): void;\n    }\n\n    // compute the size of the union of two sets a and b\n    function unionCount(a: any, b: any): number {\n        var u = {};\n        for (var i in a) u[i] = {};\n        for (var i in b) u[i] = {};\n        return Object.keys(u).length;\n    }\n\n    // compute the size of the intersection of two sets a and b\n    function intersectionCount(a: number[], b: number[]): number {\n        var n = 0;\n        for (var i in a) if (typeof b[i] !== 'undefined') ++n;\n        return n;\n    }\n\n    function getNeighbours<Link>(links: Link[], la: LinkAccessor<Link>): any {\n        var neighbours = {};\n        var addNeighbours = (u, v) => {\n            if (typeof neighbours[u] === 'undefined')\n                neighbours[u] = {};\n            neighbours[u][v] = {};\n        };\n        links.forEach(e => {\n            var u = la.getSourceIndex(e), v = la.getTargetIndex(e);\n            addNeighbours(u, v);\n            addNeighbours(v, u);\n        });\n        return neighbours;\n    }\n\n    // modify the lengths of the specified links by the result of function f weighted by w\n    function computeLinkLengths<Link>(links: Link[], w: number, f: (a: any, b: any) => number, la: LinkLengthAccessor<Link>) {\n        var neighbours = getNeighbours(links, la);\n        links.forEach(l => {\n            var a = neighbours[la.getSourceIndex(l)];\n            var b = neighbours[la.getTargetIndex(l)];\n            la.setLength(l, 1 + w * f(a, b));\n        });\n    }\n\n    /** modify the specified link lengths based on the symmetric difference of their neighbours\n     * @class symmetricDiffLinkLengths\n     */\n    export function symmetricDiffLinkLengths<Link>(links: Link[], la: LinkLengthAccessor<Link>, w: number = 1) {\n        computeLinkLengths(links, w, (a, b) => Math.sqrt(unionCount(a, b) - intersectionCount(a, b)), la);\n    }\n\n    /** modify the specified links lengths based on the jaccard difference between their neighbours\n     * @class jaccardLinkLengths\n     */\n    export function jaccardLinkLengths<Link>(links: Link[], la: LinkLengthAccessor<Link>, w: number = 1) {\n        computeLinkLengths(links, w, (a, b) =>\n            Math.min(Object.keys(a).length, Object.keys(b).length) < 1.1 ? 0 : intersectionCount(a, b) / unionCount(a, b)\n            , la);\n    }\n\n    export interface IConstraint {\n        left: number;\n        right: number;\n        gap: number;\n    }\n\n    export interface DirectedEdgeConstraints {\n        axis: string;\n        gap: number;\n    }\n\n    export interface LinkSepAccessor<Link> extends LinkAccessor<Link> {\n        getMinSeparation(l: Link): number;\n    }\n\n    /** generate separation constraints for all edges unless both their source and sink are in the same strongly connected component\n     * @class generateDirectedEdgeConstraints\n     */\n    export function generateDirectedEdgeConstraints<Link>(n: number, links: Link[], axis: string,\n        la: LinkSepAccessor<Link>): IConstraint[]\n    {\n        var components = stronglyConnectedComponents(n, links, la);\n        var nodes = {};\n        components.forEach((c,i) =>\n            c.forEach(v => nodes[v] = i)\n        );\n        var constraints: any[] = [];\n        links.forEach(l => {\n            var ui = la.getSourceIndex(l), vi = la.getTargetIndex(l),\n                u = nodes[ui], v = nodes[vi];\n            if (u !== v) {\n                constraints.push({\n                    axis: axis,\n                    left: ui,\n                    right: vi,\n                    gap: la.getMinSeparation(l)\n                });\n            }\n        });\n        return constraints;\n    }\n\n    /**\n     * Tarjan's strongly connected components algorithm for directed graphs\n     * returns an array of arrays of node indicies in each of the strongly connected components.\n     * a vertex not in a SCC of two or more nodes is it's own SCC.\n     * adaptation of https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n     */\n    export function stronglyConnectedComponents<Link>(numVertices: number, edges: Link[], la: LinkAccessor<Link>): number[][]{\n        var nodes = [];\n        var index = 0;\n        var stack = [];\n        var components = [];\n        function strongConnect(v) {\n            // Set the depth index for v to the smallest unused index\n            v.index = v.lowlink = index++;\n            stack.push(v);\n            v.onStack = true;\n\n            // Consider successors of v\n            for (var w of v.out) {\n                if (typeof w.index === 'undefined') {\n                    // Successor w has not yet been visited; recurse on it\n                    strongConnect(w);\n                    v.lowlink = Math.min(v.lowlink, w.lowlink);\n                } else if (w.onStack) {\n                    // Successor w is in stack S and hence in the current SCC\n                    v.lowlink = Math.min(v.lowlink, w.index);\n                }\n            }\n\n            // If v is a root node, pop the stack and generate an SCC\n            if (v.lowlink === v.index) {\n                // start a new strongly connected component\n                var component = [];\n                while (stack.length) {\n                    w = stack.pop();\n                    w.onStack = false;\n                    //add w to current strongly connected component\n                    component.push(w);\n                    if (w === v) break;\n                }\n                // output the current strongly connected component\n                components.push(component.map(v => v.id));\n            }\n        }\n        for (var i = 0; i < numVertices; i++) {\n            nodes.push({id: i, out: []});\n        }\n        for (var e of edges) {\n            let v = nodes[la.getSourceIndex(e)],\n                w = nodes[la.getTargetIndex(e)];\n            v.out.push(w);\n        }\n        for (var v of nodes) if (typeof v.index === 'undefined') strongConnect(v);\n        return components;\n    }\n","import type { DerivativeComputerWasmInst } from \"wasmEngine\";\n\n    /**\n     * Descent respects a collection of locks over nodes that should not move\n     * @class Locks\n     */\n    export class Locks {\n        locks: { [key:number]:number[]} = {};\n        /**\n         * add a lock on the node at index id\n         * @method add\n         * @param id index of node to be locked\n         * @param x required position for node\n         */\n        add(id: number, x: number[]) {\n/* DEBUG\n            if (isNaN(x[0]) || isNaN(x[1])) debugger;\nDEBUG */\n            this.locks[id] = x;\n        }\n        /**\n         * @method clear clear all locks\n         */\n        clear() {\n            this.locks = {};\n        }\n        /**\n         * @isEmpty\n         * @returns false if no locks exist\n         */\n        isEmpty(): boolean {\n            for (var l in this.locks) return false;\n            return true;\n        }\n        /**\n         * perform an operation on each lock\n         * @apply\n         */\n        apply(f: (id: number, x: number[]) => void) {\n            for (var l in this.locks) {\n                f(Number(l), this.locks[l]);\n            }\n        }\n    }\n\n    const BYTES_PER_F32 = 32 / 8;\n\n    /**\n     * Uses a gradient descent approach to reduce a stress or p-stress goal function over a graph with specified ideal edge lengths or a square matrix of dissimilarities.\n     * The standard stress function over a graph nodes with position vectors x,y,z is (mathematica input):\n     *   stress[x_,y_,z_,D_,w_]:=Sum[w[[i,j]] (length[x[[i]],y[[i]],z[[i]],x[[j]],y[[j]],z[[j]]]-d[[i,j]])^2,{i,Length[x]-1},{j,i+1,Length[x]}]\n     * where: D is a square matrix of ideal separations between nodes, w is matrix of weights for those separations\n     *        length[x1_, y1_, z1_, x2_, y2_, z2_] = Sqrt[(x1 - x2)^2 + (y1 - y2)^2 + (z1 - z2)^2]\n     * below, we use wij = 1/(Dij^2)\n     *\n     * @class Descent\n     */\n    export class Descent {\n        private wasm: DerivativeComputerWasmInst;\n\n        private ctxPtr: number;\n\n        public threshold: number = 0.0001;\n        /** gradient vector\n         * @property g {Float32Array[]}\n         */\n        public get g(): Float32Array[] {\n            const memory: WebAssembly.Memory = this.wasm.get_memory();\n            const memoryView = new Float32Array(memory.buffer);\n\n            const gPtr = this.k === 2 ? this.wasm.get_g_2d(this.ctxPtr) : this.wasm.get_g_3d(this.ctxPtr);\n            const gOffset = gPtr / BYTES_PER_F32;\n            return new Array(this.k)\n                .fill(null)\n                .map((_, i) => memoryView.subarray(gOffset + i * this.n, gOffset + i * this.n + this.n));\n        }\n        public set G(newG: Float32Array[] | null)  {\n            const allG = (() => {\n                if (newG) {\n                    const allG = new Float32Array(this.n * this.n);\n                    newG.forEach((Gn, i) => allG.set(Gn, i * this.n));\n                    return allG;\n                } else {\n                    return new Float32Array();\n                }\n            })();\n\n            if (this.k === 2) {\n                this.wasm.set_G_2d(this.ctxPtr, allG);\n            } else if (this.k === 3) {\n                this.wasm.set_G_3d(this.ctxPtr, allG);\n            } else {\n                throw new Error('Invalid dimensionality');\n            }\n        }\n       /** positions vector\n         * @property x {number[][]}\n         */\n        public x: Float32Array[];\n        /**\n         * @property k {number} dimensionality\n         */\n        public k: number;\n        /**\n         * number of data-points / nodes / size of vectors/matrices\n         * @property n {number}\n         */\n        public n: number;\n        /**\n         * matrix of desired distances between pairs of nodes\n         */\n         public get D(): Float32Array[] {\n            const memory: WebAssembly.Memory = this.wasm.get_memory();\n            const memoryView = new Float32Array(memory.buffer);\n\n            const DPtr = this.k === 2 ? this.wasm.get_D_2d(this.ctxPtr) : this.wasm.get_D_3d(this.ctxPtr);\n            const DOffset = DPtr / BYTES_PER_F32;\n            return new Array(this.n)\n                .fill(null)\n                .map((_, i) => memoryView.subarray(DOffset + i * this.n, DOffset + i * this.n + this.n));\n        }\n\n        public computeDerivatives(x: Float32Array[]) {\n            if (this.k === 2) {\n                const packedX = (() => {\n                    const packed = new Float32Array(x[0].length * this.k);\n                    x.forEach((xn, i) => packed.set(xn, i * this.n));\n                    return packed;\n                })();\n                const outX = this.wasm.compute_2d(this.ctxPtr, packedX);\n\n                if (x) {\n                    x.forEach((xn, i) => {\n                        const slice = outX.subarray(i * this.n, i * this.n + this.n);\n                        xn.set(slice);\n                    })\n                }\n            } else if (this.k === 3) {\n                const packedX = (() => {\n                    const packed = new Float32Array(x[0].length * this.k);\n                    x.forEach((xn, i) => packed.set(xn, i * this.n));\n                    return packed;\n                })();\n                const outX = this.wasm.compute_3d(this.ctxPtr, packedX);\n\n                if (x) {\n                    x.forEach((xn, i) => {\n                        const slice = outX.subarray(i * this.n, i * this.n + this.n);\n                        xn.set(slice);\n                    })\n                }\n            } else {\n                throw new Error('Invalid dimensionality');\n            }\n\n            if (!this.locks.isEmpty()) {\n                this.locks.apply((u, p) => {\n                    if (this.k === 2) {\n                        this.wasm.apply_lock_2d(this.ctxPtr, u, p[0], p[1], x[0][u], x[1][u]);\n                    } else if (this.k === 3) {\n                        this.wasm.apply_lock_3d(this.ctxPtr, u, p[0], p[1], p[2], x[0][u], x[1][u], x[2][u]);\n                    } else {\n                        throw new Error('Invalid dimensionality');\n                    }\n                });\n            }\n        }\n\n        public locks: Locks;\n\n        private static zeroDistance: number = 1e-10;\n        private minD: number;\n\n        // pool of arrays of size n used internally, allocated in constructor\n        private a: Float32Array[];\n        private b: Float32Array[];\n        private c: Float32Array[];\n        private d: Float32Array[];\n        private e: Float32Array[];\n        private ia: Float32Array[];\n        private ib: Float32Array[];\n        private xtmp: number[][];\n\n\n        // Parameters for grid snap stress.\n        // TODO: Make a pluggable \"StressTerm\" class instead of this\n        // mess.\n        public numGridSnapNodes: number = 0;\n        public snapGridSize: number = 100;\n        public snapStrength: number = 1000;\n        public scaleSnapByMaxH: boolean = false;\n\n        private random = new PseudoRandom();\n\n        public project: { (x0: Float32Array, y0: Float32Array, r: Float32Array): void }[] = null;\n\n        public cleanWasmMemory() {\n            if (this.ctxPtr) {\n                this.wasm.release_ctx_2d(this.ctxPtr);\n                this.ctxPtr = 0;\n            }\n        }\n\n        private setupWasm(D: number[][], G: number[][] | null = null) {\n            const allD = new Float32Array(this.n * this.n);\n            const allG = G ? new Float32Array(this.n * this.k) : new Float32Array(0);\n            D.forEach((dn, i) => {\n                allD.set(dn, i * this.n);\n            });\n            if (G) {\n                G.forEach((gn, i) => {\n                    allG.set(gn, i * this.n);\n                });\n            }\n\n            allD.forEach((d, i) => {\n                if (d === Infinity) {\n                    allD[i] = -10000000; // ideal distance\n                    allG[i] = 1000.; // weight\n                }\n            });\n\n            const createrFn = this.k === 2 ? this.wasm.create_derivative_computer_ctx_2d : this.wasm.create_derivative_computer_ctx_3d;\n            const ctxPtr = createrFn(this.n, allD, allG);\n            this.ctxPtr = ctxPtr;\n        }\n\n        /**\n         * @method constructor\n         * @param x {number[][]} initial coordinates for nodes\n         * @param D {number[][]} matrix of desired distances between pairs of nodes\n         * @param G {number[][]} [default=null] if specified, G is a matrix of weights for goal terms between pairs of nodes.\n         * If G[i][j] > 1 and the separation between nodes i and j is greater than their ideal distance, then there is no contribution for this pair to the goal\n         * If G[i][j] <= 1 then it is used as a weighting on the contribution of the variance between ideal and actual separation between i and j to the goal function\n         */\n        constructor(x: number[][], D: number[][], G: number[][] = null, wasm: DerivativeComputerWasmInst) {\n            this.wasm = wasm;\n            this.x = x.map(xn => new Float32Array(xn));\n            this.k = x.length; // dimensionality\n            var n = this.n = x[0].length; // number of nodes\n\n            // Set up Wasm context\n            this.setupWasm(D, G);\n\n            this.a = new Array(this.k);\n            this.b = new Array(this.k);\n            this.c = new Array(this.k);\n            this.d = new Array(this.k);\n            this.e = new Array(this.k);\n            this.ia = new Array(this.k);\n            this.ib = new Array(this.k);\n            this.xtmp = new Array(this.k);\n            this.locks = new Locks();\n            this.minD = Number.MAX_VALUE;\n            var i = n, j;\n            while (i--) {\n                j = n;\n                while (--j > i) {\n                    var d = D[i][j];\n                    if (d > 0 && d < this.minD) {\n                        this.minD = d;\n                    }\n                }\n            }\n            if (this.minD === Number.MAX_VALUE) this.minD = 1;\n            i = this.k;\n            while (i--) {\n                j = n;\n                this.a[i] = new Float32Array(n);\n                this.b[i] = new Float32Array(n);\n                this.c[i] = new Float32Array(n);\n                this.d[i] = new Float32Array(n);\n                this.e[i] = new Float32Array(n);\n                this.ia[i] = new Float32Array(n);\n                this.ib[i] = new Float32Array(n);\n                this.xtmp[i] = new Array(n);\n            }\n        }\n\n        public static createSquareMatrix(n: number, f: (i: number, j: number) => number): number[][] {\n            var M = new Array(n);\n            for (var i = 0; i < n; ++i) {\n                M[i] = new Array(n);\n                for (var j = 0; j < n; ++j) {\n                    M[i][j] = f(i, j);\n                }\n            }\n            return M;\n        }\n\n        private offsetDir(): number[] {\n            var u = new Array(this.k);\n            var l = 0;\n            for (var i = 0; i < this.k; ++i) {\n                var x = u[i] = this.random.getNextBetween(0.01, 1) - 0.5;\n                l += x * x;\n            }\n            l = Math.sqrt(l);\n            return u.map(x=> x *= this.minD / l);\n        }\n\n        private static dotProd(a: Float32Array, b: Float32Array): number {\n            var x = 0, i = a.length;\n            while (i--) x += a[i] * b[i];\n            return x;\n        }\n\n        // result r = matrix m * vector v\n        private static rightMultiply(m: Float32Array[], v: Float32Array, r: Float32Array) {\n            var i = m.length;\n            while (i--) r[i] = Descent.dotProd(m[i], v);\n        }\n\n        // computes the optimal step size to take in direction d using the\n        // derivative information in this.g and this.H\n        // returns the scalar multiplier to apply to d to get the optimal step\n        public computeStepSize(): number {\n            if (this.k === 2) {\n                return this.wasm.compute_step_size_2d(this.ctxPtr);\n            } else if (this.k === 3) {\n                return this.wasm.compute_step_size_3d(this.ctxPtr);\n            } else {\n                throw new Error('Invalid dimensionality');\n            }\n        }\n\n        public reduceStress(): number {\n            this.computeDerivatives(this.x);\n            var alpha = this.computeStepSize();\n            const thisG = this.g;\n            for (var i = 0; i < this.k; ++i) {\n                this.takeDescentStep(this.x[i], thisG[i], alpha);\n            }\n            return this.computeStress();\n        }\n\n        private static copy(a: Float32Array[], b: Float32Array[]): void {\n            var m = a.length, n = b[0].length;\n            for (var i = 0; i < m; ++i) {\n                for (var j = 0; j < n; ++j) {\n                    b[i][j] = a[i][j];\n                }\n            }\n        }\n\n        // takes a step of stepSize * d from x0, and then project against any constraints.\n        // result is returned in r.\n        // x0: starting positions\n        // r: result positions will be returned here\n        // d: unconstrained descent vector\n        // stepSize: amount to step along d\n        private stepAndProject(x0: Float32Array[], r: Float32Array[], d: Float32Array[], stepSize: number): void {\n            Descent.copy(x0, r);\n            this.takeDescentStep(r[0], d[0], stepSize);\n            if (this.project) this.project[0](x0[0], x0[1], r[0]);\n            this.takeDescentStep(r[1], d[1], stepSize);\n            if (this.project) this.project[1](r[0], x0[1], r[1]);\n\n            // todo: allow projection against constraints in higher dimensions\n            for (var i = 2; i < this.k; i++)\n                this.takeDescentStep(r[i], d[i], stepSize);\n\n            // the following makes locks extra sticky... but hides the result of the projection from the consumer\n            //if (!this.locks.isEmpty()) {\n            //    this.locks.apply((u, p) => {\n            //        for (var i = 0; i < this.k; i++) {\n            //            r[i][u] = p[i];\n            //        }\n            //    });\n            //}\n        }\n\n        private static mApply(m: number, n: number, f: (i: number, j: number) => any) {\n            var i = m; while (i-- > 0) {\n                var j = n; while (j-- > 0) f(i, j);\n            }\n        }\n        private matrixApply(f: (i: number, j: number) => any) {\n            Descent.mApply(this.k, this.n, f);\n        }\n\n        private computeNextPosition(x0: Float32Array[], r: Float32Array[]): void {\n            this.computeDerivatives(x0);\n            const alpha = this.computeStepSize();\n            this.stepAndProject(x0, r, this.g, alpha);\n/* DEBUG\n            for (var u: number = 0; u < this.n; ++u)\n                for (var i = 0; i < this.k; ++i)\n                    if (isNaN(r[i][u])) debugger;\nDEBUG */\n            if (this.project) {\n                // This functionality is not yet implemented with the Wasm port\n                throw new Error('Computing step with with `this.project` set is not yet implemented in Wasm port');\n                // this.matrixApply((i, j) => this.e[i][j] = x0[i][j] - r[i][j]);\n                // var beta = this.computeStepSize(this.e);\n                // beta = Math.max(0.2, Math.min(beta, 1));\n                // this.stepAndProject(x0, r, this.e, beta);\n            }\n        }\n\n        public run(iterations: number): number {\n            var stress = Number.MAX_VALUE, converged = false;\n            while (!converged && iterations-- > 0) {\n                var s = this.rungeKutta();\n                converged = Math.abs(stress / s - 1) < this.threshold;\n                stress = s;\n            }\n            return stress;\n        }\n\n        public rungeKutta(): number {\n            this.computeNextPosition(this.x, this.a);\n            Descent.mid(this.x, this.a, this.ia);\n            this.computeNextPosition(this.ia, this.b);\n            Descent.mid(this.x, this.b, this.ib);\n            this.computeNextPosition(this.ib, this.c);\n            this.computeNextPosition(this.c, this.d);\n            var disp = 0;\n            this.matrixApply((i, j) => {\n                var x = (this.a[i][j] + 2.0 * this.b[i][j] + 2.0 * this.c[i][j] + this.d[i][j]) / 6.0,\n                    d = this.x[i][j] - x;\n                disp += d * d;\n                this.x[i][j] = x;\n            });\n            return disp;\n        }\n\n        private static mid(a: Float32Array[], b: Float32Array[], m: Float32Array[]): void {\n            Descent.mApply(a.length, a[0].length, (i, j) =>\n                m[i][j] = a[i][j] + (b[i][j] - a[i][j]) / 2.0);\n        }\n\n        public takeDescentStep(x: Float32Array, d: Float32Array, stepSize: number): void {\n            for (var i = 0; i < this.n; ++i) {\n                x[i] = x[i] - stepSize * d[i];\n            }\n        }\n\n        public computeStress(): number {\n            var stress = 0;\n            for (var u = 0, nMinus1 = this.n - 1; u < nMinus1; ++u) {\n                for (var v = u + 1, n = this.n; v < n; ++v) {\n                    var l = 0;\n                    for (var i = 0; i < this.k; ++i) {\n                        var dx = this.x[i][u] - this.x[i][v];\n                        l += dx * dx;\n                    }\n                    l = Math.sqrt(l);\n                    var d = this.D[u][v];\n                    if (!isFinite(d)) continue;\n                    var rl = d - l;\n                    var d2 = d * d;\n                    stress += rl * rl / d2;\n                }\n            }\n            return stress;\n        }\n    }\n\n    // Linear congruential pseudo random number generator\n    export class PseudoRandom {\n        private a: number = 214013;\n        private c: number = 2531011;\n        private m: number = 2147483648;\n        private range: number = 32767;\n\n        constructor(public seed: number = 1) { }\n\n        // random real between 0 and 1\n        getNext(): number {\n            this.seed = (this.seed * this.a + this.c) % this.m;\n            return (this.seed >> 16) / this.range;\n        }\n\n        // random real between min and max\n        getNextBetween(min: number, max: number) {\n            return min + this.getNext() * (max - min);\n        }\n    }\n","    export class PositionStats {\n        AB: number = 0;\n        AD: number = 0;\n        A2: number = 0;\n\n        constructor(public scale: number) {}\n\n        addVariable(v: Variable): void {\n            var ai = this.scale / v.scale;\n            var bi = v.offset / v.scale;\n            var wi = v.weight;\n            this.AB += wi * ai * bi;\n            this.AD += wi * ai * v.desiredPosition;\n            this.A2 += wi * ai * ai;\n        }\n\n        getPosn(): number {\n            return (this.AD - this.AB) / this.A2;\n        }\n    }\n\n    export class Constraint {\n        lm: number;\n        active: boolean = false;\n        unsatisfiable: boolean = false;\n\n        constructor(public left: Variable, public right: Variable, public gap: number, public equality: boolean = false) {\n            this.left = left;\n            this.right = right;\n            this.gap = gap;\n            this.equality = equality;\n        }\n\n        slack(): number {\n            return this.unsatisfiable ? Number.MAX_VALUE\n                : this.right.scale * this.right.position() - this.gap\n                - this.left.scale * this.left.position();\n        }\n    }\n\n    export class Variable {\n        offset: number = 0;\n        block: Block;\n        cIn: Constraint[];\n        cOut: Constraint[];\n\n        constructor(public desiredPosition: number, public weight: number = 1, public scale: number = 1) {}\n\n        dfdv(): number {\n            return 2.0 * this.weight * (this.position() - this.desiredPosition);\n        }\n\n        position(): number {\n            return (this.block.ps.scale * this.block.posn + this.offset) / this.scale;\n        }\n\n        // visit neighbours by active constraints within the same block\n        visitNeighbours(prev: Variable, f: (c: Constraint, next: Variable) => void ): void {\n            var ff = (c, next) => c.active && prev !== next && f(c, next);\n            this.cOut.forEach(c=> ff(c, c.right));\n            this.cIn.forEach(c=> ff(c, c.left));\n        }\n    }\n\n    export class Block {\n        vars: Variable[] = [];\n        posn: number;\n        ps: PositionStats;\n        blockInd: number;\n\n        constructor(v: Variable) {\n            v.offset = 0;\n            this.ps = new PositionStats(v.scale);\n            this.addVariable(v);\n        }\n\n        private addVariable(v: Variable): void {\n            v.block = this;\n            this.vars.push(v);\n            this.ps.addVariable(v);\n            this.posn = this.ps.getPosn();\n        }\n\n        // move the block where it needs to be to minimize cost\n        updateWeightedPosition(): void {\n            this.ps.AB = this.ps.AD = this.ps.A2 = 0;\n            for (var i = 0, n = this.vars.length; i < n; ++i)\n                this.ps.addVariable(this.vars[i]);\n            this.posn = this.ps.getPosn();\n        }\n\n        private compute_lm(v: Variable, u: Variable, postAction: (c: Constraint)=>void): number {\n            var dfdv = v.dfdv();\n            v.visitNeighbours(u, (c, next) => {\n                var _dfdv = this.compute_lm(next, v, postAction);\n                if (next === c.right) {\n                    dfdv += _dfdv * c.left.scale;\n                    c.lm = _dfdv;\n                } else {\n                    dfdv += _dfdv * c.right.scale;\n                    c.lm = -_dfdv;\n                }\n                postAction(c);\n            });\n            return dfdv / v.scale;\n        }\n\n        private populateSplitBlock(v: Variable, prev: Variable): void {\n            v.visitNeighbours(prev, (c, next) => {\n                next.offset = v.offset + (next === c.right ? c.gap : -c.gap);\n                this.addVariable(next);\n                this.populateSplitBlock(next, v);\n            });\n        }\n\n        // traverse the active constraint tree applying visit to each active constraint\n        traverse(visit: (c: Constraint) => any, acc: any[], v: Variable = this.vars[0], prev: Variable=null) {\n            v.visitNeighbours(prev, (c, next) => {\n                acc.push(visit(c));\n                this.traverse(visit, acc, next, v);\n            });\n        }\n\n        // calculate lagrangian multipliers on constraints and\n        // find the active constraint in this block with the smallest lagrangian.\n        // if the lagrangian is negative, then the constraint is a split candidate.\n        findMinLM(): Constraint {\n            var m: Constraint = null;\n            this.compute_lm(this.vars[0], null, c=> {\n                if (!c.equality && (m === null || c.lm < m.lm)) m = c;\n            });\n            return m;\n        }\n\n        private findMinLMBetween(lv: Variable, rv: Variable): Constraint {\n            this.compute_lm(lv, null, () => {});\n            var m = null;\n            this.findPath(lv, null, rv, (c, next)=> {\n                if (!c.equality && c.right === next && (m === null || c.lm < m.lm)) m = c;\n            });\n            return m;\n        }\n\n        private findPath(v: Variable, prev: Variable, to: Variable, visit: (c: Constraint, next:Variable)=>void): boolean {\n            var endFound = false;\n            v.visitNeighbours(prev, (c, next) => {\n                if (!endFound && (next === to || this.findPath(next, v, to, visit)))\n                {\n                    endFound = true;\n                    visit(c, next);\n                }\n            });\n            return endFound;\n        }\n\n        // Search active constraint tree from u to see if there is a directed path to v.\n        // Returns true if path is found.\n        isActiveDirectedPathBetween(u: Variable, v: Variable) : boolean {\n            if (u === v) return true;\n            var i = u.cOut.length;\n            while(i--) {\n                var c = u.cOut[i];\n                if (c.active && this.isActiveDirectedPathBetween(c.right, v))\n                    return true;\n            }\n            return false;\n        }\n\n        // split the block into two by deactivating the specified constraint\n        static split(c: Constraint): Block[]{\n/* DEBUG\n            console.log(\"split on \" + c);\n            console.assert(c.active, \"attempt to split on inactive constraint\");\nDEBUG */\n            c.active = false;\n            return [Block.createSplitBlock(c.left), Block.createSplitBlock(c.right)];\n        }\n\n        private static createSplitBlock(startVar: Variable): Block {\n            var b = new Block(startVar);\n            b.populateSplitBlock(startVar, null);\n            return b;\n        }\n\n        // find a split point somewhere between the specified variables\n        splitBetween(vl: Variable, vr: Variable): { constraint: Constraint; lb: Block; rb: Block } {\n/* DEBUG\n            console.assert(vl.block === this);\n            console.assert(vr.block === this);\nDEBUG */\n            var c = this.findMinLMBetween(vl, vr);\n            if (c !== null) {\n                var bs = Block.split(c);\n                return { constraint: c, lb: bs[0], rb: bs[1] };\n            }\n            // couldn't find a split point - for example the active path is all equality constraints\n            return null;\n        }\n\n        mergeAcross(b: Block, c: Constraint, dist: number): void {\n            c.active = true;\n            for (var i = 0, n = b.vars.length; i < n; ++i) {\n                var v = b.vars[i];\n                v.offset += dist;\n                this.addVariable(v);\n            }\n            this.posn = this.ps.getPosn();\n        }\n\n        cost(): number {\n            var sum = 0, i = this.vars.length;\n            while (i--) {\n                var v = this.vars[i],\n                    d = v.position() - v.desiredPosition;\n                sum += d * d * v.weight;\n            }\n            return sum;\n        }\n\n/* DEBUG\n        toString(): string {\n            var cs = [];\n            this.traverse(c=> c.toString() + \"\\n\", cs)\n            return \"b\"+this.blockInd + \"@\" + this.posn + \": vars=\" + this.vars.map(v=> v.toString()+\":\"+v.offset) + \";\\n cons=\\n\" + cs;\n        }\nDEBUG */\n    }\n\n    export class Blocks {\n        private list: Block[];\n\n        constructor(public vs: Variable[]) {\n            var n = vs.length;\n            this.list = new Array(n);\n            while (n--) {\n                var b = new Block(vs[n]);\n                this.list[n] = b;\n                b.blockInd = n;\n            }\n        }\n\n        cost(): number {\n            var sum = 0, i = this.list.length;\n            while (i--) sum += this.list[i].cost();\n            return sum;\n        }\n\n        insert(b: Block) {\n/* DEBUG\n            console.assert(!this.contains(b), \"blocks error: tried to reinsert block \" + b.blockInd)\nDEBUG */\n            b.blockInd = this.list.length;\n            this.list.push(b);\n/* DEBUG\n            console.log(\"insert block: \" + b.blockInd);\n            this.contains(b);\nDEBUG */\n        }\n\n        remove(b: Block) {\n/* DEBUG\n            console.log(\"remove block: \" + b.blockInd);\n            console.assert(this.contains(b));\nDEBUG */\n            var last = this.list.length - 1;\n            var swapBlock = this.list[last];\n            this.list.length = last;\n            if (b !== swapBlock) {\n                this.list[b.blockInd] = swapBlock;\n                swapBlock.blockInd = b.blockInd;\n/* DEBUG\n                console.assert(this.contains(swapBlock));\nDEBUG */\n            }\n        }\n\n        // merge the blocks on either side of the specified constraint, by copying the smaller block into the larger\n        // and deleting the smaller.\n        merge(c: Constraint): void {\n            var l = c.left.block, r = c.right.block;\n/* DEBUG\n            console.assert(l!==r, \"attempt to merge within the same block\");\nDEBUG */\n            var dist = c.right.offset - c.left.offset - c.gap;\n            if (l.vars.length < r.vars.length) {\n                r.mergeAcross(l, c, dist);\n                this.remove(l);\n            } else {\n                l.mergeAcross(r, c, -dist);\n                this.remove(r);\n            }\n/* DEBUG\n            console.assert(Math.abs(c.slack()) < 1e-6, \"Error: Constraint should be at equality after merge!\");\n            console.log(\"merged on \" + c);\nDEBUG */\n        }\n\n        forEach(f: (b: Block, i: number) => void ) {\n            this.list.forEach(f);\n        }\n\n        // useful, for example, after variable desired positions change.\n        updateBlockPositions(): void {\n            this.list.forEach(b=> b.updateWeightedPosition());\n        }\n\n        // split each block across its constraint with the minimum lagrangian\n        split(inactive: Constraint[]): void {\n            this.updateBlockPositions();\n            this.list.forEach(b=> {\n                var v = b.findMinLM();\n                if (v !== null && v.lm < Solver.LAGRANGIAN_TOLERANCE) {\n                    b = v.left.block;\n                    Block.split(v).forEach(nb=>this.insert(nb));\n                    this.remove(b);\n                    inactive.push(v);\n/* DEBUG\n                    console.assert(this.contains(v.left.block));\n                    console.assert(this.contains(v.right.block));\nDEBUG */\n                }\n            });\n        }\n\n/* DEBUG\n        // checks b is in the block, and does a sanity check over list index integrity\n        contains(b: Block): boolean {\n            var result = false;\n            this.list.forEach((bb, i) => {\n                if (bb.blockInd !== i) {\n                    console.error(\"blocks error, blockInd \" + b.blockInd + \" found at \" + i);\n                    return false;\n                }\n                result = result || b === bb;\n            });\n            return result;\n        }\n\n        toString(): string {\n            return this.list.toString();\n        }\nDEBUG */\n    }\n\n    export class Solver {\n        bs: Blocks;\n        inactive: Constraint[];\n\n        static LAGRANGIAN_TOLERANCE = -1e-4;\n        static ZERO_UPPERBOUND = -1e-10;\n\n        constructor(public vs: Variable[], public cs: Constraint[]) {\n            this.vs = vs;\n            vs.forEach(v => {\n                v.cIn = [], v.cOut = [];\n/* DEBUG\n                v.toString = () => \"v\" + vs.indexOf(v);\nDEBUG */\n            });\n            this.cs = cs;\n            cs.forEach(c => {\n                c.left.cOut.push(c);\n                c.right.cIn.push(c);\n/* DEBUG\n                c.toString = () => c.left + \"+\" + c.gap + \"<=\" + c.right + \" slack=\" + c.slack() + \" active=\" + c.active;\nDEBUG */\n            });\n            this.inactive = cs.map(c=> { c.active = false; return c; });\n            this.bs = null;\n        }\n\n        cost(): number {\n            return this.bs.cost();\n        }\n\n        // set starting positions without changing desired positions.\n        // Note: it throws away any previous block structure.\n        setStartingPositions(ps: Float32Array): void {\n            this.inactive = this.cs.map(c=> { c.active = false; return c; });\n            this.bs = new Blocks(this.vs);\n            this.bs.forEach((b, i) => b.posn = ps[i]);\n        }\n\n        setDesiredPositions(ps: Float32Array): void {\n            this.vs.forEach((v, i) => v.desiredPosition = ps[i]);\n        }\n\n/* DEBUG\n        private getId(v: Variable): number {\n            return this.vs.indexOf(v);\n        }\n\n        // sanity check of the index integrity of the inactive list\n        checkInactive(): void {\n            var inactiveCount = 0;\n            this.cs.forEach(c=> {\n                var i = this.inactive.indexOf(c);\n                console.assert(!c.active && i >= 0 || c.active && i < 0, \"constraint should be in the inactive list if it is not active: \" + c);\n                if (i >= 0) {\n                    inactiveCount++;\n                } else {\n                    console.assert(c.active, \"inactive constraint not found in inactive list: \" + c);\n                }\n            });\n            console.assert(inactiveCount === this.inactive.length, inactiveCount + \" inactive constraints found, \" + this.inactive.length + \"in inactive list\");\n        }\n        // after every call to satisfy the following should check should pass\n        checkSatisfied(): void {\n            this.cs.forEach(c=>console.assert(c.slack() >= vpsc.Solver.ZERO_UPPERBOUND, \"Error: Unsatisfied constraint! \"+c));\n        }\nDEBUG */\n\n        private mostViolated(): Constraint {\n            var minSlack = Number.MAX_VALUE,\n                v: Constraint = null,\n                l = this.inactive,\n                n = l.length,\n                deletePoint = n;\n            for (var i = 0; i < n; ++i) {\n                var c = l[i];\n                if (c.unsatisfiable) continue;\n                var slack = c.slack();\n                if (c.equality || slack < minSlack) {\n                    minSlack = slack;\n                    v = c;\n                    deletePoint = i;\n                    if (c.equality) break;\n                }\n            }\n            if (deletePoint !== n &&\n                (minSlack < Solver.ZERO_UPPERBOUND && !v.active || v.equality))\n            {\n                l[deletePoint] = l[n - 1];\n                l.length = n - 1;\n            }\n            return v;\n        }\n\n        // satisfy constraints by building block structure over violated constraints\n        // and moving the blocks to their desired positions\n        satisfy(): void {\n            if (this.bs == null) {\n                this.bs = new Blocks(this.vs);\n            }\n/* DEBUG\n            console.log(\"satisfy: \" + this.bs);\nDEBUG */\n            this.bs.split(this.inactive);\n            var v: Constraint = null;\n            while ((v = this.mostViolated()) && (v.equality || v.slack() < Solver.ZERO_UPPERBOUND && !v.active)) {\n                var lb = v.left.block, rb = v.right.block;\n/* DEBUG\n                console.log(\"most violated is: \" + v);\n                this.bs.contains(lb);\n                this.bs.contains(rb);\nDEBUG */\n                if (lb !== rb) {\n                    this.bs.merge(v);\n                } else {\n                    if (lb.isActiveDirectedPathBetween(v.right, v.left)) {\n                        // cycle found!\n                        v.unsatisfiable = true;\n                        continue;\n                    }\n                    // constraint is within block, need to split first\n                    var split = lb.splitBetween(v.left, v.right);\n                    if (split !== null) {\n                        this.bs.insert(split.lb);\n                        this.bs.insert(split.rb);\n                        this.bs.remove(lb);\n                        this.inactive.push(split.constraint);\n                    } else {\n/* DEBUG\n                        console.log(\"unsatisfiable constraint found\");\nDEBUG */\n                        v.unsatisfiable = true;\n                        continue;\n                    }\n                    if (v.slack() >= 0) {\n/* DEBUG\n                        console.log(\"violated constraint indirectly satisfied: \" + v);\nDEBUG */\n                        // v was satisfied by the above split!\n                        this.inactive.push(v);\n                    } else {\n/* DEBUG\n                        console.log(\"merge after split:\");\nDEBUG */\n                        this.bs.merge(v);\n                    }\n                }\n/* DEBUG\n                this.bs.contains(v.left.block);\n                this.bs.contains(v.right.block);\n                this.checkInactive();\nDEBUG */\n            }\n/* DEBUG\n            this.checkSatisfied();\nDEBUG */\n        }\n\n        // repeatedly build and split block structure until we converge to an optimal solution\n        solve(): number {\n            this.satisfy();\n            var lastcost = Number.MAX_VALUE, cost = this.bs.cost();\n            while (Math.abs(lastcost - cost) > 0.0001) {\n                this.satisfy();\n                lastcost = cost;\n                cost = this.bs.cost();\n            }\n            return cost;\n        }\n    }\n    /**\n      * Remove overlap between spans while keeping their centers as close as possible to the specified desiredCenters.\n      * Lower and upper bounds will be respected if the spans physically fit between them\n      * (otherwise they'll be moved and their new position returned).\n      * If no upper/lower bound is specified then the bounds of the moved spans will be returned.\n      * returns a new center for each span.\n      */\n    export function removeOverlapInOneDimension(spans: { size: number, desiredCenter: number }[], lowerBound?: number, upperBound?: number)\n        : { newCenters: number[], lowerBound: number, upperBound: number }\n    {\n        const vs: Variable[] = spans.map(s => new Variable(s.desiredCenter));\n        const cs: Constraint[] = [];\n        const n = spans.length;\n        for (var i = 0; i < n - 1; i++) {\n            const left = spans[i], right = spans[i + 1];\n            cs.push(new Constraint(vs[i], vs[i + 1], (left.size + right.size) / 2));\n        }\n        const leftMost = vs[0],\n            rightMost = vs[n - 1],\n            leftMostSize = spans[0].size / 2,\n            rightMostSize = spans[n - 1].size / 2;\n        let vLower: Variable = null, vUpper: Variable = null;\n        if (lowerBound) {\n            vLower = new Variable(lowerBound, leftMost.weight * 1000);\n            vs.push(vLower);\n            cs.push(new Constraint(vLower, leftMost, leftMostSize));\n        }\n        if (upperBound) {\n            vUpper = new Variable(upperBound, rightMost.weight * 1000);\n            vs.push(vUpper);\n            cs.push(new Constraint(rightMost, vUpper, rightMostSize));\n        }\n        var solver = new Solver(vs, cs);\n        solver.solve();\n        return {\n            newCenters: vs.slice(0, spans.length).map(v => v.position()),\n            lowerBound: vLower ? vLower.position() : leftMost.position() - leftMostSize,\n            upperBound: vUpper ? vUpper.position() : rightMost.position() + rightMostSize\n        };\n    }\n","    //Based on js_es:\n    //\n    //https://github.com/vadimg/js_bintrees\n    //\n    //Copyright (C) 2011 by Vadim Graboys\n    //\n    //Permission is hereby granted, free of charge, to any person obtaining a copy\n    //of this software and associated documentation files (the \"Software\"), to deal\n    //in the Software without restriction, including without limitation the rights\n    //to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    //copies of the Software, and to permit persons to whom the Software is\n    //furnished to do so, subject to the following conditions:\n    //\n    //The above copyright notice and this permission notice shall be included in\n    //all copies or substantial portions of the Software.\n    //\n    //THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    //IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    //FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    //AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    //LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    //OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n    //THE SOFTWARE.\n    export class TreeBase {\n        _root;\n        size;\n        _comparator;\n        // removes all nodes from the tree\n        clear() {\n            this._root = null;\n            this.size = 0;\n        };\n\n        // returns node data if found, null otherwise\n        find(data) {\n            var res = this._root;\n\n            while (res !== null) {\n                var c = this._comparator(data, res.data);\n                if (c === 0) {\n                    return res.data;\n                }\n                else {\n                    res = res.get_child(c > 0);\n                }\n            }\n\n            return null;\n        };\n\n        // returns iterator to node if found, null otherwise\n        findIter = function (data) {\n            var res = this._root;\n            var iter = this.iterator();\n\n            while (res !== null) {\n                var c = this._comparator(data, res.data);\n                if (c === 0) {\n                    iter._cursor = res;\n                    return iter;\n                }\n                else {\n                    iter._ancestors.push(res);\n                    res = res.get_child(c > 0);\n                }\n            }\n\n            return null;\n        };\n\n        // Returns an interator to the tree node immediately before (or at) the element\n        lowerBound(data) {\n            return this._bound(data, this._comparator);\n        };\n\n        // Returns an interator to the tree node immediately after (or at) the element\n        upperBound(data) {\n            var cmp = this._comparator;\n\n            function reverse_cmp(a, b) {\n                return cmp(b, a);\n            }\n\n            return this._bound(data, reverse_cmp);\n        };\n\n        // returns null if tree is empty\n        min() {\n            var res = this._root;\n            if (res === null) {\n                return null;\n            }\n\n            while (res.left !== null) {\n                res = res.left;\n            }\n\n            return res.data;\n        };\n\n        // returns null if tree is empty\n        max() {\n            var res = this._root;\n            if (res === null) {\n                return null;\n            }\n\n            while (res.right !== null) {\n                res = res.right;\n            }\n\n            return res.data;\n        };\n\n        // returns a null iterator\n        // call next() or prev() to point to an element\n        iterator(): Iterator {\n            return new Iterator(this);\n        };\n\n        // calls cb on each node's data, in order\n        each(cb) {\n            var it = this.iterator(), data;\n            while ((data = it.next()) !== null) {\n                cb(data);\n            }\n        };\n\n        // calls cb on each node's data, in reverse order\n        reach(cb) {\n            var it = this.iterator(), data;\n            while ((data = it.prev()) !== null) {\n                cb(data);\n            }\n        };\n\n        // used for lowerBound and upperBound\n        _bound(data, cmp) {\n            var cur = this._root;\n            var iter = this.iterator();\n\n            while (cur !== null) {\n                var c = this._comparator(data, cur.data);\n                if (c === 0) {\n                    iter._cursor = cur;\n                    return iter;\n                }\n                iter._ancestors.push(cur);\n                cur = cur.get_child(c > 0);\n            }\n\n            for (var i = iter._ancestors.length - 1; i >= 0; --i) {\n                cur = iter._ancestors[i];\n                if (cmp(data, cur.data) > 0) {\n                    iter._cursor = cur;\n                    iter._ancestors.length = i;\n                    return iter;\n                }\n            }\n\n            iter._ancestors.length = 0;\n            return iter;\n        };\n    }\n    export class Iterator {\n        _tree;\n        _ancestors;\n        _cursor;\n        constructor(tree) {\n            this._tree = tree;\n            this._ancestors = [];\n            this._cursor = null;\n        }\n\n        data() {\n            return this._cursor !== null ? this._cursor.data : null;\n        };\n\n        // if null-iterator, returns first node\n        // otherwise, returns next node\n        next() {\n            if (this._cursor === null) {\n                var root = this._tree._root;\n                if (root !== null) {\n                    this._minNode(root);\n                }\n            }\n            else {\n                if (this._cursor.right === null) {\n                    // no greater node in subtree, go up to parent\n                    // if coming from a right child, continue up the stack\n                    var save;\n                    do {\n                        save = this._cursor;\n                        if (this._ancestors.length) {\n                            this._cursor = this._ancestors.pop();\n                        }\n                        else {\n                            this._cursor = null;\n                            break;\n                        }\n                    } while (this._cursor.right === save);\n                }\n                else {\n                    // get the next node from the subtree\n                    this._ancestors.push(this._cursor);\n                    this._minNode(this._cursor.right);\n                }\n            }\n            return this._cursor !== null ? this._cursor.data : null;\n        };\n\n        // if null-iterator, returns last node\n        // otherwise, returns previous node\n        prev() {\n            if (this._cursor === null) {\n                var root = this._tree._root;\n                if (root !== null) {\n                    this._maxNode(root);\n                }\n            }\n            else {\n                if (this._cursor.left === null) {\n                    var save;\n                    do {\n                        save = this._cursor;\n                        if (this._ancestors.length) {\n                            this._cursor = this._ancestors.pop();\n                        }\n                        else {\n                            this._cursor = null;\n                            break;\n                        }\n                    } while (this._cursor.left === save);\n                }\n                else {\n                    this._ancestors.push(this._cursor);\n                    this._maxNode(this._cursor.left);\n                }\n            }\n            return this._cursor !== null ? this._cursor.data : null;\n        };\n\n        _minNode(start) {\n            while (start.left !== null) {\n                this._ancestors.push(start);\n                start = start.left;\n            }\n            this._cursor = start;\n        };\n\n        _maxNode(start) {\n            while (start.right !== null) {\n                this._ancestors.push(start);\n                start = start.right;\n            }\n            this._cursor = start;\n        };\n    }\n\n    class Node {\n        data;\n        left;\n        right;\n        red;\n        constructor(data) {\n            this.data = data;\n            this.left = null;\n            this.right = null;\n            this.red = true;\n        }\n\n        get_child(dir) {\n            return dir ? this.right : this.left;\n        };\n\n        set_child(dir, val) {\n            if (dir) {\n                this.right = val;\n            }\n            else {\n                this.left = val;\n            }\n        };\n    }\n\n    export class RBTree<T> extends TreeBase {\n\n        _root;\n        _comparator;\n        size;\n        constructor(comparator: (a: T, b: T) => number) {\n            super();\n            this._root = null;\n            this._comparator = comparator;\n            this.size = 0;\n        }\n\n        // returns true if inserted, false if duplicate\n        insert(data) {\n            var ret = false;\n\n            if (this._root === null) {\n                // empty tree\n                this._root = new Node(data);\n                ret = true;\n                this.size++;\n            }\n            else {\n                var head = new Node(undefined); // fake tree root\n\n                var dir = false;\n                var last = false;\n\n                // setup\n                var gp = null; // grandparent\n                var ggp = head; // grand-grand-parent\n                var p = null; // parent\n                var node = this._root;\n                ggp.right = this._root;\n\n                // search down\n                while (true) {\n                    if (node === null) {\n                        // insert new node at the bottom\n                        node = new Node(data);\n                        p.set_child(dir, node);\n                        ret = true;\n                        this.size++;\n                    }\n                    else if (RBTree.is_red(node.left) && RBTree.is_red(node.right)) {\n                        // color flip\n                        node.red = true;\n                        node.left.red = false;\n                        node.right.red = false;\n                    }\n\n                    // fix red violation\n                    if (RBTree.is_red(node) && RBTree.is_red(p)) {\n                        var dir2 = ggp.right === gp;\n\n                        if (node === p.get_child(last)) {\n                            ggp.set_child(dir2, RBTree.single_rotate(gp, !last));\n                        }\n                        else {\n                            ggp.set_child(dir2, RBTree.double_rotate(gp, !last));\n                        }\n                    }\n\n                    var cmp = this._comparator(node.data, data);\n\n                    // stop if found\n                    if (cmp === 0) {\n                        break;\n                    }\n\n                    last = dir;\n                    dir = cmp < 0;\n\n                    // update helpers\n                    if (gp !== null) {\n                        ggp = gp;\n                    }\n                    gp = p;\n                    p = node;\n                    node = node.get_child(dir);\n                }\n\n                // update root\n                this._root = head.right;\n            }\n\n            // make root black\n            this._root.red = false;\n\n            return ret;\n        };\n\n        // returns true if removed, false if not found\n        remove(data) {\n            if (this._root === null) {\n                return false;\n            }\n\n            var head = new Node(undefined); // fake tree root\n            var node = head;\n            node.right = this._root;\n            var p = null; // parent\n            var gp = null; // grand parent\n            var found = null; // found item\n            var dir = true;\n\n            while (node.get_child(dir) !== null) {\n                var last = dir;\n\n                // update helpers\n                gp = p;\n                p = node;\n                node = node.get_child(dir);\n\n                var cmp = this._comparator(data, node.data);\n\n                dir = cmp > 0;\n\n                // save found node\n                if (cmp === 0) {\n                    found = node;\n                }\n\n                // push the red node down\n                if (!RBTree.is_red(node) && !RBTree.is_red(node.get_child(dir))) {\n                    if (RBTree.is_red(node.get_child(!dir))) {\n                        var sr = RBTree.single_rotate(node, dir);\n                        p.set_child(last, sr);\n                        p = sr;\n                    }\n                    else if (!RBTree.is_red(node.get_child(!dir))) {\n                        var sibling = p.get_child(!last);\n                        if (sibling !== null) {\n                            if (!RBTree.is_red(sibling.get_child(!last)) && !RBTree.is_red(sibling.get_child(last))) {\n                                // color flip\n                                p.red = false;\n                                sibling.red = true;\n                                node.red = true;\n                            }\n                            else {\n                                var dir2 = gp.right === p;\n\n                                if (RBTree.is_red(sibling.get_child(last))) {\n                                    gp.set_child(dir2, RBTree.double_rotate(p, last));\n                                }\n                                else if (RBTree.is_red(sibling.get_child(!last))) {\n                                    gp.set_child(dir2, RBTree.single_rotate(p, last));\n                                }\n\n                                // ensure correct coloring\n                                var gpc = gp.get_child(dir2);\n                                gpc.red = true;\n                                node.red = true;\n                                gpc.left.red = false;\n                                gpc.right.red = false;\n                            }\n                        }\n                    }\n                }\n            }\n\n            // replace and remove if found\n            if (found !== null) {\n                found.data = node.data;\n                p.set_child(p.right === node, node.get_child(node.left === null));\n                this.size--;\n            }\n\n            // update root and make it black\n            this._root = head.right;\n            if (this._root !== null) {\n                this._root.red = false;\n            }\n\n            return found !== null;\n        };\n\n        static is_red(node) {\n            return node !== null && node.red;\n        }\n\n        static single_rotate(root, dir) {\n            var save = root.get_child(!dir);\n\n            root.set_child(!dir, save.get_child(dir));\n            save.set_child(dir, root);\n\n            root.red = true;\n            save.red = false;\n\n            return save;\n        }\n\n        static double_rotate(root, dir) {\n            root.set_child(!dir, RBTree.single_rotate(root.get_child(!dir), !dir));\n            return RBTree.single_rotate(root, dir);\n        }\n    }\n","import {Constraint, Variable, Solver} from './vpsc'\nimport {RBTree} from './rbtree'\nimport {Point} from './geom'\n\n    export interface Leaf {\n        bounds: Rectangle;\n        variable: Variable;\n    }\n\n    export interface ProjectionGroup {\n        bounds: Rectangle;\n        padding: number;\n        stiffness: number;\n        leaves: Leaf[];\n        groups: ProjectionGroup[];\n        minVar: Variable;\n        maxVar: Variable;\n    }\n\n    export function computeGroupBounds(g: ProjectionGroup): Rectangle {\n        g.bounds = typeof g.leaves !== \"undefined\" ?\n            g.leaves.reduce((r: Rectangle, c) => c.bounds.union(r), Rectangle.empty()) :\n            Rectangle.empty();\n        if (typeof g.groups !== \"undefined\")\n            g.bounds = <Rectangle>g.groups.reduce((r: Rectangle, c) => computeGroupBounds(c).union(r), g.bounds);\n        g.bounds = g.bounds.inflate(g.padding);\n        return g.bounds;\n    }\n\n    export class Rectangle {\n        constructor(\n            public x: number,\n            public X: number,\n            public y: number,\n            public Y: number) { }\n\n        static empty(): Rectangle { return new Rectangle(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY); }\n\n        cx(): number { return (this.x + this.X) / 2; }\n\n        cy(): number { return (this.y + this.Y) / 2; }\n\n        overlapX(r: Rectangle): number {\n            var ux = this.cx(), vx = r.cx();\n            if (ux <= vx && r.x < this.X) return this.X - r.x;\n            if (vx <= ux && this.x < r.X) return r.X - this.x;\n            return 0;\n        }\n\n        overlapY(r: Rectangle): number {\n            var uy = this.cy(), vy = r.cy();\n            if (uy <= vy && r.y < this.Y) return this.Y - r.y;\n            if (vy <= uy && this.y < r.Y) return r.Y - this.y;\n            return 0;\n        }\n\n        setXCentre(cx: number): void {\n            var dx = cx - this.cx();\n            this.x += dx;\n            this.X += dx;\n        }\n\n        setYCentre(cy: number): void {\n            var dy = cy - this.cy();\n            this.y += dy;\n            this.Y += dy;\n        }\n\n        width(): number {\n            return this.X - this.x;\n        }\n\n        height(): number {\n            return this.Y - this.y;\n        }\n\n        union(r: Rectangle): Rectangle {\n            return new Rectangle(Math.min(this.x, r.x), Math.max(this.X, r.X), Math.min(this.y, r.y), Math.max(this.Y, r.Y));\n        }\n\n        /**\n         * return any intersection points between the given line and the sides of this rectangle\n         * @method lineIntersection\n         * @param x1 number first x coord of line\n         * @param y1 number first y coord of line\n         * @param x2 number second x coord of line\n         * @param y2 number second y coord of line\n         * @return any intersection points found\n         */\n        lineIntersections(x1: number, y1: number, x2: number, y2: number): Array<Point> {\n            var sides = [[this.x, this.y, this.X, this.y],\n                    [this.X, this.y, this.X, this.Y],\n                    [this.X, this.Y, this.x, this.Y],\n                [this.x, this.Y, this.x, this.y]];\n            var intersections = [];\n            for (var i = 0; i < 4; ++i) {\n                var r = Rectangle.lineIntersection(x1, y1, x2, y2, sides[i][0], sides[i][1], sides[i][2], sides[i][3]);\n                if (r !== null) intersections.push({ x: r.x, y: r.y });\n            }\n            return intersections;\n        }\n\n        /**\n         * return any intersection points between a line extending from the centre of this rectangle to the given point,\n         *  and the sides of this rectangle\n         * @method lineIntersection\n         * @param x2 number second x coord of line\n         * @param y2 number second y coord of line\n         * @return any intersection points found\n         */\n        rayIntersection(x2: number, y2: number): Point {\n            var ints = this.lineIntersections(this.cx(), this.cy(), x2, y2);\n            return ints.length > 0 ? ints[0] : null;\n        }\n\n        vertices(): Point[] {\n            return [\n                { x: this.x, y: this.y },\n                { x: this.X, y: this.y },\n                { x: this.X, y: this.Y },\n                { x: this.x, y: this.Y }];\n        }\n\n        static lineIntersection(\n            x1: number, y1: number,\n            x2: number, y2: number,\n            x3: number, y3: number,\n            x4: number, y4: number): Point {\n            var dx12 = x2 - x1, dx34 = x4 - x3,\n                dy12 = y2 - y1, dy34 = y4 - y3,\n                denominator = dy34 * dx12 - dx34 * dy12;\n            if (denominator == 0) return null;\n            var dx31 = x1 - x3, dy31 = y1 - y3,\n                numa = dx34 * dy31 - dy34 * dx31,\n                a = numa / denominator,\n                numb = dx12 * dy31 - dy12 * dx31,\n                b = numb / denominator;\n            if (a >= 0 && a <= 1 && b >= 0 && b <= 1) {\n                return {\n                    x: x1 + a * dx12,\n                    y: y1 + a * dy12\n                };\n            }\n            return null;\n        }\n\n        inflate(pad: number): Rectangle {\n            return new Rectangle(this.x - pad, this.X + pad, this.y - pad, this.Y + pad);\n        }\n    }\n\n    /**\n     * Returns the endpoints of a line that connects the centre of two rectangles.\n     * @param {Rectangle} [source] The source Rectangle.\n     * @param {Rectangle} [target] The target Rectangle.\n     * @param {number} [ah] The size of the arrow head, a distance to shorten the\n     *                      line by.\n     * @return An object with three point properties, the intersection with the\n     *         source rectangle (sourceIntersection), the intersection with then\n     *         target rectangle (targetIntersection), and the point an arrow\n     *         head of the specified size would need to start (arrowStart).\n     */\n    export function makeEdgeBetween(source: Rectangle, target: Rectangle, ah: number)\n        : { sourceIntersection: Point; targetIntersection: Point; arrowStart: Point } {\n        const si = source.rayIntersection(target.cx(), target.cy()) || { x: source.cx(), y: source.cy() },\n            ti = target.rayIntersection(source.cx(), source.cy()) || { x: target.cx(), y: target.cy() },\n            dx = ti.x - si.x,\n            dy = ti.y - si.y,\n            l = Math.sqrt(dx * dx + dy * dy), al = l - ah;\n        return {\n            sourceIntersection: si,\n            targetIntersection: ti,\n            arrowStart: { x: si.x + al * dx / l, y: si.y + al * dy / l }\n        }\n    }\n\n    /**\n     * Returns the intersection of a line from the given point to the centre\n     * of the target rectangle where it intersects the rectanngle.\n     * @param [source] The source point.\n     * @param {Rectangle} [target] The target Rectangle.\n     * @param {number} [ah] The size of the arrow head, a distance to shorten the\n     *                      line by.\n     * @return The point an arrow head of the specified size would need to start.\n     */\n    export function makeEdgeTo(s: { x: number; y: number }, target: Rectangle, ah: number): Point {\n        var ti = target.rayIntersection(s.x, s.y);\n        if (!ti) ti = { x: target.cx(), y: target.cy() };\n        var dx = ti.x - s.x,\n            dy = ti.y - s.y,\n            l = Math.sqrt(dx * dx + dy * dy);\n        return { x: ti.x - ah * dx / l, y: ti.y - ah * dy / l };\n    }\n\n    class Node {\n        prev: RBTree<Node>;\n        next: RBTree<Node>;\n\n        constructor(public v: Variable, public r: Rectangle, public pos: number) {\n            this.prev = makeRBTree();\n            this.next = makeRBTree();\n        }\n    }\n\n    class Event {\n        constructor(public isOpen: boolean, public v: Node, public pos: number) {}\n    }\n\n    function compareEvents(a: Event, b: Event): number {\n        if (a.pos > b.pos) {\n            return 1;\n        }\n        if (a.pos < b.pos) {\n            return -1;\n        }\n        if (a.isOpen) {\n            // open must come before close\n            return -1;\n        }\n        if (b.isOpen) {\n            // open must come before close\n            return 1;\n        }\n        return 0;\n    }\n\n    function makeRBTree(): RBTree<Node> {\n        return new RBTree<Node>((a, b) => a.pos - b.pos);\n    }\n\n    interface RectAccessors {\n        getCentre: (r: Rectangle) => number;\n        getOpen: (r: Rectangle) => number;\n        getClose: (r: Rectangle) => number;\n        getSize: (r: Rectangle) => number;\n        makeRect: (open: number, close: number, center: number, size: number) => Rectangle;\n        findNeighbours: (v: Node, scanline: RBTree<Node>) => void;\n    }\n\n    var xRect: RectAccessors = {\n        getCentre: r=> r.cx(),\n        getOpen: r=> r.y,\n        getClose: r=> r.Y,\n        getSize: r=> r.width(),\n        makeRect: (open, close, center, size) => new Rectangle(center - size / 2, center + size / 2, open, close) ,\n        findNeighbours: findXNeighbours\n    };\n\n    var yRect: RectAccessors = {\n        getCentre: r=> r.cy(),\n        getOpen: r=> r.x,\n        getClose: r=> r.X,\n        getSize: r=> r.height(),\n        makeRect: (open, close, center, size) => new Rectangle(open, close, center - size / 2, center + size / 2),\n        findNeighbours: findYNeighbours\n    };\n\n    function generateGroupConstraints(root: ProjectionGroup, f: RectAccessors, minSep: number, isContained: boolean = false): Constraint[]\n    {\n        var padding = root.padding,\n            gn = typeof root.groups !== 'undefined' ? root.groups.length : 0,\n            ln = typeof root.leaves !== 'undefined' ? root.leaves.length : 0,\n            childConstraints: Constraint[] = !gn ? []\n            : root.groups.reduce((ccs: Constraint[], g) => ccs.concat(generateGroupConstraints(g, f, minSep, true)), []),\n            n = (isContained ? 2 : 0) + ln + gn,\n            vs: Variable[] = new Array(n),\n            rs: Rectangle[] = new Array(n),\n            i = 0,\n            add = (r, v) => { rs[i] = r; vs[i++] = v };\n        if (isContained) {\n            // if this group is contained by another, then we add two dummy vars and rectangles for the borders\n            var b: Rectangle = root.bounds,\n                c = f.getCentre(b), s = f.getSize(b) / 2,\n                open = f.getOpen(b), close = f.getClose(b),\n                min = c - s + padding / 2, max = c + s - padding / 2;\n            root.minVar.desiredPosition = min;\n            add(f.makeRect(open, close, min, padding), root.minVar);\n            root.maxVar.desiredPosition = max;\n            add(f.makeRect(open, close, max, padding), root.maxVar);\n        }\n        if (ln) root.leaves.forEach(l => add(l.bounds, l.variable));\n        if (gn) root.groups.forEach(g => {\n            var b: Rectangle = g.bounds;\n            add(f.makeRect(f.getOpen(b), f.getClose(b), f.getCentre(b), f.getSize(b)), g.minVar);\n        });\n        var cs = generateConstraints(rs, vs, f, minSep);\n        if (gn) {\n            vs.forEach(v => { v.cOut = [], v.cIn = [] });\n            cs.forEach(c => { c.left.cOut.push(c), c.right.cIn.push(c) });\n            root.groups.forEach(g => {\n                var gapAdjustment = (g.padding - f.getSize(g.bounds)) / 2;\n                g.minVar.cIn.forEach(c => c.gap += gapAdjustment);\n                g.minVar.cOut.forEach(c => { c.left = g.maxVar; c.gap += gapAdjustment; });\n            });\n        }\n        return childConstraints.concat(cs);\n    }\n\n    function generateConstraints(rs: Rectangle[], vars: Variable[],\n        rect: RectAccessors, minSep: number): Constraint[]\n    {\n        var i, n = rs.length;\n        var N = 2 * n;\n        console.assert(vars.length >= n);\n        var events = new Array<Event>(N);\n        for (i = 0; i < n; ++i) {\n            var r = rs[i];\n            var v = new Node(vars[i], r, rect.getCentre(r));\n            events[i] = new Event(true, v, rect.getOpen(r));\n            events[i + n] = new Event(false, v, rect.getClose(r));\n        }\n        events.sort(compareEvents);\n        var cs = new Array<Constraint>();\n        var scanline = makeRBTree();\n        for (i = 0; i < N; ++i) {\n            var e = events[i];\n            var v = e.v;\n            if (e.isOpen) {\n                scanline.insert(v);\n                rect.findNeighbours(v, scanline);\n            } else {\n                // close event\n                scanline.remove(v);\n                var makeConstraint = (l, r) => {\n                    var sep = (rect.getSize(l.r) + rect.getSize(r.r)) / 2 + minSep;\n                    cs.push(new Constraint(l.v, r.v, sep));\n                };\n                var visitNeighbours = (forward, reverse, mkcon) => {\n                    var u, it = v[forward].iterator();\n                    while ((u = it[forward]()) !== null) {\n                        mkcon(u, v);\n                        u[reverse].remove(v);\n                    }\n                };\n                visitNeighbours(\"prev\", \"next\", (u, v) => makeConstraint(u, v));\n                visitNeighbours(\"next\", \"prev\", (u, v) => makeConstraint(v, u));\n            }\n        }\n        console.assert(scanline.size === 0);\n        return cs;\n    }\n\n    function findXNeighbours(v: Node, scanline: RBTree<Node>): void {\n        var f = (forward, reverse) => {\n            var it = scanline.findIter(v);\n            var u;\n            while ((u = it[forward]()) !== null) {\n                var uovervX = u.r.overlapX(v.r);\n                if (uovervX <= 0 || uovervX <= u.r.overlapY(v.r)) {\n                    v[forward].insert(u);\n                    u[reverse].insert(v);\n                }\n                if (uovervX <= 0) {\n                    break;\n                }\n            }\n        }\n        f(\"next\", \"prev\");\n        f(\"prev\", \"next\");\n    }\n\n    function findYNeighbours(v: Node, scanline: RBTree<Node>): void {\n        var f = (forward, reverse) => {\n            var u = scanline.findIter(v)[forward]();\n            if (u !== null && u.r.overlapX(v.r) > 0) {\n                v[forward].insert(u);\n                u[reverse].insert(v);\n            }\n        }\n        f(\"next\", \"prev\");\n        f(\"prev\", \"next\");\n    }\n\n    export function generateXConstraints(rs: Rectangle[], vars: Variable[]): Constraint[] {\n        return generateConstraints(rs, vars, xRect, 1e-6);\n    }\n\n    export function generateYConstraints(rs: Rectangle[], vars: Variable[]): Constraint[] {\n        return generateConstraints(rs, vars, yRect, 1e-6);\n    }\n\n    export function generateXGroupConstraints(root: ProjectionGroup): Constraint[] {\n        return generateGroupConstraints(root, xRect, 1e-6);\n    }\n\n    export function generateYGroupConstraints(root: ProjectionGroup): Constraint[] {\n        return generateGroupConstraints(root, yRect, 1e-6);\n    }\n\n    export function removeOverlaps(rs: Rectangle[]): void {\n        var vs = rs.map(r => new Variable(r.cx()));\n        var cs = generateXConstraints(rs, vs);\n        var solver = new Solver(vs, cs);\n        solver.solve();\n        vs.forEach((v, i) => rs[i].setXCentre(v.position()));\n        vs = rs.map(r=> new Variable(r.cy()));\n        cs = generateYConstraints(rs, vs);\n        solver = new Solver(vs, cs);\n        solver.solve();\n        vs.forEach((v, i) => rs[i].setYCentre(v.position()));\n    }\n\n    export interface GraphNode extends Leaf {\n        fixed: boolean;\n        fixedWeight?: number;\n        width: number;\n        height: number;\n        x: number;\n        y: number;\n        px: number;\n        py: number;\n    }\n\n    export class IndexedVariable extends Variable {\n        constructor(public index: number, w: number) {\n            super(0, w);\n        }\n    }\n\n    export class Projection {\n        private xConstraints: Constraint[];\n        private yConstraints: Constraint[];\n        private variables: Variable[];\n\n        constructor(private nodes: GraphNode[],\n            private groups: ProjectionGroup[],\n            private rootGroup: ProjectionGroup = null,\n            constraints: any[]= null,\n            private avoidOverlaps: boolean = false)\n        {\n            this.variables = nodes.map((v, i) => {\n                return v.variable = new IndexedVariable(i, 1);\n            });\n\n            if (constraints) this.createConstraints(constraints);\n\n            if (avoidOverlaps && rootGroup && typeof rootGroup.groups !== 'undefined') {\n                nodes.forEach(v => {\n\t\t\t\t\tif (!v.width || !v.height)\n\t\t\t\t\t{\n\t\t\t\t\t\t//If undefined, default to nothing\n\t\t\t\t\t\tv.bounds = new Rectangle(v.x, v.x, v.y, v.y);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n                    var w2 = v.width / 2, h2 = v.height / 2;\n                    v.bounds = new Rectangle(v.x - w2, v.x + w2, v.y - h2, v.y + h2);\n                });\n                computeGroupBounds(rootGroup);\n                var i = nodes.length;\n                groups.forEach(g => {\n                    this.variables[i] = g.minVar = new IndexedVariable(i++, typeof g.stiffness !== \"undefined\" ? g.stiffness : 0.01);\n                    this.variables[i] = g.maxVar = new IndexedVariable(i++, typeof g.stiffness !== \"undefined\" ? g.stiffness : 0.01);\n                });\n            }\n        }\n\n\n        private createSeparation(c: any) : Constraint {\n            return new Constraint(\n                this.nodes[c.left].variable,\n                this.nodes[c.right].variable,\n                c.gap,\n                typeof c.equality !== \"undefined\" ? c.equality : false);\n        }\n\n        // simple satisfaction of alignment constraints to ensure initial feasibility\n        private makeFeasible(c: any) {\n            if (!this.avoidOverlaps) return;\n            // sort nodes in constraint by position (along \"guideline\")\n            var axis = 'x', dim = 'width';\n            if (c.axis === 'x') axis = 'y', dim = 'height';\n            var vs: GraphNode[] = c.offsets.map(o => this.nodes[o.node]).sort((a, b) => a[axis] - b[axis]);\n            var p: GraphNode = null;\n            vs.forEach(v => {\n                // if two nodes overlap then shove the second one along\n                if (p) {\n                    let nextPos = p[axis] + p[dim];\n                    if (nextPos > v[axis]) {\n                        v[axis] = nextPos;\n                    }\n                }\n                p = v;\n            });\n        }\n\n        private createAlignment(c: any) {\n            var u = this.nodes[c.offsets[0].node].variable;\n            this.makeFeasible(c);\n            var cs = c.axis === 'x' ? this.xConstraints : this.yConstraints;\n            c.offsets.slice(1).forEach(o => {\n                var v = this.nodes[o.node].variable;\n                cs.push(new Constraint(u, v, o.offset, true));\n            });\n        }\n\n        private createConstraints(constraints: any[]) {\n            var isSep = c => typeof c.type === 'undefined' || c.type === 'separation';\n            this.xConstraints = constraints\n                .filter(c => c.axis === \"x\" && isSep(c))\n                .map(c => this.createSeparation(c));\n            this.yConstraints = constraints\n                .filter(c => c.axis === \"y\" && isSep(c))\n                .map(c => this.createSeparation(c));\n            constraints\n                .filter(c => c.type === 'alignment')\n                .forEach(c => this.createAlignment(c));\n        }\n\n        private setupVariablesAndBounds(x0: Float32Array, y0: Float32Array, desired: Float32Array, getDesired: (v: GraphNode) => number) {\n            this.nodes.forEach((v, i) => {\n                if (v.fixed) {\n                    v.variable.weight = v.fixedWeight ? v.fixedWeight : 1000;\n                    desired[i] = getDesired(v);\n                } else {\n                    v.variable.weight = 1;\n                }\n                var w = (v.width || 0) / 2, h = (v.height || 0) / 2;\n                var ix = x0[i], iy = y0[i];\n                v.bounds = new Rectangle(ix - w, ix + w, iy - h, iy + h);\n            });\n        }\n\n        xProject(x0: Float32Array, y0: Float32Array, x: Float32Array) {\n            if (!this.rootGroup && !(this.avoidOverlaps || this.xConstraints)) return;\n            this.project(x0, y0, x0, x, v=> v.px, this.xConstraints, generateXGroupConstraints,\n                v => v.bounds.setXCentre(x[(<IndexedVariable>v.variable).index] = v.variable.position()),\n                g => {\n                    var xmin = x[(<IndexedVariable>g.minVar).index] = g.minVar.position();\n                    var xmax = x[(<IndexedVariable>g.maxVar).index] = g.maxVar.position();\n                    var p2 = g.padding / 2;\n                    g.bounds.x = xmin - p2;\n                    g.bounds.X = xmax + p2;\n                });\n        }\n\n        yProject(x0: Float32Array, y0: Float32Array, y: Float32Array) {\n            if (!this.rootGroup && !this.yConstraints) return;\n            this.project(x0, y0, y0, y, v=> v.py, this.yConstraints, generateYGroupConstraints,\n                v => v.bounds.setYCentre(y[(<IndexedVariable>v.variable).index] = v.variable.position()),\n                g => {\n                    var ymin = y[(<IndexedVariable>g.minVar).index] = g.minVar.position();\n                    var ymax = y[(<IndexedVariable>g.maxVar).index] = g.maxVar.position();\n                    var p2 = g.padding / 2;\n                    g.bounds.y = ymin - p2;;\n                    g.bounds.Y = ymax + p2;\n                });\n        }\n\n        projectFunctions(): { (x0: Float32Array, y0: Float32Array, r: Float32Array): void }[]{\n            return [\n                (x0, y0, x) => this.xProject(x0, y0, x),\n                (x0, y0, y) => this.yProject(x0, y0, y)\n            ];\n        }\n\n        private project(x0: Float32Array, y0: Float32Array, start: Float32Array, desired: Float32Array,\n            getDesired: (v: GraphNode) => number,\n            cs: Constraint[],\n            generateConstraints: (g: ProjectionGroup) => Constraint[],\n            updateNodeBounds: (v: GraphNode) => any,\n            updateGroupBounds: (g: ProjectionGroup) => any)\n        {\n            this.setupVariablesAndBounds(x0, y0, desired, getDesired);\n            if (this.rootGroup && this.avoidOverlaps) {\n                computeGroupBounds(this.rootGroup);\n                cs = cs.concat(generateConstraints(this.rootGroup));\n            }\n            this.solve(this.variables, cs, start, desired);\n            this.nodes.forEach(updateNodeBounds);\n            if (this.rootGroup && this.avoidOverlaps) {\n                this.groups.forEach(updateGroupBounds);\n                computeGroupBounds(this.rootGroup);\n            }\n        }\n\n        private solve(vs: Variable[], cs: Constraint[], starting: Float32Array, desired: Float32Array) {\n            var solver = new Solver(vs, cs);\n            solver.setStartingPositions(starting);\n            solver.setDesiredPositions(desired);\n            solver.solve();\n        }\n    }\n","\nexport class PairingHeap<T> {\n    private subheaps : PairingHeap<T>[];\n    // from: https://gist.github.com/nervoussystem\n    //{elem:object, subheaps:[array of heaps]}\n    constructor(public elem: T) {\n        this.subheaps = [];\n    }\n\n    public toString(selector) : string {\n        var str = \"\", needComma = false;\n        for (var i = 0; i < this.subheaps.length; ++i) {\n            var subheap: PairingHeap<T> = this.subheaps[i];\n            if (!subheap.elem) {\n                needComma = false;\n                continue;\n            }\n            if (needComma) {\n                str = str + \",\";\n            }\n            str = str + subheap.toString(selector);\n            needComma = true;\n        }\n        if (str !== \"\") {\n            str = \"(\" + str + \")\";\n        }\n        return (this.elem ? selector(this.elem) : \"\") + str;\n    }\n\n    public forEach(f) {\n        if (!this.empty()) {\n            f(this.elem, this);\n            this.subheaps.forEach(s => s.forEach(f));\n        }\n    }\n\n    public count(): number {\n        return this.empty() ? 0 : 1 + this.subheaps.reduce((n: number, h: PairingHeap<T>) => {\n            return n + h.count();\n        }, 0);\n    }\n\n    public min() : T {\n        return this.elem;\n    }\n\n    public empty() : boolean {\n        return this.elem == null;\n    }\n\n    public contains(h: PairingHeap<T>): boolean {\n        if (this === h) return true;\n        for (var i = 0; i < this.subheaps.length; i++) {\n            if (this.subheaps[i].contains(h)) return true;\n        }\n        return false;\n    }\n\n    public isHeap(lessThan: (a: T, b: T) => boolean): boolean {\n        return this.subheaps.every(h=> lessThan(this.elem, h.elem) && h.isHeap(lessThan));\n    }\n\n    public insert(obj : T, lessThan) : PairingHeap<T> {\n        return this.merge(new PairingHeap<T>(obj), lessThan);\n    }\n\n    public merge(heap2: PairingHeap<T>, lessThan): PairingHeap<T> {\n        if (this.empty()) return heap2;\n        else if (heap2.empty()) return this;\n        else if (lessThan(this.elem, heap2.elem)) {\n            this.subheaps.push(heap2);\n            return this;\n        } else {\n            heap2.subheaps.push(this);\n            return heap2;\n        }\n    }\n\n    public removeMin(lessThan: (a: T, b: T) => boolean): PairingHeap<T> {\n        if (this.empty()) return null;\n        else return this.mergePairs(lessThan);\n    }\n\n    public mergePairs(lessThan: (a: T, b: T) => boolean) : PairingHeap<T> {\n        if (this.subheaps.length == 0) return new PairingHeap<T>(null);\n        else if (this.subheaps.length == 1) { return this.subheaps[0]; }\n        else {\n            var firstPair = this.subheaps.pop().merge(this.subheaps.pop(), lessThan);\n            var remaining = this.mergePairs(lessThan);\n            return firstPair.merge(remaining, lessThan);\n        }\n    }\n    public decreaseKey(subheap: PairingHeap<T>, newValue: T, setHeapNode: (e: T, h: PairingHeap<T>)=>void, lessThan: (a: T, b: T) => boolean): PairingHeap<T> {\n        var newHeap = subheap.removeMin(lessThan);\n        //reassign subheap values to preserve tree\n        subheap.elem = newHeap.elem;\n        subheap.subheaps = newHeap.subheaps;\n        if (setHeapNode !== null && newHeap.elem !== null) {\n            setHeapNode(subheap.elem, subheap);\n        }\n        var pairingNode = new PairingHeap(newValue);\n        if (setHeapNode !== null) {\n            setHeapNode(newValue, pairingNode);\n        }\n        return this.merge(pairingNode, lessThan);\n    }\n}\n\n/**\n * @class PriorityQueue a min priority queue backed by a pairing heap\n */\nexport class PriorityQueue<T> {\n    private root : PairingHeap<T>;\n    constructor(private lessThan: (a: T, b: T) => boolean) { }\n    /**\n     * @method top\n     * @return the top element (the min element as defined by lessThan)\n     */\n    public top() : T {\n        if (this.empty()) { return null; }\n        return this.root.elem;\n    }\n    /**\n     * @method push\n     * put things on the heap\n     */\n    public push(...args: T[]): PairingHeap<T> {\n        var pairingNode;\n        for (var i = 0, arg; arg=args[i]; ++i) {\n            pairingNode = new PairingHeap(arg);\n            this.root = this.empty() ?\n                pairingNode : this.root.merge(pairingNode, this.lessThan);\n        }\n        return pairingNode;\n    }\n    /**\n     * @method empty\n     * @return true if no more elements in queue\n     */\n    public empty(): boolean {\n        return !this.root || !this.root.elem;\n    }\n    /**\n     * @method isHeap check heap condition (for testing)\n     * @return true if queue is in valid state\n     */\n    public isHeap(): boolean {\n        return this.root.isHeap(this.lessThan);\n    }\n    /**\n     * @method forEach apply f to each element of the queue\n     * @param f function to apply\n     */\n    public forEach(f) {\n        this.root.forEach(f);\n    }\n    /**\n     * @method pop remove and return the min element from the queue\n     */\n    public pop(): T {\n        if (this.empty()) {\n            return null;\n        }\n        var obj = this.root.min();\n        this.root = this.root.removeMin(this.lessThan);\n        return obj;\n    }\n    /**\n     * @method reduceKey reduce the key value of the specified heap node\n     */\n    public reduceKey(heapNode: PairingHeap<T>, newKey: T, setHeapNode: (e: T, h: PairingHeap<T>)=>void = null): void {\n        this.root = this.root.decreaseKey(heapNode, newKey, setHeapNode, this.lessThan);\n    }\n    public toString(selector) {\n        return this.root.toString(selector);\n    }\n    /**\n     * @method count\n     * @return number of elements in queue\n     */\n    public count() {\n        return this.root.count();\n    }\n}\n","import {PairingHeap, PriorityQueue} from './pqueue'\n\nclass Neighbour {\n    constructor(public id: number, public distance: number) { }\n}\n\nclass Node {\n    constructor(public id: number) {\n        this.neighbours = [];\n    }\n    neighbours: Neighbour[];\n    d: number;\n    prev: Node;\n    q: PairingHeap<Node>;\n}\n\nclass QueueEntry {\n    constructor(public node: Node, public prev: QueueEntry, public d: number) {}\n}\n\n/**\n * calculates all-pairs shortest paths or shortest paths from a single node\n * @class Calculator\n * @constructor\n * @param n {number} number of nodes\n * @param es {Edge[]} array of edges\n */\nexport class Calculator<Link> {\n    private neighbours: Node[];\n\n    constructor(public n: number, public es: Link[], getSourceIndex: (l: Link) => number, getTargetIndex: (l: Link) => number, getLength: (l: Link) => number) {\n        this.neighbours = new Array(this.n);\n        var i = this.n; while (i--) this.neighbours[i] = new Node(i);\n\n        i = this.es.length; while (i--) {\n            var e = this.es[i];\n            var u: number = getSourceIndex(e), v: number = getTargetIndex(e);\n            var d = getLength(e);\n            this.neighbours[u].neighbours.push(new Neighbour(v, d));\n            this.neighbours[v].neighbours.push(new Neighbour(u, d));\n        }\n    }\n\n    /**\n     * compute shortest paths for graph over n nodes with edges an array of source/target pairs\n     * edges may optionally have a length attribute.  1 is the default.\n     * Uses Johnson's algorithm.\n     *\n     * @method DistanceMatrix\n     * @return the distance matrix\n     */\n    DistanceMatrix(): number[][] {\n        var D = new Array(this.n);\n        for (var i = 0; i < this.n; ++i) {\n            D[i] = this.dijkstraNeighbours(i);\n        }\n        return D;\n    }\n\n    /**\n     * get shortest paths from a specified start node\n     * @method DistancesFromNode\n     * @param start node index\n     * @return array of path lengths\n     */\n    DistancesFromNode(start: number): number[] {\n        return this.dijkstraNeighbours(start);\n    }\n\n    PathFromNodeToNode(start: number, end: number): number[] {\n        return this.dijkstraNeighbours(start, end);\n    }\n\n    // find shortest path from start to end, with the opportunity at\n    // each edge traversal to compute a custom cost based on the\n    // previous edge.  For example, to penalise bends.\n    PathFromNodeToNodeWithPrevCost(\n        start: number,\n        end: number,\n        prevCost: (u:number,v:number,w:number)=>number): number[]\n    {\n        var q = new PriorityQueue<QueueEntry>((a, b) => a.d <= b.d),\n            u: Node = this.neighbours[start],\n            qu: QueueEntry = new QueueEntry(u,null,0),\n            visitedFrom = {};\n        q.push(qu);\n        while(!q.empty()) {\n            qu = q.pop();\n            u = qu.node;\n            if (u.id === end) {\n                break;\n            }\n            var i = u.neighbours.length; while (i--) {\n                var neighbour = u.neighbours[i],\n                    v = this.neighbours[neighbour.id];\n\n                // don't double back\n                if (qu.prev && v.id === qu.prev.node.id) continue;\n\n                // don't retraverse an edge if it has already been explored\n                // from a lower cost route\n                var viduid = v.id + ',' + u.id;\n                if(viduid in visitedFrom && visitedFrom[viduid] <= qu.d)\n                    continue;\n\n                var cc = qu.prev ? prevCost(qu.prev.node.id, u.id, v.id) : 0,\n                    t = qu.d + neighbour.distance + cc;\n\n                // store cost of this traversal\n                visitedFrom[viduid] = t;\n                q.push(new QueueEntry(v, qu, t));\n            }\n        }\n        var path:number[] = [];\n        while (qu.prev) {\n            qu = qu.prev;\n            path.push(qu.node.id);\n        }\n        return path;\n    }\n\n    private dijkstraNeighbours(start: number, dest: number = -1): number[] {\n        var q = new PriorityQueue<Node>((a, b) => a.d <= b.d),\n            i = this.neighbours.length,\n            d: number[] = new Array(i);\n        while (i--) {\n            var node: Node = this.neighbours[i];\n            node.d = i === start ? 0 : Number.POSITIVE_INFINITY;\n            node.q = q.push(node);\n        }\n        while (!q.empty()) {\n            // console.log(q.toString(function (u) { return u.id + \"=\" + (u.d === Number.POSITIVE_INFINITY ? \"\\u221E\" : u.d.toFixed(2) )}));\n            var u = q.pop();\n            d[u.id] = u.d;\n            if (u.id === dest) {\n                var path: number[] = [];\n                var v = u;\n                while (typeof v.prev !== 'undefined') {\n                    path.push(v.prev.id);\n                    v = v.prev;\n                }\n                return path;\n            }\n            i = u.neighbours.length; while (i--) {\n                var neighbour = u.neighbours[i];\n                var v = this.neighbours[neighbour.id];\n                var t = u.d + neighbour.distance;\n                if (u.d !== Number.MAX_VALUE && v.d > t) {\n                    v.d = t;\n                    v.prev = u;\n                    q.reduceKey(v.q, v, (e,q)=>e.q = q);\n                }\n            }\n        }\n        return d;\n    }\n}\n","import {Rectangle} from './rectangle'\n    export class Point {\n        x: number;\n        y: number;\n    }\n\n    export class LineSegment {\n        constructor(public x1: number, public y1: number, public x2: number, public y2: number) { }\n    }\n\n    export class PolyPoint extends Point {\n        polyIndex: number;\n    }\n\n    /** tests if a point is Left|On|Right of an infinite line.\n     * @param points P0, P1, and P2\n     * @return >0 for P2 left of the line through P0 and P1\n     *            =0 for P2 on the line\n     *            <0 for P2 right of the line\n     */\n    export function isLeft(P0: Point, P1: Point, P2: Point): number {\n        return (P1.x - P0.x) * (P2.y - P0.y) - (P2.x - P0.x) * (P1.y - P0.y);\n    }\n\n    function above(p: Point, vi: Point, vj: Point): boolean {\n        return isLeft(p, vi, vj) > 0;\n    }\n\n    function below(p: Point, vi: Point, vj: Point): boolean {\n        return isLeft(p, vi, vj) < 0;\n    }\n\n\n    /**\n     * returns the convex hull of a set of points using Andrew's monotone chain algorithm\n     * see: http://geomalgorithms.com/a10-_hull-1.html#Monotone%20Chain\n     * @param S array of points\n     * @return the convex hull as an array of points\n     */\n    export function ConvexHull(S: Point[]): Point[] {\n        var P = S.slice(0).sort((a, b) => a.x !== b.x ? b.x - a.x : b.y - a.y);\n        var n = S.length, i;\n        var minmin = 0;\n        var xmin = P[0].x;\n        for (i = 1; i < n; ++i) {\n            if (P[i].x !== xmin) break;\n        }\n        var minmax = i - 1;\n        var H: Point[] = [];\n        H.push(P[minmin]); // push minmin point onto stack\n        if (minmax === n - 1) { // degenerate case: all x-coords == xmin\n            if (P[minmax].y !== P[minmin].y) // a  nontrivial segment\n                H.push(P[minmax]);\n        } else {\n            // Get the indices of points with max x-coord and min|max y-coord\n            var maxmin, maxmax = n - 1;\n            var xmax = P[n - 1].x;\n            for (i = n - 2; i >= 0; i--)\n                if (P[i].x !== xmax) break;\n            maxmin = i + 1;\n\n            // Compute the lower hull on the stack H\n            i = minmax;\n            while (++i <= maxmin) {\n                // the lower line joins P[minmin]  with P[maxmin]\n                if (isLeft(P[minmin], P[maxmin], P[i]) >= 0 && i < maxmin)\n                    continue; // ignore P[i] above or on the lower line\n\n                while (H.length > 1) // there are at least 2 points on the stack\n                {\n                    // test if  P[i] is left of the line at the stack top\n                    if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)\n                        break; // P[i] is a new hull  vertex\n                    else\n                        H.length -= 1; // pop top point off  stack\n                }\n                if (i != minmin) H.push(P[i]);\n            }\n\n            // Next, compute the upper hull on the stack H above the bottom hull\n            if (maxmax != maxmin) // if  distinct xmax points\n                H.push(P[maxmax]); // push maxmax point onto stack\n            var bot = H.length; // the bottom point of the upper hull stack\n            i = maxmin;\n            while (--i >= minmax) {\n                // the upper line joins P[maxmax]  with P[minmax]\n                if (isLeft(P[maxmax], P[minmax], P[i]) >= 0 && i > minmax)\n                    continue; // ignore P[i] below or on the upper line\n\n                while (H.length > bot) // at least 2 points on the upper stack\n                {\n                    // test if  P[i] is left of the line at the stack top\n                    if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)\n                        break; // P[i] is a new hull  vertex\n                    else\n                        H.length -= 1; // pop top point off  stack\n                }\n                if (i != minmin) H.push(P[i]); // push P[i] onto stack\n            }\n        }\n        return H;\n    }\n\n    // apply f to the points in P in clockwise order around the point p\n    export function clockwiseRadialSweep(p: Point, P: Point[], f: (p: Point) => void) {\n        P.slice(0).sort(\n            (a, b) => Math.atan2(a.y - p.y, a.x - p.x) - Math.atan2(b.y - p.y, b.x - p.x)\n            ).forEach(f);\n    }\n\n    function nextPolyPoint(p: PolyPoint, ps: PolyPoint[]): PolyPoint {\n        if (p.polyIndex === ps.length - 1) return ps[0];\n        return ps[p.polyIndex + 1];\n    }\n\n    function prevPolyPoint(p: PolyPoint, ps: PolyPoint[]): PolyPoint {\n        if (p.polyIndex === 0) return ps[ps.length - 1];\n        return ps[p.polyIndex - 1];\n    }\n\n    // tangent_PointPolyC(): fast binary search for tangents to a convex polygon\n    //    Input:  P = a 2D point (exterior to the polygon)\n    //            n = number of polygon vertices\n    //            V = array of vertices for a 2D convex polygon\n    //    Output: rtan = index of rightmost tangent point V[rtan]\n    //            ltan = index of leftmost tangent point V[ltan]\n    function tangent_PointPolyC(P: Point, V: Point[]): { rtan: number; ltan: number } {\n        // Rtangent_PointPolyC and Ltangent_PointPolyC require polygon to be\n        // \"closed\" with the first vertex duplicated at end, so V[n-1] = V[0].\n        let Vclosed = V.slice(0);  // Copy V\n        Vclosed.push(V[0]);        // Add V[0] at end\n\n        return { rtan: Rtangent_PointPolyC(P, Vclosed), ltan: Ltangent_PointPolyC(P, Vclosed) };\n    }\n\n\n    // Rtangent_PointPolyC(): binary search for convex polygon right tangent\n    //    Input:  P = a 2D point (exterior to the polygon)\n    //            n = number of polygon vertices\n    //            V = array of vertices for a 2D convex polygon with first\n    //                vertex duplicated as last, so V[n-1] = V[0]\n    //    Return: index \"i\" of rightmost tangent point V[i]\n    function Rtangent_PointPolyC(P: Point, V: Point[]): number {\n        var n = V.length - 1;\n\n        // use binary search for large convex polygons\n        var a: number, b: number, c: number;            // indices for edge chain endpoints\n        var upA: boolean, dnC: boolean;           // test for up direction of edges a and c\n\n        // rightmost tangent = maximum for the isLeft() ordering\n        // test if V[0] is a local maximum\n        if (below(P, V[1], V[0]) && !above(P, V[n - 1], V[0]))\n            return 0;               // V[0] is the maximum tangent point\n\n        for (a = 0, b = n; ;) {          // start chain = [0,n] with V[n]=V[0]\n            if (b - a === 1)\n                if (above(P, V[a], V[b]))\n                    return a;\n                else\n                    return b;\n\n            c = Math.floor((a + b) / 2);        // midpoint of [a,b], and 0<c<n\n            dnC = below(P, V[c + 1], V[c]);\n            if (dnC && !above(P, V[c - 1], V[c]))\n                return c;          // V[c] is the maximum tangent point\n\n            // no max yet, so continue with the binary search\n            // pick one of the two subchains [a,c] or [c,b]\n            upA = above(P, V[a + 1], V[a]);\n            if (upA) {                       // edge a points up\n                if (dnC)                         // edge c points down\n                    b = c;                           // select [a,c]\n                else {                           // edge c points up\n                    if (above(P, V[a], V[c]))     // V[a] above V[c]\n                        b = c;                       // select [a,c]\n                    else                          // V[a] below V[c]\n                        a = c;                       // select [c,b]\n                }\n            }\n            else {                           // edge a points down\n                if (!dnC)                        // edge c points up\n                    a = c;                           // select [c,b]\n                else {                           // edge c points down\n                    if (below(P, V[a], V[c]))     // V[a] below V[c]\n                        b = c;                       // select [a,c]\n                    else                          // V[a] above V[c]\n                        a = c;                       // select [c,b]\n                }\n            }\n        }\n    }\n\n    // Ltangent_PointPolyC(): binary search for convex polygon left tangent\n    //    Input:  P = a 2D point (exterior to the polygon)\n    //            n = number of polygon vertices\n    //            V = array of vertices for a 2D convex polygon with first\n    //                vertex duplicated as last, so V[n-1] = V[0]\n    //    Return: index \"i\" of leftmost tangent point V[i]\n    function Ltangent_PointPolyC(P: Point, V: Point[]): number {\n        var n = V.length - 1;\n        // use binary search for large convex polygons\n        var a: number, b: number, c: number;             // indices for edge chain endpoints\n        var dnA: boolean, dnC: boolean;           // test for down direction of edges a and c\n\n        // leftmost tangent = minimum for the isLeft() ordering\n        // test if V[0] is a local minimum\n        if (above(P, V[n - 1], V[0]) && !below(P, V[1], V[0]))\n            return 0;               // V[0] is the minimum tangent point\n\n        for (a = 0, b = n; ;) {          // start chain = [0,n] with V[n] = V[0]\n            if (b - a === 1)\n                if (below(P, V[a], V[b]))\n                    return a;\n                else\n                    return b;\n\n            c = Math.floor((a + b) / 2);        // midpoint of [a,b], and 0<c<n\n            dnC = below(P, V[c + 1], V[c]);\n            if (above(P, V[c - 1], V[c]) && !dnC)\n                return c;          // V[c] is the minimum tangent point\n\n            // no min yet, so continue with the binary search\n            // pick one of the two subchains [a,c] or [c,b]\n            dnA = below(P, V[a + 1], V[a]);\n            if (dnA) {                       // edge a points down\n                if (!dnC)                        // edge c points up\n                    b = c;                           // select [a,c]\n                else {                           // edge c points down\n                    if (below(P, V[a], V[c]))     // V[a] below V[c]\n                        b = c;                       // select [a,c]\n                    else                          // V[a] above V[c]\n                        a = c;                       // select [c,b]\n                }\n            }\n            else {                           // edge a points up\n                if (dnC)                         // edge c points down\n                    a = c;                           // select [c,b]\n                else {                           // edge c points up\n                    if (above(P, V[a], V[c]))     // V[a] above V[c]\n                        b = c;                       // select [a,c]\n                    else                          // V[a] below V[c]\n                        a = c;                       // select [c,b]\n                }\n            }\n        }\n    }\n\n    // RLtangent_PolyPolyC(): get the RL tangent between two convex polygons\n    //    Input:  m = number of vertices in polygon 1\n    //            V = array of vertices for convex polygon 1 with V[m]=V[0]\n    //            n = number of vertices in polygon 2\n    //            W = array of vertices for convex polygon 2 with W[n]=W[0]\n    //    Output: *t1 = index of tangent point V[t1] for polygon 1\n    //            *t2 = index of tangent point W[t2] for polygon 2\n    export function tangent_PolyPolyC(V: Point[], W: Point[], t1: (a: Point, b: Point[]) => number, t2: (a: Point, b: Point[]) => number, cmp1: (a: Point, b: Point, c: Point) => boolean, cmp2: (a: Point, b: Point, c: Point) => boolean): { t1: number; t2: number } {\n        var ix1: number, ix2: number;      // search indices for polygons 1 and 2\n\n        // first get the initial vertex on each polygon\n        ix1 = t1(W[0], V);   // right tangent from W[0] to V\n        ix2 = t2(V[ix1], W); // left tangent from V[ix1] to W\n\n        // ping-pong linear search until it stabilizes\n        var done = false;                    // flag when done\n        while (!done) {\n            done = true;                     // assume done until...\n            while (true) {\n                if (ix1 === V.length - 1) ix1 = 0;\n                if (cmp1(W[ix2], V[ix1], V[ix1 + 1])) break;\n                ++ix1;                       // get Rtangent from W[ix2] to V\n            }\n            while (true) {\n                if (ix2 === 0) ix2 = W.length - 1;\n                if (cmp2(V[ix1], W[ix2], W[ix2 - 1])) break;\n                --ix2;                       // get Ltangent from V[ix1] to W\n                done = false;                // not done if had to adjust this\n            }\n        }\n        return { t1: ix1, t2: ix2 };\n    }\n\n    export function LRtangent_PolyPolyC(V: Point[], W: Point[]): { t1: number; t2: number } {\n        var rl = RLtangent_PolyPolyC(W, V);\n        return { t1: rl.t2, t2: rl.t1 };\n    }\n\n    export function RLtangent_PolyPolyC(V: Point[], W: Point[]): { t1: number; t2: number } {\n        return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Ltangent_PointPolyC, above, below);\n    }\n\n    export function LLtangent_PolyPolyC(V: Point[], W: Point[]): { t1: number; t2: number } {\n        return tangent_PolyPolyC(V, W, Ltangent_PointPolyC, Ltangent_PointPolyC, below, below);\n    }\n\n    export function RRtangent_PolyPolyC(V: Point[], W: Point[]): { t1: number; t2: number } {\n        return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Rtangent_PointPolyC, above, above);\n    }\n\n    export class BiTangent {\n        constructor(public t1: number, public t2: number) { }\n    }\n\n    export class BiTangents {\n        rl: BiTangent;\n        lr: BiTangent;\n        ll: BiTangent;\n        rr: BiTangent;\n    }\n\n    export class TVGPoint extends Point {\n        vv: VisibilityVertex;\n    }\n\n    export class VisibilityVertex {\n        constructor(\n            public id: number,\n            public polyid: number,\n            public polyvertid: number,\n            public p: TVGPoint)\n        {\n            p.vv = this;\n        }\n    }\n\n    export class VisibilityEdge {\n        constructor(\n            public source: VisibilityVertex,\n            public target: VisibilityVertex) { }\n        length(): number {\n            var dx = this.source.p.x - this.target.p.x;\n            var dy = this.source.p.y - this.target.p.y;\n            return Math.sqrt(dx * dx + dy * dy);\n        }\n    }\n\n    export class TangentVisibilityGraph {\n        V: VisibilityVertex[] = [];\n        E: VisibilityEdge[] = [];\n        constructor(public P: TVGPoint[][], g0?: { V: VisibilityVertex[]; E: VisibilityEdge[] }) {\n            if (!g0) {\n                var n = P.length;\n                // For each node...\n                for (var i = 0; i < n; i++) {\n                    var p = P[i];\n                    // For each node vertex.\n                    for (var j = 0; j < p.length; ++j) {\n                        var pj = p[j],\n                            vv = new VisibilityVertex(this.V.length, i, j, pj);\n                        this.V.push(vv);\n                        // For the every iteration but the first, generate an\n                        // edge from the previous visibility vertex to the\n                        // current one.\n                        if (j > 0) this.E.push(new VisibilityEdge(p[j - 1].vv, vv));\n                    }\n                    // Add a visibility edge from the first vertex to the last.\n                    if (p.length > 1) this.E.push(new VisibilityEdge(p[0].vv, p[p.length - 1].vv));\n                }\n                for (var i = 0; i < n - 1; i++) {\n                    var Pi = P[i];\n                    for (var j = i + 1; j < n; j++) {\n                        var Pj = P[j],\n                            t = tangents(Pi, Pj);\n                        for (var q in t) {\n                            var c = t[q],\n                                source = Pi[c.t1], target = Pj[c.t2];\n                            this.addEdgeIfVisible(source, target, i, j);\n                        }\n                    }\n                }\n            } else {\n                this.V = g0.V.slice(0);\n                this.E = g0.E.slice(0);\n            }\n        }\n        addEdgeIfVisible(u: TVGPoint, v: TVGPoint, i1: number, i2: number) {\n            if (!this.intersectsPolys(new LineSegment(u.x, u.y, v.x, v.y), i1, i2)) {\n                this.E.push(new VisibilityEdge(u.vv, v.vv));\n            }\n        }\n        addPoint(p: TVGPoint, i1: number): VisibilityVertex {\n            var n = this.P.length;\n            this.V.push(new VisibilityVertex(this.V.length, n, 0, p));\n            for (var i = 0; i < n; ++i) {\n                if (i === i1) continue;\n                var poly = this.P[i],\n                    t = tangent_PointPolyC(p, poly);\n                this.addEdgeIfVisible(p, poly[t.ltan], i1, i);\n                this.addEdgeIfVisible(p, poly[t.rtan], i1, i);\n            }\n            return p.vv;\n        }\n        private intersectsPolys(l: LineSegment, i1: number, i2: number): boolean {\n            for (var i = 0, n = this.P.length; i < n; ++i) {\n                if (i != i1 && i != i2 && intersects(l, this.P[i]).length > 0) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    function intersects(l: LineSegment, P: Point[]) {\n        var ints = [];\n        for (var i = 1, n = P.length; i < n; ++i) {\n            var int = Rectangle.lineIntersection(\n                l.x1, l.y1,\n                l.x2, l.y2,\n                P[i - 1].x, P[i - 1].y,\n                P[i].x, P[i].y\n                );\n            if (int) ints.push(int);\n        }\n        return ints;\n    }\n\n    export function tangents(V: Point[], W: Point[]): BiTangents\n    {\n        var m = V.length - 1, n = W.length - 1;\n        var bt = new BiTangents();\n        for (var i = 0; i <= m; ++i) {\n            for (var j = 0; j <= n; ++j) {\n                var v1 = V[i == 0 ? m : i - 1];\n                var v2 = V[i];\n                var v3 = V[i == m ? 0 : i + 1];\n                var w1 = W[j == 0 ? n : j - 1];\n                var w2 = W[j];\n                var w3 = W[j == n ? 0 : j + 1];\n                var v1v2w2 = isLeft(v1, v2, w2);\n                var v2w1w2 = isLeft(v2, w1, w2);\n                var v2w2w3 = isLeft(v2, w2, w3);\n                var w1w2v2 = isLeft(w1, w2, v2);\n                var w2v1v2 = isLeft(w2, v1, v2);\n                var w2v2v3 = isLeft(w2, v2, v3);\n                if (v1v2w2 >= 0 && v2w1w2 >= 0 && v2w2w3 < 0\n                    && w1w2v2 >= 0 && w2v1v2 >= 0 && w2v2v3 < 0) {\n                        bt.ll = new BiTangent(i, j);\n                } else if (v1v2w2 <= 0 && v2w1w2 <= 0 && v2w2w3 > 0\n                    && w1w2v2 <= 0 && w2v1v2 <= 0 && w2v2v3 > 0) {\n                        bt.rr = new BiTangent(i, j);\n                } else if (v1v2w2 <= 0 && v2w1w2 > 0 && v2w2w3 <= 0\n                    && w1w2v2 >= 0 && w2v1v2 < 0 && w2v2v3 >= 0) {\n                        bt.rl = new BiTangent(i, j);\n                } else if (v1v2w2 >= 0 && v2w1w2 < 0 && v2w2w3 >= 0\n                    && w1w2v2 <= 0 && w2v1v2 > 0 && w2v2v3 <= 0) {\n                        bt.lr = new BiTangent(i, j);\n                }\n            }\n        }\n        return bt;\n    }\n\n    function isPointInsidePoly(p: Point, poly: Point[]): boolean {\n        for (var i = 1, n = poly.length; i < n; ++i)\n            if (below(poly[i - 1], poly[i], p)) return false;\n        return true;\n    }\n\n    function isAnyPInQ(p: Point[], q: Point[]): boolean {\n        return !p.every(v => !isPointInsidePoly(v, q));\n    }\n\n    export function polysOverlap(p: Point[], q: Point[]): boolean {\n        if (isAnyPInQ(p, q)) return true;\n        if (isAnyPInQ(q, p)) return true;\n        for (var i = 1, n = p.length; i < n; ++i) {\n            var v = p[i], u = p[i - 1];\n            if (intersects(new LineSegment(u.x, u.y, v.x, v.y), q).length > 0) return true;\n        }\n        return false;\n    }\n","    var packingOptions = {\n        PADDING: 10,\n        GOLDEN_SECTION: (1 + Math.sqrt(5)) / 2,\n        FLOAT_EPSILON: 0.0001,\n        MAX_INERATIONS: 100\n    };\n\n    // assign x, y to nodes while using box packing algorithm for disconnected graphs\n    export function applyPacking(graphs:Array<any>, w, h, node_size, desired_ratio = 1, centerGraph = true) {\n\n        var init_x = 0,\n            init_y = 0,\n\n            svg_width = w,\n            svg_height = h,\n\n            desired_ratio = typeof desired_ratio !== 'undefined' ? desired_ratio : 1,\n            node_size = typeof node_size !== 'undefined' ? node_size : 0,\n\n            real_width = 0,\n            real_height = 0,\n            min_width = 0,\n\n            global_bottom = 0,\n            line = [];\n\n        if (graphs.length == 0)\n            return;\n\n        /// that would take care of single nodes problem\n        // graphs.forEach(function (g) {\n        //     if (g.array.length == 1) {\n        //         g.array[0].x = 0;\n        //         g.array[0].y = 0;\n        //     }\n        // });\n\n        calculate_bb(graphs);\n        apply(graphs, desired_ratio);\n        if(centerGraph) {\n            put_nodes_to_right_positions(graphs);\n        }\n\n        // get bounding boxes for all separate graphs\n        function calculate_bb(graphs) {\n\n            graphs.forEach(function (g) {\n                calculate_single_bb(g)\n            });\n\n            function calculate_single_bb(graph) {\n                var min_x = Number.MAX_VALUE, min_y = Number.MAX_VALUE,\n                    max_x = 0, max_y = 0;\n\n                graph.array.forEach(function (v) {\n                    var w = typeof v.width !== 'undefined' ? v.width : node_size;\n                    var h = typeof v.height !== 'undefined' ? v.height : node_size;\n                    w /= 2;\n                    h /= 2;\n                    max_x = Math.max(v.x + w, max_x);\n                    min_x = Math.min(v.x - w, min_x);\n                    max_y = Math.max(v.y + h, max_y);\n                    min_y = Math.min(v.y - h, min_y);\n                });\n\n                graph.width = max_x - min_x;\n                graph.height = max_y - min_y;\n            }\n        }\n\n        //function plot(data, left, right, opt_x, opt_y) {\n        //    // plot the cost function\n        //    var plot_svg = d3.select(\"body\").append(\"svg\")\n        //        .attr(\"width\", function () { return 2 * (right - left); })\n        //        .attr(\"height\", 200);\n\n\n        //    var x = d3.time.scale().range([0, 2 * (right - left)]);\n\n        //    var xAxis = d3.svg.axis().scale(x).orient(\"bottom\");\n        //    plot_svg.append(\"g\").attr(\"class\", \"x axis\")\n        //        .attr(\"transform\", \"translate(0, 199)\")\n        //        .call(xAxis);\n\n        //    var lastX = 0;\n        //    var lastY = 0;\n        //    var value = 0;\n        //    for (var r = left; r < right; r += 1) {\n        //        value = step(data, r);\n        //        // value = 1;\n\n        //        plot_svg.append(\"line\").attr(\"x1\", 2 * (lastX - left))\n        //            .attr(\"y1\", 200 - 30 * lastY)\n        //            .attr(\"x2\", 2 * r - 2 * left)\n        //            .attr(\"y2\", 200 - 30 * value)\n        //            .style(\"stroke\", \"rgb(6,120,155)\");\n\n        //        lastX = r;\n        //        lastY = value;\n        //    }\n\n        //    plot_svg.append(\"circle\").attr(\"cx\", 2 * opt_x - 2 * left).attr(\"cy\", 200 - 30 * opt_y)\n        //        .attr(\"r\", 5).style('fill', \"rgba(0,0,0,0.5)\");\n\n        //}\n\n        // actual assigning of position to nodes\n        function put_nodes_to_right_positions(graphs) {\n            graphs.forEach(function (g) {\n                // calculate current graph center:\n                var center = { x: 0, y: 0 };\n\n                g.array.forEach(function (node) {\n                    center.x += node.x;\n                    center.y += node.y;\n                });\n\n                center.x /= g.array.length;\n                center.y /= g.array.length;\n\n                // calculate current top left corner:\n                var corner = { x: center.x - g.width / 2, y: center.y - g.height / 2 };\n                var offset = { x: g.x - corner.x + svg_width / 2 - real_width / 2, y: g.y - corner.y + svg_height / 2 - real_height / 2};\n\n                // put nodes:\n                g.array.forEach(function (node) {\n                    node.x += offset.x;\n                    node.y += offset.y;\n                });\n            });\n        }\n\n        // starts box packing algorithm\n        // desired ratio is 1 by default\n        function apply(data, desired_ratio) {\n            var curr_best_f = Number.POSITIVE_INFINITY;\n            var curr_best = 0;\n            data.sort(function (a, b) { return b.height - a.height; });\n\n            min_width = data.reduce(function (a, b) {\n                return a.width < b.width ? a.width : b.width;\n            });\n\n            var left = x1 = min_width;\n            var right = x2 = get_entire_width(data);\n            var iterationCounter = 0;\n\n            var f_x1 = Number.MAX_VALUE;\n            var f_x2 = Number.MAX_VALUE;\n            var flag = -1; // determines which among f_x1 and f_x2 to recompute\n\n\n            var dx = Number.MAX_VALUE;\n            var df = Number.MAX_VALUE;\n\n            while ((dx > min_width) || df > packingOptions.FLOAT_EPSILON) {\n\n                if (flag != 1) {\n                    var x1 = right - (right - left) / packingOptions.GOLDEN_SECTION;\n                    var f_x1 = step(data, x1);\n                }\n                if (flag != 0) {\n                    var x2 = left + (right - left) / packingOptions.GOLDEN_SECTION;\n                    var f_x2 = step(data, x2);\n                }\n\n                dx = Math.abs(x1 - x2);\n                df = Math.abs(f_x1 - f_x2);\n\n                if (f_x1 < curr_best_f) {\n                    curr_best_f = f_x1;\n                    curr_best = x1;\n                }\n\n                if (f_x2 < curr_best_f) {\n                    curr_best_f = f_x2;\n                    curr_best = x2;\n                }\n\n                if (f_x1 > f_x2) {\n                    left = x1;\n                    x1 = x2;\n                    f_x1 = f_x2;\n                    flag = 1;\n                } else {\n                    right = x2;\n                    x2 = x1;\n                    f_x2 = f_x1;\n                    flag = 0;\n                }\n\n                if (iterationCounter++ > 100) {\n                    break;\n                }\n            }\n            // plot(data, min_width, get_entire_width(data), curr_best, curr_best_f);\n            step(data, curr_best);\n        }\n\n        // one iteration of the optimization method\n        // (gives a proper, but not necessarily optimal packing)\n        function step(data, max_width) {\n            line = [];\n            real_width = 0;\n            real_height = 0;\n            global_bottom = init_y;\n\n            for (var i = 0; i < data.length; i++) {\n                var o = data[i];\n                put_rect(o, max_width);\n            }\n\n            return Math.abs(get_real_ratio() - desired_ratio);\n        }\n\n        // looking for a position to one box\n        function put_rect(rect, max_width) {\n\n\n            var parent = undefined;\n\n            for (var i = 0; i < line.length; i++) {\n                if ((line[i].space_left >= rect.height) && (line[i].x + line[i].width + rect.width + packingOptions.PADDING - max_width) <= packingOptions.FLOAT_EPSILON) {\n                    parent = line[i];\n                    break;\n                }\n            }\n\n            line.push(rect);\n\n            if (parent !== undefined) {\n                rect.x = parent.x + parent.width + packingOptions.PADDING;\n                rect.y = parent.bottom;\n                rect.space_left = rect.height;\n                rect.bottom = rect.y;\n                parent.space_left -= rect.height + packingOptions.PADDING;\n                parent.bottom += rect.height + packingOptions.PADDING;\n            } else {\n                rect.y = global_bottom;\n                global_bottom += rect.height + packingOptions.PADDING;\n                rect.x = init_x;\n                rect.bottom = rect.y;\n                rect.space_left = rect.height;\n            }\n\n            if (rect.y + rect.height - real_height > -packingOptions.FLOAT_EPSILON) real_height = rect.y + rect.height - init_y;\n            if (rect.x + rect.width - real_width > -packingOptions.FLOAT_EPSILON) real_width = rect.x + rect.width - init_x;\n        };\n\n        function get_entire_width(data) {\n            var width = 0;\n            data.forEach(function (d) { return width += d.width + packingOptions.PADDING; });\n            return width;\n        }\n\n        function get_real_ratio() {\n            return (real_width / real_height);\n        }\n    }\n\n    /**\n     * connected components of graph\n     * returns an array of {}\n     */\n    export function separateGraphs(nodes, links) {\n        var marks = {};\n        var ways = {};\n        var graphs = [];\n        var clusters = 0;\n\n        for (var i = 0; i < links.length; i++) {\n            var link = links[i];\n            var n1 = link.source;\n            var n2 = link.target;\n            if (ways[n1.index])\n                ways[n1.index].push(n2);\n            else\n                ways[n1.index] = [n2];\n\n            if (ways[n2.index])\n                ways[n2.index].push(n1);\n            else\n                ways[n2.index] = [n1];\n        }\n\n        for (var i = 0; i < nodes.length; i++) {\n            var node = nodes[i];\n            if (marks[node.index]) continue;\n            explore_node(node, true);\n        }\n\n        function explore_node(n, is_new) {\n            if (marks[n.index] !== undefined) return;\n            if (is_new) {\n                clusters++;\n                graphs.push({ array: [] });\n            }\n            marks[n.index] = clusters;\n            graphs[clusters - 1].array.push(n);\n            var adjacent = ways[n.index];\n            if (!adjacent) return;\n\n            for (var j = 0; j < adjacent.length; j++) {\n                explore_node(adjacent[j], false);\n            }\n        }\n\n        return graphs;\n    }\n","let wasm; export async function setWasm(wasmModule) { const inst = await WebAssembly.instantiate(wasmModule, { \"./derivative_computer_bg.js\": { __wbindgen_memory } }); wasm = inst.exports; } export function getWasm() { return wasm; }\nexport function __wbg_set_wasm(val) {\n    wasm = val;\n}\n\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n/**\n* @param {number} ctx_ptr\n*/\nexport function release_ctx_2d(ctx_ptr) {\n    wasm.release_ctx_2d(ctx_ptr);\n}\n\nlet cachedFloat32Memory0 = null;\n\nfunction getFloat32Memory0() {\n    if (cachedFloat32Memory0 === null || cachedFloat32Memory0.byteLength === 0) {\n        cachedFloat32Memory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachedFloat32Memory0;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArrayF32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getFloat32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n* @param {number} node_count\n* @param {Float32Array} D\n* @param {Float32Array} G\n* @returns {number}\n*/\nexport function create_derivative_computer_ctx_2d(node_count, D, G) {\n    const ptr0 = passArrayF32ToWasm0(D, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArrayF32ToWasm0(G, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    const ret = wasm.create_derivative_computer_ctx_2d(node_count, ptr0, len0, ptr1, len1);\n    return ret;\n}\n\n/**\n* @param {number} node_count\n* @param {Float32Array} D\n* @param {Float32Array} G\n* @returns {number}\n*/\nexport function create_derivative_computer_ctx_3d(node_count, D, G) {\n    const ptr0 = passArrayF32ToWasm0(D, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArrayF32ToWasm0(G, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    const ret = wasm.create_derivative_computer_ctx_3d(node_count, ptr0, len0, ptr1, len1);\n    return ret;\n}\n\nlet cachedInt32Memory0 = null;\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nfunction getArrayF32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getFloat32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n/**\n* @param {number} ctx_ptr\n* @param {Float32Array} x\n* @returns {Float32Array}\n*/\nexport function compute_2d(ctx_ptr, x) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passArrayF32ToWasm0(x, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.compute_2d(retptr, ctx_ptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v2 = getArrayF32FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 4);\n        return v2;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {number} ctx_ptr\n* @param {Float32Array} x\n* @returns {Float32Array}\n*/\nexport function compute_3d(ctx_ptr, x) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passArrayF32ToWasm0(x, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.compute_3d(retptr, ctx_ptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v2 = getArrayF32FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 4);\n        return v2;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {number} ctx_ptr\n* @param {number} u\n* @param {number} p_0\n* @param {number} p_1\n* @param {number} x_0_u\n* @param {number} x_1_u\n*/\nexport function apply_lock_2d(ctx_ptr, u, p_0, p_1, x_0_u, x_1_u) {\n    wasm.apply_lock_2d(ctx_ptr, u, p_0, p_1, x_0_u, x_1_u);\n}\n\n/**\n* @param {number} ctx_ptr\n* @param {number} u\n* @param {number} p_0\n* @param {number} p_1\n* @param {number} p_2\n* @param {number} x_0_u\n* @param {number} x_1_u\n* @param {number} x_2_u\n*/\nexport function apply_lock_3d(ctx_ptr, u, p_0, p_1, p_2, x_0_u, x_1_u, x_2_u) {\n    wasm.apply_lock_3d(ctx_ptr, u, p_0, p_1, p_2, x_0_u, x_1_u, x_2_u);\n}\n\n/**\n* @param {number} ctx_ptr\n* @returns {number}\n*/\nexport function compute_step_size_2d(ctx_ptr) {\n    const ret = wasm.compute_step_size_2d(ctx_ptr);\n    return ret;\n}\n\n/**\n* @param {number} ctx_ptr\n* @returns {number}\n*/\nexport function compute_step_size_3d(ctx_ptr) {\n    const ret = wasm.compute_step_size_3d(ctx_ptr);\n    return ret;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n/**\n* @returns {any}\n*/\nexport function get_memory() {\n    const ret = wasm.get_memory();\n    return takeObject(ret);\n}\n\n/**\n* @param {number} ctx\n* @returns {number}\n*/\nexport function get_D_2d(ctx) {\n    const ret = wasm.get_D_2d(ctx);\n    return ret;\n}\n\n/**\n* @param {number} ctx\n* @returns {number}\n*/\nexport function get_D_3d(ctx) {\n    const ret = wasm.get_D_3d(ctx);\n    return ret;\n}\n\n/**\n* @param {number} ctx\n* @returns {number}\n*/\nexport function get_g_2d(ctx) {\n    const ret = wasm.get_g_2d(ctx);\n    return ret;\n}\n\n/**\n* @param {number} ctx\n* @returns {number}\n*/\nexport function get_g_3d(ctx) {\n    const ret = wasm.get_D_2d(ctx);\n    return ret;\n}\n\n/**\n* @param {number} ctx\n* @param {Float32Array} new_G\n*/\nexport function set_G_2d(ctx, new_G) {\n    const ptr0 = passArrayF32ToWasm0(new_G, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.set_G_2d(ctx, ptr0, len0);\n}\n\n/**\n* @param {number} ctx\n* @param {Float32Array} new_G\n*/\nexport function set_G_3d(ctx, new_G) {\n    const ptr0 = passArrayF32ToWasm0(new_G, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.set_G_3d(ctx, ptr0, len0);\n}\n\nexport function __wbindgen_memory() {\n    const ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\n","let wasm; export async function setWasm(wasmModule) { const inst = await WebAssembly.instantiate(wasmModule, { \"./derivative_computer_bg.js\": { __wbindgen_memory } }); wasm = inst.exports; } export function getWasm() { return wasm; }\nexport function __wbg_set_wasm(val) {\n    wasm = val;\n}\n\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n/**\n* @param {number} ctx_ptr\n*/\nexport function release_ctx_2d(ctx_ptr) {\n    wasm.release_ctx_2d(ctx_ptr);\n}\n\nlet cachedFloat32Memory0 = null;\n\nfunction getFloat32Memory0() {\n    if (cachedFloat32Memory0 === null || cachedFloat32Memory0.byteLength === 0) {\n        cachedFloat32Memory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachedFloat32Memory0;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArrayF32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getFloat32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n* @param {number} node_count\n* @param {Float32Array} D\n* @param {Float32Array} G\n* @returns {number}\n*/\nexport function create_derivative_computer_ctx_2d(node_count, D, G) {\n    const ptr0 = passArrayF32ToWasm0(D, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArrayF32ToWasm0(G, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    const ret = wasm.create_derivative_computer_ctx_2d(node_count, ptr0, len0, ptr1, len1);\n    return ret;\n}\n\n/**\n* @param {number} node_count\n* @param {Float32Array} D\n* @param {Float32Array} G\n* @returns {number}\n*/\nexport function create_derivative_computer_ctx_3d(node_count, D, G) {\n    const ptr0 = passArrayF32ToWasm0(D, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArrayF32ToWasm0(G, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    const ret = wasm.create_derivative_computer_ctx_3d(node_count, ptr0, len0, ptr1, len1);\n    return ret;\n}\n\nlet cachedInt32Memory0 = null;\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nfunction getArrayF32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getFloat32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n/**\n* @param {number} ctx_ptr\n* @param {Float32Array} x\n* @returns {Float32Array}\n*/\nexport function compute_2d(ctx_ptr, x) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passArrayF32ToWasm0(x, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.compute_2d(retptr, ctx_ptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v2 = getArrayF32FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 4);\n        return v2;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {number} ctx_ptr\n* @param {Float32Array} x\n* @returns {Float32Array}\n*/\nexport function compute_3d(ctx_ptr, x) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passArrayF32ToWasm0(x, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.compute_3d(retptr, ctx_ptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v2 = getArrayF32FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 4);\n        return v2;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {number} ctx_ptr\n* @param {number} u\n* @param {number} p_0\n* @param {number} p_1\n* @param {number} x_0_u\n* @param {number} x_1_u\n*/\nexport function apply_lock_2d(ctx_ptr, u, p_0, p_1, x_0_u, x_1_u) {\n    wasm.apply_lock_2d(ctx_ptr, u, p_0, p_1, x_0_u, x_1_u);\n}\n\n/**\n* @param {number} ctx_ptr\n* @param {number} u\n* @param {number} p_0\n* @param {number} p_1\n* @param {number} p_2\n* @param {number} x_0_u\n* @param {number} x_1_u\n* @param {number} x_2_u\n*/\nexport function apply_lock_3d(ctx_ptr, u, p_0, p_1, p_2, x_0_u, x_1_u, x_2_u) {\n    wasm.apply_lock_3d(ctx_ptr, u, p_0, p_1, p_2, x_0_u, x_1_u, x_2_u);\n}\n\n/**\n* @param {number} ctx_ptr\n* @returns {number}\n*/\nexport function compute_step_size_2d(ctx_ptr) {\n    const ret = wasm.compute_step_size_2d(ctx_ptr);\n    return ret;\n}\n\n/**\n* @param {number} ctx_ptr\n* @returns {number}\n*/\nexport function compute_step_size_3d(ctx_ptr) {\n    const ret = wasm.compute_step_size_3d(ctx_ptr);\n    return ret;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n/**\n* @returns {any}\n*/\nexport function get_memory() {\n    const ret = wasm.get_memory();\n    return takeObject(ret);\n}\n\n/**\n* @param {number} ctx\n* @returns {number}\n*/\nexport function get_D_2d(ctx) {\n    const ret = wasm.get_D_2d(ctx);\n    return ret;\n}\n\n/**\n* @param {number} ctx\n* @returns {number}\n*/\nexport function get_D_3d(ctx) {\n    const ret = wasm.get_D_3d(ctx);\n    return ret;\n}\n\n/**\n* @param {number} ctx\n* @returns {number}\n*/\nexport function get_g_2d(ctx) {\n    const ret = wasm.get_g_2d(ctx);\n    return ret;\n}\n\n/**\n* @param {number} ctx\n* @returns {number}\n*/\nexport function get_g_3d(ctx) {\n    const ret = wasm.get_D_2d(ctx);\n    return ret;\n}\n\n/**\n* @param {number} ctx\n* @param {Float32Array} new_G\n*/\nexport function set_G_2d(ctx, new_G) {\n    const ptr0 = passArrayF32ToWasm0(new_G, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.set_G_2d(ctx, ptr0, len0);\n}\n\n/**\n* @param {number} ctx\n* @param {Float32Array} new_G\n*/\nexport function set_G_3d(ctx, new_G) {\n    const ptr0 = passArrayF32ToWasm0(new_G, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.set_G_3d(ctx, ptr0, len0);\n}\n\nexport function __wbindgen_memory() {\n    const ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\n","import * as powergraph from './powergraph'\nimport {LinkLengthAccessor, symmetricDiffLinkLengths, jaccardLinkLengths, generateDirectedEdgeConstraints} from './linklengths'\nimport {Descent} from './descent'\nimport {Rectangle, Projection, makeEdgeTo, makeEdgeBetween} from './rectangle'\nimport {Calculator} from './shortestpaths'\nimport {TangentVisibilityGraph, TVGPoint} from './geom'\nimport {separateGraphs, applyPacking} from './handledisconnected'\nimport { getDerivativeComputerWasm } from './wasmEngine'\n\n// Kick this off right away since we're going to need it eventually\nconst wasmInstPromise = getDerivativeComputerWasm();\n\n    /**\n     * The layout process fires three events:\n     *  - start: layout iterations started\n     *  - tick: fired once per iteration, listen to this to animate\n     *  - end: layout converged, you might like to zoom-to-fit or something at notification of this event\n     */\n    export enum EventType { start, tick, end };\n    export interface Event {\n        type: EventType;\n        alpha: number;\n        stress?: number;\n        listener?: () => void;\n    }\n    export interface InputNode {\n        /**\n         * index in nodes array, this is initialized by Layout.start()\n         */\n        index?: number;\n        /**\n         * x and y will be computed by layout as the Node's centroid\n         */\n        x?: number;\n        /**\n         * x and y will be computed by layout as the Node's centroid\n         */\n        y?: number;\n        /**\n         * specify a width and height of the node's bounding box if you turn on avoidOverlaps\n         */\n        width?: number;\n        /**\n         * specify a width and height of the node's bounding box if you turn on avoidOverlaps\n         */\n        height?: number;\n        /**\n         * selective bit mask.  !=0 means layout will not move.\n         */\n        fixed?: number;\n    }\n    export interface Node extends InputNode {\n      // Client-passed node may be missing these properties, which will be set\n      // upon ingestion\n      x: number;\n      y: number;\n    }\n\n    export interface Group {\n        bounds?: Rectangle;\n        leaves?: Node[];\n        groups?: Group[];\n        padding?: number;\n    }\n\n    function isGroup(g: any): g is Group {\n        return typeof g.leaves !== 'undefined' || typeof g.groups !== 'undefined';\n    }\n\n    export interface Link<NodeRefType> {\n        source: NodeRefType;\n        target: NodeRefType;\n\n        // ideal length the layout should try to achieve for this link\n        length?: number;\n\n        // how hard we should try to satisfy this link's ideal length\n        // must be in the range: 0 < weight <= 1\n        // if unspecified 1 is the default\n        weight?: number;\n    }\n\n    export type LinkNumericPropertyAccessor = (t: Link<Node | number>) => number;\n\n    export interface LinkLengthTypeAccessor extends LinkLengthAccessor<Link<Node | number>> {\n        getType: LinkNumericPropertyAccessor;\n    }\n    /**\n     * Main interface to cola layout.\n     * @class Layout\n     */\n    export class Layout {\n        private _canvasSize = [1, 1];\n        private _linkDistance: number | LinkNumericPropertyAccessor = 20;\n        private _defaultNodeSize: number = 10;\n        private _linkLengthCalculator = null;\n        private _linkType = null;\n        private _avoidOverlaps = false;\n        private _handleDisconnected = true;\n        private _alpha;\n        private _lastStress;\n        private _running = false;\n        private _nodes = [];\n        private _groups = [];\n        private _rootGroup = null;\n        private _links: Link<Node | number>[] = [];\n        private _constraints = [];\n        private _distanceMatrix = null;\n        private _descent: Descent = null;\n        private _directedLinkConstraints = null;\n        private _threshold = 0.01;\n        private _visibilityGraph = null;\n        private _groupCompactness = 1e-6;\n\n        // sub-class and override this property to replace with a more sophisticated eventing mechanism\n        protected event = null;\n\n        // subscribe a listener to an event\n        // sub-class and override this method to replace with a more sophisticated eventing mechanism\n        public on(e: EventType | string, listener: (event?: Event) => void): this {\n            // override me!\n            if (!this.event) this.event = {};\n            if (typeof e === 'string') {\n                this.event[EventType[e]] = listener;\n            } else {\n                this.event[e] = listener;\n            }\n            return this;\n        }\n\n        // a function that is notified of events like \"tick\"\n        // sub-classes can override this method to replace with a more sophisticated eventing mechanism\n        protected trigger(e: Event) {\n            if (this.event && typeof this.event[e.type] !== 'undefined') {\n                this.event[e.type](e);\n            }\n        }\n\n        // a function that kicks off the iteration tick loop\n        // it calls tick() repeatedly until tick returns true (is converged)\n        // subclass and override it with something fancier (e.g. dispatch tick on a timer)\n        protected kick(): void {\n            while (!this.tick());\n        }\n\n        /**\n         * iterate the layout.  Returns true when layout converged.\n         */\n        protected tick(): boolean {\n            if (this._alpha < this._threshold) {\n                this._running = false;\n                this.trigger({ type: EventType.end, alpha: this._alpha = 0, stress: this._lastStress });\n                return true;\n            }\n            const n = this._nodes.length,\n                  m = this._links.length;\n            let o, i;\n\n            this._descent.locks.clear();\n            for (i = 0; i < n; ++i) {\n                o = this._nodes[i];\n                if (o.fixed) {\n                    if (typeof o.px === 'undefined' || typeof o.py === 'undefined') {\n                        o.px = o.x;\n                        o.py = o.y;\n                    }\n                    var p = [o.px, o.py];\n                    this._descent.locks.add(i, p);\n                }\n            }\n\n            let s1 = this._descent.rungeKutta();\n            //var s1 = descent.reduceStress();\n            if (s1 === 0) {\n                this._alpha = 0;\n            } else if (typeof this._lastStress !== 'undefined') {\n                this._alpha = s1; //Math.abs(Math.abs(this._lastStress / s1) - 1);\n            }\n            this._lastStress = s1;\n\n            this.updateNodePositions();\n\n            this.trigger({ type: EventType.tick, alpha: this._alpha, stress: this._lastStress });\n            return false;\n        }\n\n        // copy positions out of descent instance into each of the nodes' center coords\n        private updateNodePositions(): void {\n            const x = this._descent.x[0], y = this._descent.x[1];\n            let o, i = this._nodes.length;\n            while (i--) {\n                o = this._nodes[i];\n                o.x = x[i];\n                o.y = y[i];\n            }\n        }\n\n        /**\n         * the list of nodes.\n         * If nodes has not been set, but links has, then we instantiate a nodes list here, of the correct size,\n         * before returning it.\n         * @property nodes {Array}\n         * @default empty list\n         */\n        nodes(): Array<Node>\n        nodes(v: Array<InputNode>): this\n        nodes(v?: any): any {\n            if (!v) {\n                if (this._nodes.length === 0 && this._links.length > 0) {\n                    // if we have links but no nodes, create the nodes array now with empty objects for the links to point at.\n                    // in this case the links are expected to be numeric indices for nodes in the range 0..n-1 where n is the number of nodes\n                    var n = 0;\n                    this._links.forEach(function (l) {\n                        n = Math.max(n, <number>l.source, <number>l.target);\n                    });\n                    this._nodes = new Array(++n);\n                    for (var i = 0; i < n; ++i) {\n                        this._nodes[i] = {};\n                    }\n                }\n                return this._nodes;\n            }\n            this._nodes = v;\n            return this;\n        }\n\n        /**\n         * a list of hierarchical groups defined over nodes\n         * @property groups {Array}\n         * @default empty list\n         */\n        groups(): Array<Group>\n        groups(x: Array<Group>): this\n        groups(x?: Array<Group>): any {\n            if (!x) return this._groups;\n            this._groups = x;\n            this._rootGroup = {};\n            this._groups.forEach(g => {\n                if (typeof g.padding === \"undefined\")\n                    g.padding = 1;\n                if (typeof g.leaves !== \"undefined\") {\n                    g.leaves.forEach((v, i) => {\n                        if (typeof v === 'number')\n                            (g.leaves[i] = this._nodes[v]).parent = g\n                    });\n                }\n                if (typeof g.groups !== \"undefined\") {\n                    g.groups.forEach((gi, i) => {\n                        if (typeof gi === 'number')\n                            (g.groups[i] = this._groups[gi]).parent = g\n                    });\n                }\n            });\n            this._rootGroup.leaves = this._nodes.filter(v => typeof v.parent === 'undefined');\n            this._rootGroup.groups = this._groups.filter(g => typeof g.parent === 'undefined');\n            return this;\n        }\n\n        powerGraphGroups(f: Function): this {\n            var g = powergraph.getGroups(this._nodes, this._links, this.linkAccessor, this._rootGroup);\n            this.groups(g.groups);\n            f(g);\n            return this;\n        }\n\n        /**\n         * if true, the layout will not permit overlaps of the node bounding boxes (defined by the width and height properties on nodes)\n         * @property avoidOverlaps\n         * @type bool\n         * @default false\n         */\n        avoidOverlaps(): boolean\n        avoidOverlaps(v: boolean): this\n        avoidOverlaps(v?: boolean): any {\n            if (!arguments.length) return this._avoidOverlaps;\n            this._avoidOverlaps = v;\n            return this;\n        }\n\n        /**\n         * if true, the final step of the start method will be to nicely pack connected components of the graph.\n         * works best if start() is called with a reasonable number of iterations specified and\n         * each node has a bounding box (defined by the width and height properties on nodes).\n         * @property handleDisconnected\n         * @type bool\n         * @default true\n         */\n        handleDisconnected(): boolean\n        handleDisconnected(v: boolean): this\n        handleDisconnected(v?: boolean): any {\n            if (!arguments.length) return this._handleDisconnected;\n            this._handleDisconnected = v;\n            return this;\n        }\n\n        /**\n         * causes constraints to be generated such that directed graphs are laid out either from left-to-right or top-to-bottom.\n         * a separation constraint is generated in the selected axis for each edge that is not involved in a cycle (part of a strongly connected component)\n         * @param axis {string} 'x' for left-to-right, 'y' for top-to-bottom\n         * @param minSeparation {number|link=>number} either a number specifying a minimum spacing required across all links or a function to return the minimum spacing for each link\n         */\n        flowLayout(axis: string, minSeparation: number|((t: any)=>number)): this {\n            if (!arguments.length) axis = 'y';\n            this._directedLinkConstraints = {\n                axis: axis,\n                getMinSeparation: typeof minSeparation === 'number' ? function () { return minSeparation } : minSeparation\n            };\n            return this;\n        }\n\n        /**\n         * links defined as source, target pairs over nodes\n         * @property links {array}\n         * @default empty list\n         */\n        links(): Array<Link<Node|number>>\n        links(x: Array<Link<Node|number>>): this\n        links(x?: Array<Link<Node|number>>): any {\n            if (!arguments.length) return this._links;\n            this._links = x;\n            return this;\n        }\n\n        /**\n         * list of constraints of various types\n         * @property constraints\n         * @type {array}\n         * @default empty list\n         */\n        constraints(): Array<any>\n        constraints(c: Array<any>): this\n        constraints(c?: Array<any>): any {\n            if (!arguments.length) return this._constraints;\n            this._constraints = c;\n            return this;\n        }\n\n        /**\n         * Matrix of ideal distances between all pairs of nodes.\n         * If unspecified, the ideal distances for pairs of nodes will be based on the shortest path distance between them.\n         * @property distanceMatrix\n         * @type {Array of Array of Number}\n         * @default null\n         */\n        distanceMatrix(): Array<Array<number>>\n        distanceMatrix(d: Array<Array<number>>): this\n        distanceMatrix(d?: any): any {\n            if (!arguments.length) return this._distanceMatrix;\n            this._distanceMatrix = d;\n            return this;\n        }\n\n        /**\n         * Size of the layout canvas dimensions [x,y]. Currently only used to determine the midpoint which is taken as the starting position\n         * for nodes with no preassigned x and y.\n         * @property size\n         * @type {Array of Number}\n         */\n        size(): Array<number>\n        size(x: Array<number>): this\n        size(x?: Array<number>): any {\n            if (!x) return this._canvasSize;\n            this._canvasSize = x;\n            return this;\n        }\n\n        /**\n         * Default size (assume nodes are square so both width and height) to use in packing if node width/height are not specified.\n         * @property defaultNodeSize\n         * @type {Number}\n         */\n        defaultNodeSize(): number\n        defaultNodeSize(x: number): this\n        defaultNodeSize(x?: any): any {\n            if (!x) return this._defaultNodeSize;\n            this._defaultNodeSize = x;\n            return this;\n        }\n\n        /**\n         * The strength of attraction between the group boundaries to each other.\n         * @property defaultNodeSize\n         * @type {Number}\n         */\n        groupCompactness(): number\n        groupCompactness(x: number): this\n        groupCompactness(x?: any): any {\n            if (!x) return this._groupCompactness;\n            this._groupCompactness = x;\n            return this;\n        }\n\n        /**\n         * links have an ideal distance, The automatic layout will compute layout that tries to keep links (AKA edges) as close as possible to this length.\n         */\n        linkDistance(): number\n        linkDistance(): LinkNumericPropertyAccessor\n        linkDistance(x: number): this\n        linkDistance(x: LinkNumericPropertyAccessor): this\n        linkDistance(x?: any): any {\n            if (!x) {\n                return this._linkDistance;\n            }\n            this._linkDistance = typeof x === \"function\" ? x : +x;\n            this._linkLengthCalculator = null;\n            return this;\n        }\n\n        linkType(f: Function | number): this {\n            this._linkType = f;\n            return this;\n        }\n\n        convergenceThreshold(): number\n        convergenceThreshold(x: number): this\n        convergenceThreshold(x?: number): any {\n            if (!x) return this._threshold;\n            this._threshold = typeof x === \"function\" ? x : +x;\n            return this;\n        }\n\n        alpha(): number\n        alpha(x: number): this\n        alpha(x?: number): any {\n            if (!arguments.length) return this._alpha;\n            else {\n                x = +x;\n                if (this._alpha) { // if we're already running\n                    if (x > 0) this._alpha = x; // we might keep it hot\n                    else this._alpha = 0; // or, next tick will dispatch \"end\"\n                } else if (x > 0) { // otherwise, fire it up!\n                    if (!this._running) {\n                        this._running = true;\n                        this.trigger({ type: EventType.start, alpha: this._alpha = x});\n                        this.kick();\n                    }\n                }\n                return this;\n            }\n        }\n\n        getLinkLength(link: Link<Node | number>): number {\n            return typeof this._linkDistance === \"function\" ? +((<LinkNumericPropertyAccessor>this._linkDistance)(link)) : <number>this._linkDistance;\n        }\n\n        static setLinkLength(link: Link<Node|number>, length: number) {\n            link.length = length;\n        }\n\n        getLinkType(link: Link<Node | number>): number {\n            return typeof this._linkType === \"function\" ? this._linkType(link) : 0;\n        }\n\n        linkAccessor: LinkLengthTypeAccessor = {\n            getSourceIndex: Layout.getSourceIndex,\n            getTargetIndex: Layout.getTargetIndex,\n            setLength: Layout.setLinkLength,\n            getType: l => typeof this._linkType === \"function\" ? this._linkType(l) : 0\n        };\n\n        /**\n         * compute an ideal length for each link based on the graph structure around that link.\n         * you can use this (for example) to create extra space around hub-nodes in dense graphs.\n         * In particular this calculation is based on the \"symmetric difference\" in the neighbour sets of the source and target:\n         * i.e. if neighbours of source is a and neighbours of target are b then calculation is: sqrt(|a union b| - |a intersection b|)\n         * Actual computation based on inspection of link structure occurs in start(), so links themselves\n         * don't have to have been assigned before invoking this function.\n         * @param {number} [idealLength] the base length for an edge when its source and start have no other common neighbours (e.g. 40)\n         * @param {number} [w] a multiplier for the effect of the length adjustment (e.g. 0.7)\n         */\n        symmetricDiffLinkLengths(idealLength: number, w: number = 1): this {\n            this.linkDistance(l => idealLength * l.length);\n            this._linkLengthCalculator = () => symmetricDiffLinkLengths(this._links, this.linkAccessor, w);\n            return this;\n        }\n\n        /**\n         * compute an ideal length for each link based on the graph structure around that link.\n         * you can use this (for example) to create extra space around hub-nodes in dense graphs.\n         * In particular this calculation is based on the \"symmetric difference\" in the neighbour sets of the source and target:\n         * i.e. if neighbours of source is a and neighbours of target are b then calculation is: |a intersection b|/|a union b|\n         * Actual computation based on inspection of link structure occurs in start(), so links themselves\n         * don't have to have been assigned before invoking this function.\n         * @param {number} [idealLength] the base length for an edge when its source and start have no other common neighbours (e.g. 40)\n         * @param {number} [w] a multiplier for the effect of the length adjustment (e.g. 0.7)\n         */\n        jaccardLinkLengths(idealLength: number, w: number = 1): this {\n            this.linkDistance(l => idealLength * l.length);\n            this._linkLengthCalculator = () => jaccardLinkLengths(this._links, this.linkAccessor, w);\n            return this;\n        }\n\n        /**\n         * start the layout process\n         * @method start\n         * @param {number} [initialUnconstrainedIterations=0] unconstrained initial layout iterations\n         * @param {number} [initialUserConstraintIterations=0] initial layout iterations with user-specified constraints\n         * @param {number} [initialAllConstraintsIterations=0] initial layout iterations with all constraints including non-overlap\n         * @param {number} [gridSnapIterations=0] iterations of \"grid snap\", which pulls nodes towards grid cell centers - grid of size node[0].width - only really makes sense if all nodes have the same width and height\n         * @param [keepRunning=true] keep iterating shronously via the tick method\n         * @param [centerGraph=true] Center graph on restart\n         */\n        async start(\n            initialUnconstrainedIterations: number = 0,\n            initialUserConstraintIterations: number = 0,\n            initialAllConstraintsIterations: number = 0,\n            gridSnapIterations: number = 0,\n            keepRunning = true,\n            centerGraph = true,\n        ): Promise<this> {\n            var i: number,\n                j: number,\n                n = (<Array<any>>this.nodes()).length,\n                N = n + 2 * this._groups.length,\n                m = this._links.length,\n                w = this._canvasSize[0],\n                h = this._canvasSize[1];\n\n            var x = new Array(N), y = new Array(N);\n\n            var G = null;\n\n            var ao = this._avoidOverlaps;\n\n            this._nodes.forEach((v, i) => {\n                v.index = i;\n                if (typeof v.x === 'undefined') {\n                    v.x = w / 2, v.y = h / 2;\n                }\n                x[i] = v.x, y[i] = v.y;\n            });\n\n            if (this._linkLengthCalculator) this._linkLengthCalculator();\n\n            //should we do this to clearly label groups?\n            //this._groups.forEach((g, i) => g.groupIndex = i);\n\n            var distances;\n            if (this._distanceMatrix) {\n                // use the user specified distanceMatrix\n                distances = this._distanceMatrix;\n            } else {\n                // construct an n X n distance matrix based on shortest paths through graph (with respect to edge.length).\n                distances = (new Calculator(N, this._links, Layout.getSourceIndex, Layout.getTargetIndex, l=> this.getLinkLength(l))).DistanceMatrix();\n\n                // G is a square matrix with G[i][j] = 1 iff there exists an edge between node i and node j\n                // otherwise 2. (\n                G = Descent.createSquareMatrix(N, () => 2);\n                this._links.forEach(l => {\n                    if (typeof l.source == \"number\") l.source = this._nodes[<number>l.source];\n                    if (typeof l.target == \"number\") l.target = this._nodes[<number>l.target];\n                });\n                this._links.forEach(e => {\n                    const u = Layout.getSourceIndex(e), v = Layout.getTargetIndex(e);\n                    G[u][v] = G[v][u] = e.weight || 1;\n                });\n            }\n\n            var D = Descent.createSquareMatrix(N, function (i, j) {\n                return distances[i][j];\n            });\n\n            if (this._rootGroup && typeof this._rootGroup.groups !== 'undefined') {\n                var i = n;\n                var addAttraction = (i, j, strength, idealDistance) => {\n                    G[i][j] = G[j][i] = strength;\n                    D[i][j] = D[j][i] = idealDistance;\n                };\n                this._groups.forEach(g => {\n                    addAttraction(i, i + 1, this._groupCompactness, 0.1);\n\n                    // todo: add terms here attracting children of the group to the group dummy nodes\n                    //if (typeof g.leaves !== 'undefined')\n                    //    g.leaves.forEach(l => {\n                    //        addAttraction(l.index, i, 1e-4, 0.1);\n                    //        addAttraction(l.index, i + 1, 1e-4, 0.1);\n                    //    });\n                    //if (typeof g.groups !== 'undefined')\n                    //    g.groups.forEach(g => {\n                    //        var gid = n + g.groupIndex * 2;\n                    //        addAttraction(gid, i, 0.1, 0.1);\n                    //        addAttraction(gid + 1, i, 0.1, 0.1);\n                    //        addAttraction(gid, i + 1, 0.1, 0.1);\n                    //        addAttraction(gid + 1, i + 1, 0.1, 0.1);\n                    //    });\n\n                    if (typeof g.bounds === 'undefined') {\n                        x[i] = w / 2, y[i++] = h / 2;\n                        x[i] = w / 2, y[i++] = h / 2;\n                    } else {\n                        x[i] = g.bounds.x, y[i++] = g.bounds.y;\n                        x[i] = g.bounds.X, y[i++] = g.bounds.Y;\n                    }\n                });\n            } else this._rootGroup = { leaves: this._nodes, groups: [] };\n\n            var curConstraints = this._constraints || [];\n            if (this._directedLinkConstraints) {\n                (<any>this.linkAccessor).getMinSeparation = this._directedLinkConstraints.getMinSeparation;\n                curConstraints = curConstraints.concat(generateDirectedEdgeConstraints(n, this._links, this._directedLinkConstraints.axis, <any>(this.linkAccessor)));\n\n                // todo: add containment constraints between group dummy nodes and their children\n            }\n\n            this.avoidOverlaps(false);\n            const wasmInst = await wasmInstPromise;\n            this._descent = new Descent([x, y], D, undefined, wasmInst);\n\n            this._descent.locks.clear();\n            for (var i = 0; i < n; ++i) {\n                var o = this._nodes[i];\n                if (o.fixed) {\n                    o.px = o.x;\n                    o.py = o.y;\n                    var p = [o.x, o.y];\n                    this._descent.locks.add(i, p);\n                }\n            }\n            this._descent.threshold = this._threshold;\n\n            // apply initialIterations without user constraints or nonoverlap constraints\n            // if groups are specified, dummy nodes and edges will be added to untangle\n            // with respect to group connectivity\n            this.initialLayout(initialUnconstrainedIterations, x, y);\n\n            // apply initialIterations with user constraints but no nonoverlap constraints\n            if (curConstraints.length > 0) this._descent.project = new Projection(this._nodes, this._groups, this._rootGroup, curConstraints).projectFunctions();\n            this._descent.run(initialUserConstraintIterations);\n            this.separateOverlappingComponents(w, h, centerGraph);\n\n            // subsequent iterations will apply all constraints\n            this.avoidOverlaps(ao);\n            if (ao) {\n                this._nodes.forEach(function (v, i) { v.x = x[i], v.y = y[i]; });\n                this._descent.project = new Projection(this._nodes, this._groups, this._rootGroup, curConstraints, true).projectFunctions();\n                this._nodes.forEach(function (v, i) { x[i] = v.x, y[i] = v.y; });\n            }\n\n            // allow not immediately connected nodes to relax apart (p-stress)\n            this._descent.G = G;\n            this._descent.run(initialAllConstraintsIterations);\n\n            // TODO\n            // if (gridSnapIterations) {\n            //     this._descent.snapStrength = 1000;\n            //     this._descent.snapGridSize = this._nodes[0].width;\n            //     this._descent.numGridSnapNodes = n;\n            //     this._descent.scaleSnapByMaxH = n != N; // if we have groups then need to scale hessian so grid forces still apply\n            //     var G0 = Descent.createSquareMatrix(N,(i, j) => {\n            //         if (i >= n || j >= n) return G[i][j];\n            //         return 0\n            //     });\n            //     this._descent.G = G0;\n            //     this._descent.run(gridSnapIterations);\n            // }\n\n            this.updateNodePositions();\n            this.separateOverlappingComponents(w, h, centerGraph);\n            return keepRunning ? this.resume() : this;\n        }\n\n        private initialLayout(iterations: number, x: number[], y: number[]) {\n            if (this._groups.length > 0 && iterations > 0) {\n                // construct a flat graph with dummy nodes for the groups and edges connecting group dummy nodes to their children\n                // todo: edges attached to groups are replaced with edges connected to the corresponding group dummy node\n                var n = this._nodes.length;\n                var edges = this._links.map(e => <any>{ source: (<Node>e.source).index, target: (<Node>e.target).index });\n                var vs = this._nodes.map(v => <any>{ index: v.index });\n                this._groups.forEach((g, i) => {\n                    vs.push(<any>{ index: g.index = n + i });\n                });\n                this._groups.forEach((g, i) => {\n                    if (typeof g.leaves !== 'undefined')\n                        g.leaves.forEach(v => edges.push({ source: g.index, target: v.index }));\n                    if (typeof g.groups !== 'undefined')\n                        g.groups.forEach(gg => edges.push({ source: g.index, target: gg.index }));\n                });\n\n                // layout the flat graph with dummy nodes and edges\n                new Layout()\n                    .size(this.size())\n                    .nodes(vs)\n                    .links(edges)\n                    .avoidOverlaps(false)\n                    .linkDistance(this.linkDistance())\n                    .symmetricDiffLinkLengths(5)\n                    .convergenceThreshold(1e-4)\n                    .start(iterations, 0, 0, 0, false);\n\n                this._nodes.forEach(v => {\n                    x[v.index] = vs[v.index].x;\n                    y[v.index] = vs[v.index].y;\n                });\n            } else {\n                this._descent.run(iterations);\n            }\n        }\n\n        // recalculate nodes position for disconnected graphs\n        private separateOverlappingComponents(width: number, height: number, centerGraph: boolean = true): void {\n            // recalculate nodes position for disconnected graphs\n            if (!this._distanceMatrix && this._handleDisconnected) {\n                let x = this._descent.x[0], y = this._descent.x[1];\n                this._nodes.forEach(function (v, i) { v.x = x[i], v.y = y[i]; });\n                var graphs = separateGraphs(this._nodes, this._links);\n                applyPacking(graphs, width, height, this._defaultNodeSize, 1, centerGraph);\n                this._nodes.forEach((v, i) => {\n                    this._descent.x[0][i] = v.x, this._descent.x[1][i] = v.y;\n                    if (v.bounds) {\n                        v.bounds.setXCentre(v.x);\n                        v.bounds.setYCentre(v.y);\n                    }\n                });\n            }\n        }\n\n        resume(): this {\n            return this.alpha(0.1);\n        }\n\n        pause(): this {\n            return this.alpha(0);\n        }\n\n        stop(): this {\n            if (this._descent) {\n                this._descent.cleanWasmMemory();\n            }\n            return this.alpha(0);\n        }\n\n        /// find a visibility graph over the set of nodes.  assumes all nodes have a\n        /// bounds property (a rectangle) and that no pair of bounds overlaps.\n        prepareEdgeRouting(nodeMargin: number = 0) {\n            this._visibilityGraph = new TangentVisibilityGraph(\n                this._nodes.map(function (v) {\n                    return v.bounds.inflate(-nodeMargin).vertices();\n                }));\n        }\n\n        /**\n         * find a route avoiding node bounds for the given edge.\n         * assumes the visibility graph has been created (by prepareEdgeRouting method)\n         * and also assumes that nodes have an index property giving their position in the\n         * node array.  This index property is created by the start() method.\n         * @param [edge] The edge to generate a route for.\n         * @param {number} [ah] The size of the arrow head, a distance to shorten the end\n         *                      of the edge by.  Defaults to 5.\n         */\n        routeEdge(edge, ah: number = 5, draw) {\n            var lineData = [];\n            //if (d.source.id === 10 && d.target.id === 11) {\n            //    debugger;\n            //}\n            var vg2 = new TangentVisibilityGraph(this._visibilityGraph.P, { V: this._visibilityGraph.V, E: this._visibilityGraph.E }),\n                port1 = <TVGPoint>{ x: edge.source.x, y: edge.source.y },\n                port2 = <TVGPoint>{ x: edge.target.x, y: edge.target.y },\n                start = vg2.addPoint(port1, edge.source.index),\n                end = vg2.addPoint(port2, edge.target.index);\n            vg2.addEdgeIfVisible(port1, port2, edge.source.index, edge.target.index);\n            if (typeof draw !== 'undefined') {\n                draw(vg2);\n            }\n            var sourceInd = e => e.source.id, targetInd = e => e.target.id, length = e => e.length(),\n                spCalc = new Calculator(vg2.V.length, vg2.E, sourceInd, targetInd, length),\n                shortestPath = spCalc.PathFromNodeToNode(start.id, end.id);\n            if (shortestPath.length === 1 || shortestPath.length === vg2.V.length) {\n                let route = makeEdgeBetween(edge.source.innerBounds, edge.target.innerBounds, ah);\n                lineData = [route.sourceIntersection, route.arrowStart];\n            } else {\n                var n = shortestPath.length - 2,\n                    p = vg2.V[shortestPath[n]].p,\n                    q = vg2.V[shortestPath[0]].p,\n                    lineData = [edge.source.innerBounds.rayIntersection(p.x, p.y)];\n                for (var i = n; i >= 0; --i)\n                    lineData.push(vg2.V[shortestPath[i]].p);\n                lineData.push(makeEdgeTo(q, edge.target.innerBounds, ah));\n            }\n            //lineData.forEach((v, i) => {\n            //    if (i > 0) {\n            //        var u = lineData[i - 1];\n            //        this._nodes.forEach(function (node) {\n            //            if (node.id === getSourceIndex(d) || node.id === getTargetIndex(d)) return;\n            //            var ints = node.innerBounds.lineIntersections(u.x, u.y, v.x, v.y);\n            //            if (ints.length > 0) {\n            //                debugger;\n            //            }\n            //        })\n            //    }\n            //})\n            return lineData;\n        }\n\n        //The link source and target may be just a node index, or they may be references to nodes themselves.\n        static getSourceIndex(e: Link<Node | number>): number {\n            return typeof e.source === 'number' ? <number>e.source : (<Node>e.source).index;\n        }\n\n        //The link source and target may be just a node index, or they may be references to nodes themselves.\n        static getTargetIndex(e: Link<Node | number>): number {\n            return typeof e.target === 'number' ? <number>e.target : (<Node>e.target).index;\n        }\n\n        // Get a string ID for a given link.\n        static linkId(e: Link<Node | number>): string {\n            return Layout.getSourceIndex(e) + \"-\" + Layout.getTargetIndex(e);\n        }\n\n        // The fixed property has three bits:\n        // Bit 1 can be set externally (e.g., d.fixed = true) and show persist.\n        // Bit 2 stores the dragging state, from mousedown to mouseup.\n        // Bit 3 stores the hover state, from mouseover to mouseout.\n        static dragStart(d: Node | Group) {\n            if (isGroup(d)) {\n                Layout.storeOffset(d, Layout.dragOrigin(d));\n            } else {\n                Layout.stopNode(d);\n                d.fixed |= 2; // set bit 2\n            }\n        }\n\n        // we clobber any existing desired positions for nodes\n        // in case another tick event occurs before the drag\n        private static stopNode(v: Node) {\n            (<any>v).px = v.x;\n            (<any>v).py = v.y;\n        }\n\n        // we store offsets for each node relative to the centre of the ancestor group\n        // being dragged in a pair of properties on the node\n        private static storeOffset(d: Group, origin: { x: number, y: number }) {\n            if (typeof d.leaves !== 'undefined') {\n                d.leaves.forEach(v => {\n                    v.fixed |= 2;\n                    Layout.stopNode(v);\n                    (<any>v)._dragGroupOffsetX = v.x - origin.x;\n                    (<any>v)._dragGroupOffsetY = v.y - origin.y;\n                });\n            }\n            if (typeof d.groups !== 'undefined') {\n                d.groups.forEach(g => Layout.storeOffset(g, origin));\n            }\n        }\n\n        // the drag origin is taken as the centre of the node or group\n        static dragOrigin(d: Node | Group): { x: number, y: number } {\n            if (isGroup(d)) {\n                return {\n                    x: d.bounds.cx(),\n                    y: d.bounds.cy()\n                };\n            } else {\n                return d;\n            }\n        }\n\n        // for groups, the drag translation is propagated down to all of the children of\n        // the group.\n        static drag(d: Node | Group, position: { x: number, y: number }) {\n            if (isGroup(d)) {\n                if (typeof d.leaves !== 'undefined') {\n                    d.leaves.forEach(v => {\n                        d.bounds.setXCentre(position.x);\n                        d.bounds.setYCentre(position.y);\n                        (<any>v).px = (<any>v)._dragGroupOffsetX + position.x;\n                        (<any>v).py = (<any>v)._dragGroupOffsetY + position.y;\n                    });\n                }\n                if (typeof d.groups !== 'undefined') {\n                    d.groups.forEach(g => Layout.drag(g, position));\n                }\n            } else {\n                (<any>d).px = position.x;\n                (<any>d).py = position.y;\n            }\n        }\n\n        // we unset only bits 2 and 3 so that the user can fix nodes with another a different\n        // bit such that the lock persists between drags\n        static dragEnd(d) {\n            if (isGroup(d)) {\n                if (typeof d.leaves !== 'undefined') {\n                    d.leaves.forEach(v => {\n                        Layout.dragEnd(v);\n                        delete (<any>v)._dragGroupOffsetX;\n                        delete (<any>v)._dragGroupOffsetY;\n                    });\n                }\n                if (typeof d.groups !== 'undefined') {\n                    d.groups.forEach(Layout.dragEnd);\n                }\n            } else {\n                d.fixed &= ~6; // unset bits 2 and 3\n                //d.fixed = 0;\n            }\n        }\n\n        // in d3 hover temporarily locks nodes, currently not used in cola\n        static mouseOver(d) {\n            d.fixed |= 4; // set bit 3\n            d.px = d.x, d.py = d.y; // set velocity to zero\n        }\n\n        // in d3 hover temporarily locks nodes, currently not used in cola\n        static mouseOut(d) {\n            d.fixed &= ~4; // unset bit 3\n        }\n    }\n","/**\n * Loads the WebAssembly module that performs the derivative computations for `descent.ts`\n */\n\nimport * as wasmSIMD from './wasm/build/simd/derivative_computer';\nimport wasmSIMD_bg from './wasm/build/simd/derivative_computer_bg.wasm';\nimport * as wasmNoSIMD from './wasm/build/no_simd/derivative_computer';\nimport wasmNoSIMD_bg from './wasm/build/no_simd/derivative_computer_bg.wasm';\n\n// prettier-ignore\nconst getHasSIMDSupport = async () => WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))\n\nclass AsyncOnce<T> {\n  private getter: () => Promise<T>;\n  private pending: Promise<T> | null = null;\n  private res: null | { value: T };\n\n  public constructor(getter: () => Promise<T>) {\n    this.getter = getter;\n  }\n\n  public async get(): Promise<T> {\n    if (this.res) {\n      return this.res.value;\n    }\n    if (this.pending) {\n      return this.pending;\n    }\n\n    this.pending = new Promise((resolve) =>\n      this.getter().then((res) => {\n        this.res = { value: res };\n        this.pending = null;\n        resolve(res);\n      })\n    );\n    return this.pending!;\n  }\n}\n\nexport const WasmInst = new AsyncOnce(async () => {\n  const hasWasmSIMDSupport = await getHasSIMDSupport();\n  if (!window.location.href.includes('localhost')) {\n    console.log(\n      hasWasmSIMDSupport\n        ? 'Wasm SIMD support detected!'\n        : 'Wasm SIMD support NOT detected; using non-SIMD Wasm'\n    );\n  }\n\n  if (hasWasmSIMDSupport) {\n    const wasmModule = await (wasmSIMD_bg as any)();\n    (wasmSIMD as any).setWasm(wasmModule);\n    return wasmSIMD;\n  } else {\n    const wasmModule = await (wasmNoSIMD_bg as any)();\n    (wasmNoSIMD as any).setWasm(wasmModule);\n    return wasmNoSIMD;\n  }\n});\n\ntype PromiseResolveType<P> = P extends Promise<infer T> ? T : never;\n\nexport type DerivativeComputerWasmInst = PromiseResolveType<ReturnType<typeof WasmInst.get>>;\n\nexport const getDerivativeComputerWasm = (): Promise<DerivativeComputerWasmInst> => WasmInst.get();\n","import {Layout, EventType, Event} from './layout'\n\n    export class LayoutAdaptor extends Layout {\n\n        // dummy functions in case not defined by client\n        trigger(e: Event) {};\n        kick() {};\n        drag() {};\n        on(eventType: EventType | string, listener: () => void) : this { return this; };\n\n        dragstart: (d:any) => void;\n        dragStart: (d:any) => void;\n        dragend: (d:any) => void;\n        dragEnd: (d:any) => void;\n\n        constructor( options ) {\n            super();\n\n            // take in implementation as defined by client\n\n            var self = this;\n            var o = options;\n\n            if ( o.trigger ) {\n                this.trigger = o.trigger;\n            }\n\n            if ( o.kick ){\n                this.kick = o.kick;\n            }\n\n            if ( o.drag ){\n                this.drag = o.drag;\n            }\n\n            if ( o.on ){\n                this.on = o.on;\n            }\n\n            this.dragstart = this.dragStart = Layout.dragStart;\n            this.dragend = this.dragEnd = Layout.dragEnd;\n        }\n    }\n\n    /**\n     * provides an interface for use with any external graph system (e.g. Cytoscape.js):\n     */\n    export function adaptor( options ): LayoutAdaptor {\n        return new LayoutAdaptor( options );\n    }\n","////<reference path=\"../extern/d3v3.d.ts\"/>\n////commented out the reference, because the path ended up in the typings, which\n////makes it impossible import in other projects.\n// declare const d3;\n\n\nimport {Layout, EventType, Event} from './layout';\nimport {ID3StyleLayoutAdaptor} from './d3adaptor'\n\n    /**\n     * @internal\n     */\n    export class D3StyleLayoutAdaptor extends Layout implements ID3StyleLayoutAdaptor {\n        protected readonly event: any;\n\n        trigger(e: Event) {\n            var d3event = { type: EventType[e.type], alpha: e.alpha, stress: e.stress };\n            this.event[d3event.type](d3event); // via d3 dispatcher, e.g. event.start(e);\n        }\n\n        // iterate layout using a d3.timer, which queues calls to tick repeatedly until tick returns true\n        kick() {\n            this.d3Context.timer(() => super.tick());\n        }\n\n        // a function to allow for dragging of nodes\n        drag: () => any;\n\n        private d3Context: any;\n\n        constructor(d3Context: any = self.d3) {\n            super();\n            this.d3Context = d3Context;\n            this.event = d3Context.dispatch(EventType[EventType.start], EventType[EventType.tick], EventType[EventType.end]);\n            // bit of trickyness remapping 'this' so we can reference it in the function body.\n            var d3layout = this;\n            var drag;\n            this.drag = function () {\n                if (!drag) {\n                    var drag = d3Context.behavior.drag()\n                        .origin(Layout.dragOrigin)\n                        .on(\"dragstart.d3adaptor\", Layout.dragStart)\n                        .on(\"drag.d3adaptor\", d => {\n                            Layout.drag(d, <any>d3layout.d3Context.event);\n                            d3layout.resume(); // restart annealing\n                        })\n                        .on(\"dragend.d3adaptor\", Layout.dragEnd);\n                }\n\n                if (!arguments.length) return drag;\n\n                // this is the context of the function, i.e. the d3 selection\n                this//.on(\"mouseover.adaptor\", colaMouseover)\n                //.on(\"mouseout.adaptor\", colaMouseout)\n                    .call(drag);\n            }\n        }\n\n        // a function for binding to events on the adapter\n        on(eventType: EventType | string, listener: () => void): this {\n            if (typeof eventType === 'string') {\n                this.event.on(eventType, listener);\n            } else {\n                this.event.on(EventType[eventType], listener);\n            }\n            return this;\n        }\n    }\n","import {dispatch} from 'd3-dispatch'\nimport {timer} from 'd3-timer'\nimport {drag as d3drag} from 'd3-drag'\nimport {Layout, EventType, Event} from './layout'\nimport {ID3StyleLayoutAdaptor} from './d3adaptor'\n\nexport interface D3Context {\n    timer: typeof timer; \n    drag: typeof d3drag; \n    dispatch: typeof dispatch;\n    event: any;\n}\n\n/**\n * @internal\n */\nexport class D3v4StyleLayoutAdaptor extends Layout implements ID3StyleLayoutAdaptor {\n    event:any;\n    trigger(e: Event) {\n        var d3event = { type: EventType[e.type], alpha: e.alpha, stress: e.stress };\n        // the dispatcher is actually expecting something of type EventTarget as the second argument\n        // so passing the thing above is totally abusing the pattern... not sure what to do about this yet\n        this.event.call(d3event.type, <any>d3event); // via d3 dispatcher, e.g. event.start(e);\n    }\n\n    // iterate layout using a d3.timer, which queues calls to tick repeatedly until tick returns true\n    kick() {\n        var t = this.d3Context.timer(() => super.tick() && t.stop());\n    }\n\n    // a function to allow for dragging of nodes\n    drag: () => any;\n\n    /**\n     * @internal\n     */\n    private readonly d3Context: D3Context;\n\n    constructor(d3Context: D3Context) {\n        super();\n        this.d3Context = d3Context;\n        this.event = d3Context.dispatch(EventType[EventType.start], EventType[EventType.tick], EventType[EventType.end]);\n\n        // bit of trickyness remapping 'this' so we can reference it in the function body.\n        var d3layout = this;\n        var drag;\n        this.drag = function () {\n            if (!drag) {\n                var drag = d3Context.drag()\n                    .subject(Layout.dragOrigin)\n                    .on(\"start.d3adaptor\", Layout.dragStart)\n                    .on(\"drag.d3adaptor\", d => {\n                        Layout.drag(<any>d, d3Context.event);\n                        d3layout.resume(); // restart annealing\n                    })\n                    .on(\"end.d3adaptor\", Layout.dragEnd);\n            }\n\n            if (!arguments.length) return drag;\n\n            // this is the context of the function, i.e. the d3 selection\n            //this//.on(\"mouseover.adaptor\", colaMouseover)\n            //.on(\"mouseout.adaptor\", colaMouseout)\n            arguments[0].call(drag);\n        }\n    }\n\n    // a function for binding to events on the adapter\n    on(eventType: EventType | string, listener: () => void): this {\n        if (typeof eventType === 'string') {\n            this.event.on(eventType, listener);\n        } else {\n            this.event.on(EventType[eventType], listener);\n        }\n        return this;\n    }\n}\n","import {Point} from './geom'\nimport {Rectangle} from './rectangle'\nimport {Constraint, Solver, Variable} from './vpsc'\nimport {Calculator} from './shortestpaths'\n    export interface NodeAccessor<Node>{\n        getChildren(v:Node) : number[];\n        getBounds(v:Node) : Rectangle;\n    }\n    export class NodeWrapper {\n        leaf: boolean;\n        parent: NodeWrapper;\n        ports: Vert[];\n        constructor(public id: number, public rect: Rectangle, public children: number[]) {\n            this.leaf = typeof children === 'undefined' || children.length === 0;\n        }\n    }\n    export class Vert {\n        constructor(public id: number, public x:number, public y: number, public node: NodeWrapper = null, public line = null) {}\n    }\n\n    export class LongestCommonSubsequence<T> {\n        length: number;\n        si: number;\n        ti: number;\n        reversed: boolean;\n        constructor(public s: T[], public t: T[]) {\n            var mf = LongestCommonSubsequence.findMatch(s, t);\n            var tr = t.slice(0).reverse();\n            var mr = LongestCommonSubsequence.findMatch(s, tr);\n            if (mf.length >= mr.length) {\n                this.length = mf.length;\n                this.si = mf.si;\n                this.ti = mf.ti;\n                this.reversed = false;\n            } else {\n                this.length = mr.length;\n                this.si = mr.si;\n                this.ti = t.length - mr.ti - mr.length;\n                this.reversed = true;\n            }\n        }\n        private static findMatch<T>(s: T[], t: T[]) {\n            var m = s.length;\n            var n = t.length;\n            var match = { length: 0, si: -1, ti: -1 };\n            var l = new Array(m);\n            for (var i = 0; i < m; i++) {\n                l[i] = new Array(n);\n                for (var j = 0; j < n; j++)\n                    if (s[i] === t[j]) {\n                        var v = l[i][j] = (i === 0 || j === 0) ? 1 : l[i - 1][j - 1] + 1;\n                        if (v > match.length) {\n                            match.length = v;\n                            match.si = i - v + 1;\n                            match.ti = j - v + 1;\n                        };\n                    } else l[i][j] = 0;\n            }\n            return match;\n        }\n        getSequence(): T[]{\n            return this.length >= 0 ? this.s.slice(this.si, this.si + this.length) : [];\n        }\n    }\n    // a horizontal or vertical line of nodes\n    export interface GridLine {\n        nodes: NodeWrapper[];\n        pos: number;\n    }\n    export class GridRouter<Node> {\n        leaves: NodeWrapper[] = null;\n        groups: NodeWrapper[];\n        nodes: NodeWrapper[];\n        cols: GridLine[];\n        rows: GridLine[];\n        root;\n        verts: Vert[];\n        edges;\n        backToFront;\n        obstacles;\n        passableEdges;\n        private avg(a) { return a.reduce((x, y) => x + y) / a.length }\n\n        // in the given axis, find sets of leaves overlapping in that axis\n        // center of each GridLine is average of all nodes in column\n        private getGridLines(axis): GridLine[] {\n            var columns = [];\n            var ls = this.leaves.slice(0, this.leaves.length);\n            while (ls.length > 0) {\n                // find a column of all leaves overlapping in axis with the first leaf\n                let overlapping = ls.filter(v=> v.rect['overlap' + axis.toUpperCase()](ls[0].rect));\n                let col = {\n                    nodes: overlapping,\n                    pos: this.avg(overlapping.map(v=> v.rect['c' + axis]()))\n                };\n                columns.push(col);\n                col.nodes.forEach(v=> ls.splice(ls.indexOf(v), 1));\n            }\n            columns.sort((a, b) => a.pos - b.pos)\n            return columns;\n        }\n\n        // get the depth of the given node in the group hierarchy\n        private getDepth(v) {\n            var depth = 0;\n            while (v.parent !== this.root) {\n                depth++;\n                v = v.parent;\n            }\n            return depth;\n        }\n\n        // medial axes between node centres and also boundary lines for the grid\n        private midPoints(a) {\n            if (a.length === 1) {\n                return [a[0]]\n            }\n\n            var gap = a[1] - a[0];\n            var mids = [a[0] - gap / 2];\n            for (var i = 1; i < a.length; i++) {\n                mids.push((a[i] + a[i - 1]) / 2);\n            }\n            mids.push(a[a.length - 1] + gap / 2);\n            return mids;\n        }\n\n        constructor(public originalnodes: Node[], accessor: NodeAccessor<Node>, public groupPadding: number = 12) {\n            this.nodes = originalnodes.map((v, i) => new NodeWrapper(i, accessor.getBounds(v), accessor.getChildren(v)));\n            this.leaves = this.nodes.filter(v=> v.leaf);\n            this.groups = this.nodes.filter(g=> !g.leaf);\n            this.cols = this.getGridLines('x');\n            this.rows = this.getGridLines('y');\n\n            // create parents for each node or group that is a member of another's children\n            this.groups.forEach(v=>\n                v.children.forEach(c=> this.nodes[<number>c].parent = v));\n\n            // root claims the remaining orphans\n            this.root = { children: [] };\n            this.nodes.forEach(v=> {\n                if (typeof v.parent === 'undefined') {\n                    v.parent = this.root;\n                    this.root.children.push(v.id);\n                }\n\n                // each node will have grid vertices associated with it,\n                // some inside the node and some on the boundary\n                // leaf nodes will have exactly one internal node at the center\n                // and four boundary nodes\n                // groups will have potentially many of each\n                v.ports = []\n            });\n\n            // nodes ordered by their position in the group hierarchy\n            this.backToFront = this.nodes.slice(0);\n            this.backToFront.sort((x, y) => this.getDepth(x) - this.getDepth(y));\n\n            // compute boundary rectangles for each group\n            // has to be done from front to back, i.e. inside groups to outside groups\n            // such that each can be made large enough to enclose its interior\n            var frontToBackGroups = this.backToFront.slice(0).reverse().filter(g=> !g.leaf);\n            frontToBackGroups.forEach(v=> {\n                var r = Rectangle.empty();\n                v.children.forEach(c=> r = r.union(this.nodes[c].rect));\n                v.rect = r.inflate(this.groupPadding);\n            });\n\n            var colMids = this.midPoints(this.cols.map(r=> r.pos));\n            var rowMids = this.midPoints(this.rows.map(r=> r.pos));\n\n            // setup extents of lines\n            var rowx = colMids[0], rowX = colMids[colMids.length - 1];\n            var coly = rowMids[0], colY = rowMids[rowMids.length - 1];\n\n            // horizontal lines\n            var hlines = this.rows.map(r=> <any>{ x1: rowx, x2: rowX, y1: r.pos, y2: r.pos })\n                .concat(rowMids.map(m=> <any>{ x1: rowx, x2: rowX, y1: m, y2: m }));\n\n            // vertical lines\n            var vlines = this.cols.map(c=> <any>{ x1: c.pos, x2: c.pos, y1: coly, y2: colY })\n                .concat(colMids.map(m=> <any>{ x1: m, x2: m, y1: coly, y2: colY }));\n\n            // the full set of lines\n            var lines = hlines.concat(vlines);\n\n            // we record the vertices associated with each line\n            lines.forEach(l=> l.verts = []);\n\n            // the routing graph\n            this.verts = [];\n            this.edges = [];\n\n            // create vertices at the crossings of horizontal and vertical grid-lines\n            hlines.forEach(h=>\n                vlines.forEach(v=> {\n                    var p = new Vert(this.verts.length, v.x1, h.y1);\n                    h.verts.push(p);\n                    v.verts.push(p);\n                    this.verts.push(p);\n\n                    // assign vertices to the nodes immediately under them\n                    var i = this.backToFront.length;\n                    while (i-- > 0) {\n                        var node = this.backToFront[i],\n                            r = node.rect;\n                        var dx = Math.abs(p.x - r.cx()),\n                            dy = Math.abs(p.y - r.cy());\n                        if (dx < r.width() / 2 && dy < r.height() / 2) {\n                            (<any>p).node = node;\n                            break;\n                        }\n                    }\n                })\n                );\n\n            lines.forEach((l, li) => {\n                // create vertices at the intersections of nodes and lines\n                this.nodes.forEach((v, i) => {\n                    v.rect.lineIntersections(l.x1, l.y1, l.x2, l.y2).forEach((intersect, j) => {\n                        //console.log(li+','+i+','+j+':'+intersect.x + ',' + intersect.y);\n                        var p = new Vert(this.verts.length, intersect.x, intersect.y, v, l);\n                        this.verts.push(p);\n                        l.verts.push(p);\n                        v.ports.push(p);\n                    });\n                });\n\n                // split lines into edges joining vertices\n                var isHoriz = Math.abs(l.y1 - l.y2) < 0.1;\n                var delta = (a, b) => isHoriz ? b.x - a.x : b.y - a.y;\n                l.verts.sort(delta);\n                for (var i = 1; i < l.verts.length; i++) {\n                    var u = l.verts[i - 1], v = l.verts[i];\n                    if (u.node && u.node === v.node && u.node.leaf) continue;\n                    this.edges.push({ source: u.id, target: v.id, length: Math.abs(delta(u, v)) });\n                }\n            });\n\n\n\n        }\n\n        // find path from v to root including both v and root\n        private findLineage(v) {\n            var lineage = [v];\n            do {\n                v = v.parent;\n                lineage.push(v);\n            } while (v !== this.root);\n            return lineage.reverse();\n        }\n\n        // find path connecting a and b through their lowest common ancestor\n        private findAncestorPathBetween(a, b) {\n            var aa = this.findLineage(a), ba = this.findLineage(b), i = 0;\n            while (aa[i] === ba[i]) i++;\n            // i-1 to include common ancestor only once (as first element)\n            return { commonAncestor: aa[i - 1], lineages: aa.slice(i).concat(ba.slice(i)) };\n        }\n\n        // when finding a path between two nodes a and b, siblings of a and b on the\n        // paths from a and b to their least common ancestor are obstacles\n        siblingObstacles(a, b) {\n            var path = this.findAncestorPathBetween(a, b);\n            var lineageLookup = {};\n            path.lineages.forEach(v=> lineageLookup[v.id] = {});\n            var obstacles = path.commonAncestor.children.filter(v=> !(v in lineageLookup));\n\n            path.lineages\n                .filter(v=> v.parent !== path.commonAncestor)\n                .forEach(v=> obstacles = obstacles.concat(v.parent.children.filter(c=> c !== v.id)));\n\n            return obstacles.map(v=> this.nodes[v]);\n        }\n\n        // for the given routes, extract all the segments orthogonal to the axis x\n        // and return all them grouped by x position\n        static getSegmentSets(routes, x, y) {\n            // vsegments is a list of vertical segments sorted by x position\n            var vsegments = [];\n            for (var ei = 0; ei < routes.length; ei++) {\n                var route = routes[ei];\n                for (var si = 0; si < route.length; si++) {\n                    var s = <any>route[si];\n                    s.edgeid = ei;\n                    s.i = si;\n                    var sdx = s[1][x] - s[0][x];\n                    if (Math.abs(sdx) < 0.1) {\n                        vsegments.push(s);\n                    }\n                }\n            }\n            vsegments.sort((a, b) => a[0][x] - b[0][x]);\n\n            // vsegmentsets is a set of sets of segments grouped by x position\n            var vsegmentsets = [];\n            var segmentset = null;\n            for (var i = 0; i < vsegments.length; i++) {\n                var s = vsegments[i];\n                if (!segmentset || Math.abs(s[0][x] - segmentset.pos) > 0.1) {\n                    segmentset = { pos: s[0][x], segments: [] };\n                    vsegmentsets.push(segmentset);\n                }\n                segmentset.segments.push(s);\n            }\n            return vsegmentsets;\n        }\n\n        // for all segments in this bundle create a vpsc problem such that\n        // each segment's x position is a variable and separation constraints\n        // are given by the partial order over the edges to which the segments belong\n        // for each pair s1,s2 of segments in the open set:\n        //   e1 = edge of s1, e2 = edge of s2\n        //   if leftOf(e1,e2) create constraint s1.x + gap <= s2.x\n        //   else if leftOf(e2,e1) create cons. s2.x + gap <= s1.x\n        static nudgeSegs(x: string, y: string, routes, segments, leftOf, gap: number) {\n            var n = segments.length;\n            if (n <= 1) return;\n            var vs = segments.map(s => new Variable(s[0][x]));\n            var cs = [];\n            for (var i = 0; i < n; i++) {\n                for (var j = 0; j < n; j++) {\n                    if (i === j) continue;\n                    var s1 = segments[i],\n                        s2 = segments[j],\n                        e1 = s1.edgeid,\n                        e2 = s2.edgeid,\n                        lind = -1,\n                        rind = -1;\n                    // in page coordinates (not cartesian) the notion of 'leftof' is flipped in the horizontal axis from the vertical axis\n                    // that is, when nudging vertical segments, if they increase in the y(conj) direction the segment belonging to the\n                    // 'left' edge actually needs to be nudged to the right\n                    // when nudging horizontal segments, if the segments increase in the x direction\n                    // then the 'left' segment needs to go higher, i.e. to have y pos less than that of the right\n                    if (x == 'x') {\n                        if (leftOf(e1, e2)) {\n                            //console.log('s1: ' + s1[0][x] + ',' + s1[0][y] + '-' + s1[1][x] + ',' + s1[1][y]);\n                            if (s1[0][y] < s1[1][y]) {\n                                lind = j, rind = i;\n                            } else {\n                                lind = i, rind = j;\n                            }\n                        }\n                    } else {\n                        if (leftOf(e1, e2)) {\n                            if (s1[0][y] < s1[1][y]) {\n                                lind = i, rind = j;\n                            } else {\n                                lind = j, rind = i;\n                            }\n                        }\n                    }\n                    if (lind >= 0) {\n                        //console.log(x+' constraint: ' + lind + '<' + rind);\n                        cs.push(new Constraint(vs[lind], vs[rind], gap));\n                    }\n                }\n            }\n            var solver = new Solver(vs, cs);\n            solver.solve();\n            vs.forEach((v, i) => {\n                var s = segments[i];\n                var pos = v.position();\n                s[0][x] = s[1][x] = pos;\n                var route = routes[s.edgeid];\n                if (s.i > 0) route[s.i - 1][1][x] = pos;\n                if (s.i < route.length - 1) route[s.i + 1][0][x] = pos;\n            });\n        }\n\n        static nudgeSegments(routes, x: string, y: string, leftOf: (e1: number, e2: number) => boolean, gap: number) {\n            var vsegmentsets = GridRouter.getSegmentSets(routes, x, y);\n            // scan the grouped (by x) segment sets to find co-linear bundles\n            for (var i = 0; i < vsegmentsets.length; i++) {\n                var ss = vsegmentsets[i];\n                var events = [];\n                for (var j = 0; j < ss.segments.length; j++) {\n                    var s = ss.segments[j];\n                    events.push({ type: 0, s: s, pos: Math.min(s[0][y], s[1][y]) });\n                    events.push({ type: 1, s: s, pos: Math.max(s[0][y], s[1][y]) });\n                }\n                events.sort((a, b) => a.pos - b.pos + a.type - b.type);\n                var open = [];\n                var openCount = 0;\n                events.forEach(e=> {\n                    if (e.type === 0) {\n                        open.push(e.s);\n                        openCount++;\n                    } else {\n                        openCount--;\n                    }\n                    if (openCount == 0) {\n                        GridRouter.nudgeSegs(x, y, routes, open, leftOf, gap);\n                        open = [];\n                    }\n                });\n            }\n        }\n\n        // obtain routes for the specified edges, nicely nudged apart\n        // warning: edge paths may be reversed such that common paths are ordered consistently within bundles!\n        // @param edges list of edges\n        // @param nudgeGap how much to space parallel edge segements\n        // @param source function to retrieve the index of the source node for a given edge\n        // @param target function to retrieve the index of the target node for a given edge\n        // @returns an array giving, for each edge, an array of segments, each segment a pair of points in an array\n        routeEdges<Edge>(edges: Edge[], nudgeGap: number, source: (e: Edge) => number, target: (e: Edge) => number): Point[][][] {\n            var routePaths = edges.map(e=> this.route(source(e), target(e)));\n            var order = GridRouter.orderEdges(routePaths);\n            var routes = routePaths.map(function (e) { return GridRouter.makeSegments(e); });\n            GridRouter.nudgeSegments(routes, 'x', 'y', order, nudgeGap);\n            GridRouter.nudgeSegments(routes, 'y', 'x', order, nudgeGap);\n            GridRouter.unreverseEdges(routes, routePaths);\n            return routes;\n        }\n\n        // path may have been reversed by the subsequence processing in orderEdges\n        // so now we need to restore the original order\n        static unreverseEdges(routes, routePaths) {\n            routes.forEach((segments, i) => {\n                var path = routePaths[i];\n                if ((<any>path).reversed) {\n                    segments.reverse(); // reverse order of segments\n                    segments.forEach(function (segment) {\n                        segment.reverse();  // reverse each segment\n                    });\n                }\n            });\n        }\n\n        static angleBetween2Lines(line1: Point[], line2: Point[]): number {\n            var angle1 = Math.atan2(line1[0].y - line1[1].y,\n                line1[0].x - line1[1].x);\n            var angle2 = Math.atan2(line2[0].y - line2[1].y,\n                line2[0].x - line2[1].x);\n            var diff = angle1 - angle2;\n            if (diff > Math.PI || diff < -Math.PI) {\n                diff = angle2 - angle1;\n            }\n            return diff;\n        }\n\n        // does the path a-b-c describe a left turn?\n        private static isLeft(a, b, c) {\n            return ((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) <= 0;\n        }\n\n        // for the given list of ordered pairs, returns a function that (efficiently) looks-up a specific pair to\n        // see if it exists in the list\n        private static getOrder(pairs: { l: number; r: number }[]): (l: number, r: number) => boolean {\n            var outgoing = {};\n            for (var i = 0; i < pairs.length; i++) {\n                var p = pairs[i];\n                if (typeof outgoing[p.l] === 'undefined') outgoing[p.l] = {};\n                outgoing[p.l][p.r] = true;\n            }\n            return (l, r) => typeof outgoing[l] !== 'undefined' && outgoing[l][r];\n        }\n\n        // returns an ordering (a lookup function) that determines the correct order to nudge the\n        // edge paths apart to minimize crossings\n        static orderEdges(edges) {\n            var edgeOrder = [];\n            for (var i = 0; i < edges.length - 1; i++) {\n                for (var j = i + 1; j < edges.length; j++) {\n                    var e = edges[i],\n                        f = edges[j],\n                        lcs = new LongestCommonSubsequence(e, f);\n                    var u, vi, vj;\n                    if (lcs.length === 0)\n                        continue; // no common subpath\n                    if (lcs.reversed) {\n                        // if we found a common subpath but one of the edges runs the wrong way,\n                        // then reverse f.\n                        f.reverse();\n                        f.reversed = true;\n                        lcs = new LongestCommonSubsequence(e, f);\n                    }\n                    if ((lcs.si <= 0 || lcs.ti <= 0) &&\n                        (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length)) {\n                        // the paths do not diverge, so make an arbitrary ordering decision\n                        edgeOrder.push({ l: i, r: j });\n                        continue;\n                    }\n                    if (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length) {\n                        // if the common subsequence of the\n                        // two edges being considered goes all the way to the\n                        // end of one (or both) of the lines then we have to\n                        // base our ordering decision on the other end of the\n                        // common subsequence\n                        u = e[lcs.si + 1];\n                        vj = e[lcs.si - 1];\n                        vi = f[lcs.ti - 1];\n                    } else {\n                        u = e[lcs.si + lcs.length - 2];\n                        vi = e[lcs.si + lcs.length];\n                        vj = f[lcs.ti + lcs.length];\n                    }\n                    if (GridRouter.isLeft(u, vi, vj)) {\n                        edgeOrder.push({ l: j, r: i });\n                    } else {\n                        edgeOrder.push({ l: i, r: j });\n                    }\n                }\n            }\n            //edgeOrder.forEach(function (e) { console.log('l:' + e.l + ',r:' + e.r) });\n            return GridRouter.getOrder(edgeOrder);\n        }\n\n        // for an orthogonal path described by a sequence of points, create a list of segments\n        // if consecutive segments would make a straight line they are merged into a single segment\n        // segments are over cloned points, not the original vertices\n        static makeSegments(path: Point[]): Point[][] {\n            function copyPoint(p: Point) {\n                return <Point>{ x: p.x, y: p.y };\n            }\n            var isStraight = (a, b, c) => Math.abs((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) < 0.001;\n            var segments = [];\n            var a = copyPoint(path[0]);\n            for (var i = 1; i < path.length; i++) {\n                var b = copyPoint(path[i]), c = i < path.length - 1 ? path[i + 1] : null;\n                if (!c || !isStraight(a, b, c)) {\n                    segments.push([a, b]);\n                    a = b;\n                }\n            }\n            return segments;\n        }\n\n        // find a route between node s and node t\n        // returns an array of indices to verts\n        route(s: number, t: number): Point[] {\n            var source = this.nodes[<number>s], target = this.nodes[<number>t];\n            this.obstacles = this.siblingObstacles(source, target);\n\n            var obstacleLookup = {};\n            this.obstacles.forEach(o => obstacleLookup[o.id] = o);\n            this.passableEdges = this.edges.filter(e=> {\n                var u = this.verts[e.source],\n                    v = this.verts[e.target];\n                return !(u.node && u.node.id in obstacleLookup\n                    || v.node && v.node.id in obstacleLookup);\n            });\n\n            // add dummy segments linking ports inside source and target\n            for (var i = 1; i < source.ports.length; i++) {\n                var u = source.ports[0].id;\n                var v = source.ports[i].id;\n                this.passableEdges.push({\n                    source: u,\n                    target: v,\n                    length: 0\n                });\n            }\n            for (var i = 1; i < target.ports.length; i++) {\n                var u = target.ports[0].id;\n                var v = target.ports[i].id;\n                this.passableEdges.push({\n                    source: u,\n                    target: v,\n                    length: 0\n                });\n            }\n\n            var getSource = e=> e.source,\n                getTarget = e=> e.target,\n                getLength = e=> e.length;\n\n            var shortestPathCalculator = new Calculator(this.verts.length, this.passableEdges, getSource, getTarget, getLength);\n            var bendPenalty = (u, v, w) => {\n                var a = this.verts[u], b = this.verts[v], c = this.verts[w];\n                var dx = Math.abs(c.x - a.x), dy = Math.abs(c.y - a.y);\n                // don't count bends from internal node edges\n                if (a.node === source && a.node === b.node || b.node === target && b.node === c.node)\n                    return 0;\n                return dx > 1 && dy > 1 ? 1000 : 0;\n            };\n\n            // get shortest path\n            var shortestPath = shortestPathCalculator.PathFromNodeToNodeWithPrevCost(\n                source.ports[0].id, target.ports[0].id,\n                bendPenalty);\n\n            // shortest path is reversed and does not include the target port\n            var pathPoints = shortestPath.reverse().map(vi => this.verts[vi]);\n            pathPoints.push(this.nodes[target.id].ports[0]);\n\n            // filter out any extra end points that are inside the source or target (i.e. the dummy segments above)\n            return pathPoints.filter((v, i) =>\n                !(i < pathPoints.length - 1 && pathPoints[i + 1].node === source && v.node === source\n                    || i > 0 && v.node === target && pathPoints[i - 1].node === target));\n        }\n\n        static getRoutePath(route: Point[][], cornerradius: number, arrowwidth: number, arrowheight: number): { routepath: string; arrowpath: string } {\n            var result = {\n                routepath: 'M ' + route[0][0].x + ' ' + route[0][0].y + ' ',\n                arrowpath: ''\n            };\n            if (route.length > 1) {\n                for (var i = 0; i < route.length; i++) {\n                    var li = route[i];\n                    var x = li[1].x, y = li[1].y;\n                    var dx = x - li[0].x;\n                    var dy = y - li[0].y;\n                    if (i < route.length - 1) {\n                        if (Math.abs(dx) > 0) {\n                            x -= dx / Math.abs(dx) * cornerradius;\n                        } else {\n                            y -= dy / Math.abs(dy) * cornerradius;\n                        }\n                        result.routepath += 'L ' + x + ' ' + y + ' ';\n                        var l = route[i + 1];\n                        var x0 = l[0].x, y0 = l[0].y;\n                        var x1 = l[1].x;\n                        var y1 = l[1].y;\n                        dx = x1 - x0;\n                        dy = y1 - y0;\n                        var angle = GridRouter.angleBetween2Lines(li, l) < 0 ? 1 : 0;\n                        //console.log(cola.GridRouter.angleBetween2Lines(li, l))\n                        var x2, y2;\n                        if (Math.abs(dx) > 0) {\n                            x2 = x0 + dx / Math.abs(dx) * cornerradius;\n                            y2 = y0;\n                        } else {\n                            x2 = x0;\n                            y2 = y0 + dy / Math.abs(dy) * cornerradius;\n                        }\n                        var cx = Math.abs(x2 - x);\n                        var cy = Math.abs(y2 - y);\n                        result.routepath += 'A ' + cx + ' ' + cy + ' 0 0 ' + angle + ' ' + x2 + ' ' + y2 + ' ';\n                    } else {\n                        var arrowtip = [x, y];\n                        var arrowcorner1, arrowcorner2;\n                        if (Math.abs(dx) > 0) {\n                            x -= dx / Math.abs(dx) * arrowheight;\n                            arrowcorner1 = [x, y + arrowwidth];\n                            arrowcorner2 = [x, y - arrowwidth];\n                        } else {\n                            y -= dy / Math.abs(dy) * arrowheight;\n                            arrowcorner1 = [x + arrowwidth, y];\n                            arrowcorner2 = [x - arrowwidth, y];\n                        }\n                        result.routepath += 'L ' + x + ' ' + y + ' ';\n                        if (arrowheight > 0) {\n                            result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1]\n                            + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];\n                        }\n                    }\n                }\n            } else {\n                var li = route[0];\n                var x = li[1].x, y = li[1].y;\n                var dx = x - li[0].x;\n                var dy = y - li[0].y;\n                var arrowtip = [x, y];\n                var arrowcorner1, arrowcorner2;\n                if (Math.abs(dx) > 0) {\n                    x -= dx / Math.abs(dx) * arrowheight;\n                    arrowcorner1 = [x, y + arrowwidth];\n                    arrowcorner2 = [x, y - arrowwidth];\n                } else {\n                    y -= dy / Math.abs(dy) * arrowheight;\n                    arrowcorner1 = [x + arrowwidth, y];\n                    arrowcorner2 = [x - arrowwidth, y];\n                }\n                result.routepath += 'L ' + x + ' ' + y + ' ';\n                if (arrowheight > 0) {\n                    result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1]\n                    + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];\n                }\n            }\n            return result;\n        }\n    }\n","import {Calculator} from './shortestpaths'\nimport {Descent} from './descent'\nimport {Projection, GraphNode, Rectangle} from './rectangle'\nimport {Variable} from './vpsc'\nimport {jaccardLinkLengths, LinkLengthAccessor} from './linklengths'\nimport { getDerivativeComputerWasm } from './wasmEngine'\n\n// Kick this off right away since we're going to need it eventually\nconst wasmInstPromise = getDerivativeComputerWasm();\n\nexport class Link3D {\n        length: number;\n        constructor(public source: number, public target: number) { }\n        actualLength(x: number[][]) {\n            return Math.sqrt(\n                x.reduce((c: number, v: number[]) => {\n                    const dx = v[this.target] - v[this.source];\n                    return c + dx * dx;\n                }, 0));\n        }\n    }\n    export class Node3D implements GraphNode {\n        // if fixed, layout will not move the node from its specified starting position\n        fixed: boolean;\n        width: number;\n        height: number;\n        px: number;\n        py: number;\n        bounds: Rectangle;\n        variable: Variable;\n        constructor(\n            public x: number = 0,\n            public y: number = 0,\n            public z: number = 0) { }\n    }\n    export class Layout3D {\n        static dims = ['x', 'y', 'z'];\n        static k = Layout3D.dims.length;\n        result: number[][];\n        constraints: any[] = null;\n\n        constructor(public nodes: Node3D[], public links: Link3D[], public idealLinkLength: number = 1) {\n            this.result = new Array(Layout3D.k);\n            for (var i = 0; i < Layout3D.k; ++i) {\n                this.result[i] = new Array(nodes.length);\n            }\n            nodes.forEach((v, i) => {\n                for (var dim of Layout3D.dims) {\n                    if (typeof v[dim] == 'undefined') v[dim] = Math.random();\n                }\n                this.result[0][i] = v.x;\n                this.result[1][i] = v.y;\n                this.result[2][i] = v.z;\n            });\n        };\n\n        linkLength(l: Link3D): number {\n            return l.actualLength(this.result);\n        }\n\n        useJaccardLinkLengths: boolean = true;\n\n        descent: Descent;\n        async start(iterations: number = 100): Promise<Layout3D> {\n            const n = this.nodes.length;\n\n            var linkAccessor = new LinkAccessor();\n\n            if (this.useJaccardLinkLengths)\n                jaccardLinkLengths(this.links, linkAccessor, 1.5);\n\n            this.links.forEach(e => e.length *= this.idealLinkLength);\n\n            // Create the distance matrix that Cola needs\n            const distanceMatrix = (new Calculator(n, this.links,\n                e=> e.source, e=> e.target, e => e.length)).DistanceMatrix();\n\n            const D = Descent.createSquareMatrix(n, (i, j) => distanceMatrix[i][j]);\n\n            // G is a square matrix with G[i][j] = 1 iff there exists an edge between node i and node j\n            // otherwise 2.\n            var G = Descent.createSquareMatrix(n, function () { return 2 });\n            this.links.forEach(({ source, target }) => G[source][target] = G[target][source] = 1);\n\n            const wasmInst = await wasmInstPromise;\n            this.descent = new Descent(this.result, D, undefined, wasmInst);\n            this.descent.threshold = 1e-3;\n            this.descent.G = G.map(Gn => new Float32Array(Gn));\n            //let constraints = this.links.map(e=> <any>{\n            //    axis: 'y', left: e.source, right: e.target, gap: e.length*1.5\n            //});\n            if (this.constraints)\n                this.descent.project = new Projection(<GraphNode[]>this.nodes, null, null, this.constraints).projectFunctions();\n\n            for (var i = 0; i < this.nodes.length; i++) {\n                var v = this.nodes[i];\n                if (v.fixed) {\n                    this.descent.locks.add(i, [v.x, v.y, v.z]);\n                }\n            }\n\n            this.descent.run(iterations);\n            return this;\n        }\n\n        tick(): number {\n            this.descent.locks.clear();\n            for (var i = 0; i < this.nodes.length; i++) {\n                var v = this.nodes[i];\n                if (v.fixed) {\n                    this.descent.locks.add(i, [v.x, v.y, v.z]);\n                }\n            }\n            return this.descent.rungeKutta();\n        }\n    }\n\n    class LinkAccessor implements LinkLengthAccessor<any> {\n        getSourceIndex(e: any): number { return e.source; }\n        getTargetIndex(e: any): number { return e.target; }\n        getLength(e: any): number { return e.length; }\n        setLength(e: any, l: number) { e.length = l; }\n    }\n","import {D3StyleLayoutAdaptor} from './d3v3adaptor'\nimport {D3Context, D3v4StyleLayoutAdaptor} from './d3v4adaptor'\nimport { Layout, EventType, Event } from './layout';\n\nexport { D3Context } from './d3v4adaptor';\n\nexport interface D3v3Context { version: string };\n\nexport interface ID3StyleLayoutAdaptor {\n    trigger(e: Event): void;\n    kick(): void;\n    drag: () => any;\n\n    on(eventType: EventType | string, listener: () => void): ID3StyleLayoutAdaptor;\n}\n\n\n/**\n * provides an interface for use with d3:\n * Correct way to create way to construct the d3 cola object is to pass the d3 object into the adaptor function, like so:\n * \n *   `var d3cola = cola.d3adaptor(d3);`\n * \n * Internally, it will figure out if d3 is version 3 or 4 from the version tag and set up the right event forwarding. Defaults to version 3 if the d3 object is not passed.\n * - uses the d3 event system to dispatch layout events such as:\n *   o \"start\" (start layout process)\n *   o \"tick\" (after each layout iteration)\n *   o \"end\" (layout converged and complete).\n * - uses the d3 timer to queue layout iterations.\n * - sets up d3.behavior.drag to drag nodes\n *   o use `node.call(<the returned instance of Layout>.drag)` to make nodes draggable\n * returns an instance of the cola.Layout itself with which the user\n * can interact directly.\n */\nexport function d3adaptor(d3Context?: D3Context | D3v3Context): Layout & ID3StyleLayoutAdaptor {\n    if (!d3Context || isD3V3(d3Context)) {\n        return new D3StyleLayoutAdaptor(d3Context);\n    }\n    return new D3v4StyleLayoutAdaptor(d3Context);\n}\n\nfunction isD3V3(d3Context: D3Context | D3v3Context): d3Context is D3v3Context {\n    const v3exp = /^3\\./;\n    return (<any>d3Context).version && (<any>d3Context).version.match(v3exp) !== null;\n}\n","import {Node, Link, Layout} from './layout'\nimport {GridRouter} from './gridrouter'\nimport {Point} from './geom'\n\n/**\n * @property nudgeGap spacing between parallel edge segments\n * @property margin space around nodes\n * @property groupMargin space around groups\n */\nexport function gridify(pgLayout, nudgeGap: number, margin: number, groupMargin: number) {\n    pgLayout.cola.start(0, 0, 0, 10, false);\n    let gridrouter = route(pgLayout.cola.nodes(), pgLayout.cola.groups(), margin, groupMargin);\n    return gridrouter.routeEdges<any>(pgLayout.powerGraph.powerEdges, nudgeGap, e=> e.source.routerNode.id, e=> e.target.routerNode.id);\n}\n\nfunction route(nodes, groups, margin: number, groupMargin: number) {\n    nodes.forEach(d => {\n        d.routerNode = <any>{\n            name: d.name,\n            bounds: d.bounds.inflate(-margin)\n        };\n    });\n    groups.forEach(d => {\n        d.routerNode = <any>{\n            bounds: d.bounds.inflate(-groupMargin),\n            children: (typeof d.groups !== 'undefined' ? d.groups.map(c=> nodes.length + c.id) : [])\n                .concat(typeof d.leaves !== 'undefined' ? d.leaves.map(c=> c.index) : [])\n        };\n    });\n    let gridRouterNodes = nodes.concat(groups).map((d, i) => {\n        d.routerNode.id = i;\n        return d.routerNode;\n    });\n    return new GridRouter(gridRouterNodes, {\n        getChildren: (v: any) => v.children,\n        getBounds: v => v.bounds\n    }, margin - groupMargin);\n}\n\nexport function powerGraphGridLayout(\n    graph: { nodes: Node[], links: Link<Node>[] },\n    size: number[],\n    grouppadding: number)\n{\n    // compute power graph\n    var powerGraph;\n    graph.nodes.forEach((v,i) => (<any>v).index = i);\n    new Layout()\n        .avoidOverlaps(false)\n        .nodes(graph.nodes)\n        .links(graph.links)\n        .powerGraphGroups(function (d) {\n            powerGraph = d;\n            powerGraph.groups.forEach(v=> v.padding = grouppadding);\n        });\n\n    // construct a flat graph with dummy nodes for the groups and edges connecting group dummy nodes to their children\n    // power edges attached to groups are replaced with edges connected to the corresponding group dummy node\n    var n = graph.nodes.length;\n    var edges = [];\n    var vs = graph.nodes.slice(0);\n    vs.forEach((v, i) => (<any>v).index = i);\n    powerGraph.groups.forEach(g => {\n        var sourceInd = g.index = g.id + n;\n        vs.push(g);\n        if (typeof g.leaves !== 'undefined')\n            g.leaves.forEach(v => edges.push({ source: sourceInd, target: v.index }));\n        if (typeof g.groups !== 'undefined')\n            g.groups.forEach(gg => edges.push({ source: sourceInd, target: gg.id + n }));\n    });\n    powerGraph.powerEdges.forEach(e=> {\n        edges.push({ source: e.source.index, target: e.target.index });\n    });\n\n    // layout the flat graph with dummy nodes and edges\n    new Layout()\n        .size(size)\n        .nodes(vs)\n        .links(edges)\n        .avoidOverlaps(false)\n        .linkDistance(30)\n        .symmetricDiffLinkLengths(5)\n        .convergenceThreshold(1e-4)\n        .start(100, 0, 0, 0, false);\n\n    // final layout taking node positions from above as starting positions\n    // subject to group containment constraints\n    // and then gridifying the layout\n    return {\n        cola:\n            new Layout()\n            .convergenceThreshold(1e-3)\n            .size(size)\n            .avoidOverlaps(true)\n            .nodes(graph.nodes)\n            .links(graph.links)\n        //.flowLayout('y', 30)\n            .groupCompactness(1e-4)\n            .linkDistance(30)\n            .symmetricDiffLinkLengths(5)\n            .powerGraphGroups(function (d) {\n                powerGraph = d;\n                powerGraph.groups.forEach(function (v) {\n                    v.padding = grouppadding\n                });\n            }).start(50, 0, 100, 0, false),\n        powerGraph: powerGraph\n    };\n}\n"],"names":["PowerEdge","source","target","type","Configuration","n","edges","linkAccessor","rootGroup","modules","Array","roots","initModulesFromGroup","push","ModuleSet","i","add","this","Module","R","length","forEach","e","s","_this","getSourceIndex","t","getTargetIndex","getType","outgoing","incoming","group","moduleSet","leaves","node","module","id","groups","j","child","definition","prop","hasOwnProperty","LinkSets","merge","a","b","k","inInt","intersection","outInt","children","m","update","o","forAll","ms","linktype","nls","remove","count","rootMerges","rs","merges","ctr","i_","nEdges","greedyMerge","sort","getGroupHierarchy","retargetedEdges","toGroups","isLeaf","g","gid","isIsland","isPredefined","allEdges","_this2","es","getEdges","edgetype","_this3","Object","keys","table","other","result","v","intersectionCount","contains","f","mid","vs","forAllModules","sets","Number","lt","getGroups","nodes","links","la","c","powerEdges","end","unionCount","u","computeLinkLengths","w","neighbours","addNeighbours","getNeighbours","l","setLength","symmetricDiffLinkLengths","Math","sqrt","jaccardLinkLengths","min","generateDirectedEdgeConstraints","axis","components","stronglyConnectedComponents","constraints","ui","vi","left","right","gap","getMinSeparation","numVertices","index","stack","strongConnect","lowlink","onStack","out","component","pop","map","Locks","x","locks","clear","isEmpty","apply","Descent","D","G","wasm","PseudoRandom","xn","Float32Array","setupWasm","d","ia","ib","xtmp","minD","MAX_VALUE","computeDerivatives","packed","packedX","set","outX","compute_2d","ctxPtr","slice","subarray","Error","compute_3d","p","apply_lock_2d","apply_lock_3d","cleanWasmMemory","release_ctx_2d","allD","allG","dn","gn","Infinity","create_derivative_computer_ctx_2d","create_derivative_computer_ctx_3d","createSquareMatrix","M","offsetDir","random","getNextBetween","dotProd","rightMultiply","r","computeStepSize","compute_step_size_2d","compute_step_size_3d","reduceStress","alpha","thisG","takeDescentStep","computeStress","copy","stepAndProject","x0","stepSize","project","mApply","matrixApply","computeNextPosition","run","iterations","stress","converged","rungeKutta","abs","threshold","disp","_this4","nMinus1","dx","isFinite","rl","memory","get_memory","memoryView","buffer","gOffset","get_g_2d","get_g_3d","fill","_","_this5","newG","_this6","Gn","set_G_2d","set_G_3d","DOffset","get_D_2d","get_D_3d","_this7","seed","getNext","range","max","PositionStats","scale","addVariable","ai","wi","weight","AB","offset","AD","desiredPosition","A2","getPosn","Constraint","equality","slack","unsatisfiable","position","Variable","dfdv","block","ps","posn","visitNeighbours","prev","ff","next","active","cOut","cIn","Block","vars","updateWeightedPosition","compute_lm","postAction","_dfdv","lm","populateSplitBlock","traverse","visit","acc","findMinLM","findMinLMBetween","lv","rv","findPath","to","endFound","isActiveDirectedPathBetween","split","createSplitBlock","startVar","splitBetween","vl","vr","bs","constraint","lb","rb","mergeAcross","dist","cost","sum","Blocks","list","blockInd","insert","last","swapBlock","updateBlockPositions","inactive","Solver","LAGRANGIAN_TOLERANCE","nb","cs","setStartingPositions","setDesiredPositions","mostViolated","minSlack","deletePoint","ZERO_UPPERBOUND","satisfy","solve","lastcost","TreeBase","data","res","_root","iter","iterator","_comparator","_cursor","_ancestors","get_child","size","find","lowerBound","_bound","upperBound","cmp","Iterator","each","cb","it","reach","cur","tree","_tree","root","_minNode","save","_maxNode","start","Node","red","dir","set_child","val","RBTree","comparator","ret","head","undefined","gp","ggp","is_red","dir2","single_rotate","double_rotate","found","sr","sibling","gpc","computeGroupBounds","bounds","reduce","union","Rectangle","empty","inflate","padding","X","y","Y","POSITIVE_INFINITY","NEGATIVE_INFINITY","cx","cy","overlapX","ux","vx","overlapY","uy","vy","setXCentre","setYCentre","dy","width","height","lineIntersections","x1","y1","x2","y2","sides","intersections","lineIntersection","rayIntersection","ints","vertices","x3","y3","x4","y4","dx12","dx34","dy12","dy34","denominator","dx31","dy31","pad","makeEdgeBetween","ah","si","ti","al","sourceIntersection","targetIntersection","arrowStart","makeEdgeTo","pos","makeRBTree","Event","isOpen","compareEvents","xRect","getCentre","getOpen","getClose","getSize","makeRect","open","close","center","findNeighbours","scanline","forward","reverse","findIter","uovervX","yRect","generateGroupConstraints","minSep","isContained","ln","childConstraints","ccs","concat","minVar","maxVar","variable","generateConstraints","gapAdjustment","rect","N","console","assert","events","makeConstraint","sep","mkcon","generateXConstraints","generateYConstraints","generateXGroupConstraints","generateYGroupConstraints","IndexedVariable","Projection","avoidOverlaps","variables","createConstraints","w2","h2","stiffness","createSeparation","makeFeasible","dim","offsets","nextPos","createAlignment","xConstraints","yConstraints","isSep","filter","setupVariablesAndBounds","y0","desired","getDesired","fixed","fixedWeight","h","ix","iy","xProject","px","xmin","xmax","p2","yProject","py","ymin","ymax","projectFunctions","updateNodeBounds","updateGroupBounds","starting","solver","PairingHeap","elem","subheaps","toString","selector","str","needComma","subheap","isHeap","lessThan","every","obj","heap2","removeMin","mergePairs","firstPair","remaining","decreaseKey","newValue","setHeapNode","newHeap","pairingNode","PriorityQueue","top","arg","reduceKey","heapNode","newKey","Neighbour","distance","QueueEntry","Calculator","getLength","DistanceMatrix","dijkstraNeighbours","DistancesFromNode","PathFromNodeToNode","PathFromNodeToNodeWithPrevCost","prevCost","q","qu","visitedFrom","neighbour","viduid","cc","path","dest","Point","LineSegment","PolyPoint","isLeft","P0","P1","P2","above","vj","below","Rtangent_PointPolyC","P","V","dnC","floor","Ltangent_PointPolyC","tangent_PolyPolyC","W","t1","t2","cmp1","cmp2","ix1","ix2","done","RLtangent_PolyPolyC","BiTangent","BiTangents","TVGPoint","VisibilityVertex","polyid","polyvertid","vv","VisibilityEdge","TangentVisibilityGraph","g0","E","Pi","Pj","tangents","addEdgeIfVisible","i1","i2","intersectsPolys","addPoint","Vclosed","poly","rtan","ltan","intersects","int","bt","v1","v2","v3","w1","w3","v1v2w2","v2w1w2","v2w2w3","w1w2v2","w2v1v2","w2v2v3","ll","rr","lr","isAnyPInQ","isPointInsidePoly","packingOptions","applyPacking","graphs","node_size","desired_ratio","centerGraph","svg_width","svg_height","real_width","real_height","min_width","global_bottom","line","step","max_width","put_rect","parent","space_left","bottom","graph","min_x","min_y","max_x","max_y","array","calculate_bb","curr_best_f","curr_best","get_entire_width","iterationCounter","f_x1","f_x2","flag","df","put_nodes_to_right_positions","separateGraphs","marks","ways","clusters","link","n1","n2","explore_node","is_new","adjacent","setWasm","wasmModule","WebAssembly","instantiate","__wbindgen_memory","inst","exports","heap","heap_next","cachedFloat32Memory0","getFloat32Memory0","byteLength","WASM_VECTOR_LEN","passArrayF32ToWasm0","malloc","ptr","cachedInt32Memory0","getInt32Memory0","Int32Array","getArrayF32FromWasm0","len","idx","addHeapObject","ctx_ptr","node_count","ptr0","__wbindgen_malloc","len0","ptr1","retptr","__wbindgen_add_to_stack_pointer","r0","r1","__wbindgen_free","p_0","p_1","x_0_u","x_1_u","p_2","x_2_u","getObject","dropObject","ctx","new_G","EventType","WasmInst","getter","get","value","pending","Promise","resolve","then","validate","Uint8Array","getHasSIMDSupport","hasWasmSIMDSupport","window","location","href","includes","log","wasmSIMD","wasmNoSIMD_bg","wasmNoSIMD","getDerivativeComputerWasm","wasmInstPromise","isGroup","Layout","setLinkLength","_linkType","on","listener","event","trigger","kick","tick","_alpha","_threshold","_running","_lastStress","_nodes","_descent","s1","updateNodePositions","_links","_groups","_rootGroup","gi","powerGraphGroups","powergraph","arguments","_avoidOverlaps","handleDisconnected","_handleDisconnected","flowLayout","minSeparation","_directedLinkConstraints","_constraints","distanceMatrix","_distanceMatrix","_canvasSize","defaultNodeSize","_defaultNodeSize","groupCompactness","_groupCompactness","linkDistance","_linkDistance","_linkLengthCalculator","linkType","convergenceThreshold","getLinkLength","getLinkType","idealLength","initialUnconstrainedIterations","initialUserConstraintIterations","initialAllConstraintsIterations","gridSnapIterations","keepRunning","distances","ao","strength","idealDistance","addAttraction","curConstraints","wasmInst","initialLayout","separateOverlappingComponents","resume","gg","pause","stop","prepareEdgeRouting","nodeMargin","_visibilityGraph","routeEdge","edge","draw","lineData","vg2","port1","port2","shortestPath","route","innerBounds","linkId","dragStart","storeOffset","dragOrigin","stopNode","origin","_dragGroupOffsetX","_dragGroupOffsetY","drag","dragEnd","mouseOver","mouseOut","LayoutAdaptor","options","dragstart","dragend","eventType","D3StyleLayoutAdaptor","d3Context","self","d3","dispatch","d3layout","behavior","call","d3event","timer","D3v4StyleLayoutAdaptor","subject","_Layout","NodeWrapper","leaf","Vert","LongestCommonSubsequence","mf","findMatch","tr","mr","reversed","match","getSequence","GridRouter","originalnodes","accessor","groupPadding","getBounds","getChildren","cols","getGridLines","rows","ports","backToFront","getDepth","colMids","midPoints","rowMids","rowx","rowX","coly","colY","hlines","vlines","lines","verts","li","intersect","isHoriz","delta","avg","columns","ls","overlapping","toUpperCase","col","splice","indexOf","depth","mids","findLineage","lineage","findAncestorPathBetween","aa","ba","commonAncestor","lineages","siblingObstacles","lineageLookup","obstacles","getSegmentSets","routes","vsegments","ei","edgeid","vsegmentsets","segmentset","segments","nudgeSegs","leftOf","e1","e2","lind","rind","nudgeSegments","ss","openCount","routeEdges","nudgeGap","routePaths","order","orderEdges","makeSegments","unreverseEdges","segment","angleBetween2Lines","line1","line2","angle1","atan2","angle2","diff","PI","getOrder","pairs","edgeOrder","lcs","copyPoint","isStraight","obstacleLookup","passableEdges","pathPoints","getRoutePath","cornerradius","arrowwidth","arrowheight","arrowcorner1","arrowcorner2","routepath","arrowpath","angle","arrowtip","Link3D","actualLength","Layout3D","idealLinkLength","dims","z","linkLength","LinkAccessor","useJaccardLinkLengths","descent","S","minmax","H","maxmin","maxmax","bot","version","isD3V3","pgLayout","margin","groupMargin","cola","routerNode","name","gridRouterNodes","powerGraph","grouppadding","sourceInd","spans","desiredCenter","leftMost","rightMost","leftMostSize","rightMostSize","vLower","vUpper","newCenters"],"mappings":"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"}