{"version":3,"file":"cola.umd.production.min.js","sources":["../src/powergraph.ts","../src/linklengths.ts","../src/descent.ts","../src/vpsc.ts","../src/rbtree.ts","../src/rectangle.ts","../src/pqueue.ts","../src/shortestpaths.ts","../src/geom.ts","../src/handledisconnected.ts","../src/wasm/build/simd/derivative_computer_bg.js","../src/wasm/build/no_simd/derivative_computer_bg.js","../src/layout.ts","../src/wasmEngine.ts","../src/adaptor.ts","../src/d3v3adaptor.ts","../src/d3v4adaptor.ts","../src/gridrouter.ts","../src/layout3d.ts","../src/d3adaptor.ts","../src/batch.ts"],"sourcesContent":["import {LinkAccessor} from './linklengths'\n\nexport interface LinkTypeAccessor<Link> extends LinkAccessor<Link> {\n        // return a unique identifier for the type of the link\n        getType(l: Link): number;\n    }\n\n    export class PowerEdge {\n        constructor(\n            public source: any,\n            public target: any,\n            public type: number) { }\n    }\n\n    export class Configuration<Link> {\n        // canonical list of modules.\n        // Initialized to a module for each leaf node, such that the ids and indexes of the module in the array match the indexes of the nodes in links\n        // Modules created through merges are appended to the end of this.\n        modules: Module[];\n        // top level modules and candidates for merges\n        roots: ModuleSet[];\n        // remaining edge count\n        R: number;\n        constructor(n: number, edges: Link[], private linkAccessor: LinkTypeAccessor<Link>, rootGroup?: any[]) {\n            this.modules = new Array(n);\n            this.roots = [];\n            if (rootGroup) {\n                this.initModulesFromGroup(rootGroup);\n            } else {\n                this.roots.push(new ModuleSet());\n                for (var i = 0; i < n; ++i)\n                    this.roots[0].add(this.modules[i] = new Module(i));\n            }\n            this.R = edges.length;\n            edges.forEach(e => {\n                var s = this.modules[linkAccessor.getSourceIndex(e)],\n                    t = this.modules[linkAccessor.getTargetIndex(e)],\n                    type = linkAccessor.getType(e);\n                s.outgoing.add(type, t);\n                t.incoming.add(type, s);\n            });\n        }\n\n        private initModulesFromGroup(group): ModuleSet {\n            var moduleSet = new ModuleSet();\n            this.roots.push(moduleSet);\n            for (var i = 0; i < group.leaves.length; ++i) {\n                var node = group.leaves[i];\n                var module = new Module(node.id);\n                this.modules[node.id] = module;\n                moduleSet.add(module);\n            }\n            if (group.groups) {\n                for (var j = 0; j < group.groups.length; ++j) {\n                    var child = group.groups[j];\n                    // Propagate group properties (like padding, stiffness, ...) as module definition so that the generated power graph group will inherit it\n                    var definition = {};\n                    for (var prop in child)\n                        if (prop !== \"leaves\" && prop !== \"groups\" && child.hasOwnProperty(prop))\n                            definition[prop] = child[prop];\n                    // Use negative module id to avoid clashes between predefined and generated modules\n                    moduleSet.add(new Module(-1-j, new LinkSets(), new LinkSets(), this.initModulesFromGroup(child), definition));\n                }\n            }\n            return moduleSet;\n         }\n\n        // merge modules a and b keeping track of their power edges and removing the from roots\n        merge(a: Module, b: Module, k: number = 0): Module {\n            var inInt = a.incoming.intersection(b.incoming),\n                outInt = a.outgoing.intersection(b.outgoing);\n            var children = new ModuleSet();\n            children.add(a);\n            children.add(b);\n            var m = new Module(this.modules.length, outInt, inInt, children);\n            this.modules.push(m);\n            var update = (s: LinkSets, i: string, o: string) => {\n                s.forAll((ms, linktype) => {\n                    ms.forAll(n => {\n                        var nls = <LinkSets>n[i];\n                        nls.add(linktype, m);\n                        nls.remove(linktype, a);\n                        nls.remove(linktype, b);\n                        (<LinkSets>a[o]).remove(linktype, n);\n                        (<LinkSets>b[o]).remove(linktype, n);\n                    });\n                });\n            };\n            update(outInt, \"incoming\", \"outgoing\");\n            update(inInt, \"outgoing\", \"incoming\");\n            this.R -= inInt.count() + outInt.count();\n            this.roots[k].remove(a);\n            this.roots[k].remove(b);\n            this.roots[k].add(m);\n            return m;\n        }\n\n        private rootMerges(k: number = 0): {\n            id: number;\n            nEdges: number;\n            a: Module;\n            b: Module;\n        }[] {\n            var rs = this.roots[k].modules();\n            var n = rs.length;\n            var merges = new Array(n * (n - 1));\n            var ctr = 0;\n            for (var i = 0, i_ = n - 1; i < i_; ++i) {\n                for (var j = i+1; j < n; ++j) {\n                    var a = rs[i], b = rs[j];\n                    merges[ctr] = { id: ctr, nEdges: this.nEdges(a, b), a: a, b: b };\n                    ctr++;\n                }\n            }\n            return merges;\n        }\n\n        greedyMerge(): boolean {\n            for (var i = 0; i < this.roots.length; ++i) {\n                // Handle single nested module case\n                if (this.roots[i].modules().length < 2) continue;\n\n                // find the merge that allows for the most edges to be removed.  secondary ordering based on arbitrary id (for predictability)\n                var ms = this.rootMerges(i).sort((a, b) => a.nEdges == b.nEdges ? a.id - b.id : a.nEdges - b.nEdges);\n                var m = ms[0];\n                if (m.nEdges >= this.R) continue;\n                this.merge(m.a, m.b, i);\n                return true;\n            }\n        }\n\n        private nEdges(a: Module, b: Module): number {\n            var inInt = a.incoming.intersection(b.incoming),\n                outInt = a.outgoing.intersection(b.outgoing);\n            return this.R - inInt.count() - outInt.count();\n        }\n\n        getGroupHierarchy(retargetedEdges: PowerEdge[]): any[]{\n            var groups = [];\n            var root = {};\n            toGroups(this.roots[0], root, groups);\n            var es = this.allEdges();\n            es.forEach(e => {\n                var a = this.modules[e.source];\n                var b = this.modules[e.target];\n                retargetedEdges.push(new PowerEdge(\n                    typeof a.gid === \"undefined\" ? e.source : groups[a.gid],\n                    typeof b.gid === \"undefined\" ? e.target : groups[b.gid],\n                    e.type\n                ));\n            });\n            return groups;\n        }\n\n        allEdges(): PowerEdge[] {\n            var es = [];\n            Configuration.getEdges(this.roots[0], es);\n            return es;\n        }\n\n        static getEdges(modules: ModuleSet, es: PowerEdge[]) {\n            modules.forAll(m => {\n                m.getEdges(es);\n                Configuration.getEdges(m.children, es);\n            });\n        }\n    }\n\n    function toGroups(modules: ModuleSet, group, groups) {\n        modules.forAll(m => {\n            if (m.isLeaf()) {\n                if (!group.leaves) group.leaves = [];\n                group.leaves.push(m.id);\n            } else {\n                var g = group;\n                m.gid = groups.length;\n                if (!m.isIsland() || m.isPredefined()) {\n                    g = { id: m.gid };\n                    if (m.isPredefined())\n                        // Apply original group properties\n                        for (var prop in m.definition)\n                            g[prop] = m.definition[prop];\n                    if (!group.groups) group.groups = [];\n                    group.groups.push(m.gid);\n                    groups.push(g);\n                }\n                toGroups(m.children, g, groups);\n            }\n        });\n    }\n\n    export class Module {\n        gid: number;\n\n        constructor(\n            public id: number,\n            public outgoing: LinkSets = new LinkSets(),\n            public incoming: LinkSets = new LinkSets(),\n            public children: ModuleSet = new ModuleSet(),\n            public definition?: any) { }\n\n        getEdges(es: PowerEdge[]) {\n            this.outgoing.forAll((ms, edgetype) => {\n                ms.forAll(target => {\n                    es.push(new PowerEdge(this.id, target.id, edgetype));\n                });\n            });\n        }\n\n        isLeaf() {\n            return this.children.count() === 0;\n        }\n\n        isIsland() {\n            return this.outgoing.count() === 0 && this.incoming.count() === 0;\n        }\n\n        isPredefined(): boolean {\n            return typeof this.definition !== \"undefined\";\n        }\n    }\n\n    function intersection(m: any, n: any): any {\n        var i = {};\n        for (var v in m) if (v in n) i[v] = m[v];\n        return i;\n    }\n\n    export class ModuleSet {\n        table: any = {};\n        count() {\n            return Object.keys(this.table).length;\n        }\n        intersection(other: ModuleSet): ModuleSet {\n            var result = new ModuleSet();\n            result.table = intersection(this.table, other.table);\n            return result;\n        }\n        intersectionCount(other: ModuleSet): number {\n            return this.intersection(other).count();\n        }\n        contains(id: number): boolean {\n            return id in this.table;\n        }\n        add(m: Module): void {\n            this.table[m.id] = m;\n        }\n        remove(m: Module): void {\n            delete this.table[m.id];\n        }\n        forAll(f: (m: Module) => void) {\n            for (var mid in this.table) {\n                f(this.table[mid]);\n            }\n        }\n        modules(): Module[] {\n            var vs = [];\n            this.forAll(m => {\n                if (!m.isPredefined())\n                    vs.push(m);\n            });\n            return vs;\n        }\n    }\n\n    export class LinkSets {\n        sets: any = {};\n        n: number = 0;\n        count(): number {\n            return this.n;\n        }\n        contains(id: number) {\n            var result = false;\n            this.forAllModules(m => {\n                if (!result && m.id == id) {\n                    result = true;\n                }\n            });\n            return result;\n        }\n        add(linktype: number, m: Module) {\n            var s: ModuleSet = linktype in this.sets ? this.sets[linktype] : this.sets[linktype] = new ModuleSet();\n            s.add(m);\n            ++this.n;\n        }\n        remove(linktype: number, m: Module) {\n            var ms = <ModuleSet>this.sets[linktype];\n            ms.remove(m);\n            if (ms.count() === 0) {\n                delete this.sets[linktype];\n            }\n            --this.n;\n        }\n        forAll(f: (ms: ModuleSet, linktype: number) => void) {\n            for (var linktype in this.sets) {\n                f(<ModuleSet>this.sets[linktype], Number(linktype));\n            }\n        }\n        forAllModules(f: (m: Module) => void) {\n            this.forAll((ms, lt) => ms.forAll(f));\n        }\n        intersection(other: LinkSets): LinkSets {\n            var result: LinkSets = new LinkSets();\n            this.forAll((ms, lt) => {\n                if (lt in other.sets) {\n                    var i = ms.intersection(other.sets[lt]),\n                        n = i.count();\n                    if (n > 0) {\n                        result.sets[lt] = i;\n                        result.n += n;\n                    }\n                }\n            });\n            return result;\n        }\n    }\n\n    function intersectionCount(m: any, n: any): number {\n        return Object.keys(intersection(m, n)).length\n    }\n\n    export function getGroups<Link>(nodes: any[], links: Link[], la: LinkTypeAccessor<Link>, rootGroup?: any[]): { groups: any[]; powerEdges: PowerEdge[] } {\n        var n = nodes.length,\n            c = new Configuration(n, links, la, rootGroup);\n        while (c.greedyMerge());\n        var powerEdges: PowerEdge[] = [];\n        var g = c.getGroupHierarchy(powerEdges);\n        powerEdges.forEach(function (e) {\n            var f = (end) => {\n                var g = e[end];\n                if (typeof g == \"number\") e[end] = nodes[g];\n            };\n            f(\"source\");\n            f(\"target\");\n        });\n        return { groups: g, powerEdges: powerEdges };\n    }\n","    export interface LinkAccessor<Link> {\n        getSourceIndex(l: Link): number;\n        getTargetIndex(l: Link): number;\n    }\n\n    export interface LinkLengthAccessor<Link> extends LinkAccessor<Link> {\n        setLength(l: Link, value: number): void;\n    }\n\n    // compute the size of the union of two sets a and b\n    function unionCount(a: any, b: any): number {\n        var u = {};\n        for (var i in a) u[i] = {};\n        for (var i in b) u[i] = {};\n        return Object.keys(u).length;\n    }\n\n    // compute the size of the intersection of two sets a and b\n    function intersectionCount(a: number[], b: number[]): number {\n        var n = 0;\n        for (var i in a) if (typeof b[i] !== 'undefined') ++n;\n        return n;\n    }\n\n    function getNeighbours<Link>(links: Link[], la: LinkAccessor<Link>): any {\n        var neighbours = {};\n        var addNeighbours = (u, v) => {\n            if (typeof neighbours[u] === 'undefined')\n                neighbours[u] = {};\n            neighbours[u][v] = {};\n        };\n        links.forEach(e => {\n            var u = la.getSourceIndex(e), v = la.getTargetIndex(e);\n            addNeighbours(u, v);\n            addNeighbours(v, u);\n        });\n        return neighbours;\n    }\n\n    // modify the lengths of the specified links by the result of function f weighted by w\n    function computeLinkLengths<Link>(links: Link[], w: number, f: (a: any, b: any) => number, la: LinkLengthAccessor<Link>) {\n        var neighbours = getNeighbours(links, la);\n        links.forEach(l => {\n            var a = neighbours[la.getSourceIndex(l)];\n            var b = neighbours[la.getTargetIndex(l)];\n            la.setLength(l, 1 + w * f(a, b));\n        });\n    }\n\n    /** modify the specified link lengths based on the symmetric difference of their neighbours\n     * @class symmetricDiffLinkLengths\n     */\n    export function symmetricDiffLinkLengths<Link>(links: Link[], la: LinkLengthAccessor<Link>, w: number = 1) {\n        computeLinkLengths(links, w, (a, b) => Math.sqrt(unionCount(a, b) - intersectionCount(a, b)), la);\n    }\n\n    /** modify the specified links lengths based on the jaccard difference between their neighbours\n     * @class jaccardLinkLengths\n     */\n    export function jaccardLinkLengths<Link>(links: Link[], la: LinkLengthAccessor<Link>, w: number = 1) {\n        computeLinkLengths(links, w, (a, b) =>\n            Math.min(Object.keys(a).length, Object.keys(b).length) < 1.1 ? 0 : intersectionCount(a, b) / unionCount(a, b)\n            , la);\n    }\n\n    export interface IConstraint {\n        left: number;\n        right: number;\n        gap: number;\n    }\n\n    export interface DirectedEdgeConstraints {\n        axis: string;\n        gap: number;\n    }\n\n    export interface LinkSepAccessor<Link> extends LinkAccessor<Link> {\n        getMinSeparation(l: Link): number;\n    }\n\n    /** generate separation constraints for all edges unless both their source and sink are in the same strongly connected component\n     * @class generateDirectedEdgeConstraints\n     */\n    export function generateDirectedEdgeConstraints<Link>(n: number, links: Link[], axis: string,\n        la: LinkSepAccessor<Link>): IConstraint[]\n    {\n        var components = stronglyConnectedComponents(n, links, la);\n        var nodes = {};\n        components.forEach((c,i) =>\n            c.forEach(v => nodes[v] = i)\n        );\n        var constraints: any[] = [];\n        links.forEach(l => {\n            var ui = la.getSourceIndex(l), vi = la.getTargetIndex(l),\n                u = nodes[ui], v = nodes[vi];\n            if (u !== v) {\n                constraints.push({\n                    axis: axis,\n                    left: ui,\n                    right: vi,\n                    gap: la.getMinSeparation(l)\n                });\n            }\n        });\n        return constraints;\n    }\n\n    /**\n     * Tarjan's strongly connected components algorithm for directed graphs\n     * returns an array of arrays of node indicies in each of the strongly connected components.\n     * a vertex not in a SCC of two or more nodes is it's own SCC.\n     * adaptation of https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n     */\n    export function stronglyConnectedComponents<Link>(numVertices: number, edges: Link[], la: LinkAccessor<Link>): number[][]{\n        var nodes = [];\n        var index = 0;\n        var stack = [];\n        var components = [];\n        function strongConnect(v) {\n            // Set the depth index for v to the smallest unused index\n            v.index = v.lowlink = index++;\n            stack.push(v);\n            v.onStack = true;\n\n            // Consider successors of v\n            for (var w of v.out) {\n                if (typeof w.index === 'undefined') {\n                    // Successor w has not yet been visited; recurse on it\n                    strongConnect(w);\n                    v.lowlink = Math.min(v.lowlink, w.lowlink);\n                } else if (w.onStack) {\n                    // Successor w is in stack S and hence in the current SCC\n                    v.lowlink = Math.min(v.lowlink, w.index);\n                }\n            }\n\n            // If v is a root node, pop the stack and generate an SCC\n            if (v.lowlink === v.index) {\n                // start a new strongly connected component\n                var component = [];\n                while (stack.length) {\n                    w = stack.pop();\n                    w.onStack = false;\n                    //add w to current strongly connected component\n                    component.push(w);\n                    if (w === v) break;\n                }\n                // output the current strongly connected component\n                components.push(component.map(v => v.id));\n            }\n        }\n        for (var i = 0; i < numVertices; i++) {\n            nodes.push({id: i, out: []});\n        }\n        for (var e of edges) {\n            let v = nodes[la.getSourceIndex(e)],\n                w = nodes[la.getTargetIndex(e)];\n            v.out.push(w);\n        }\n        for (var v of nodes) if (typeof v.index === 'undefined') strongConnect(v);\n        return components;\n    }\n","import type { DerivativeComputerWasmInst } from \"wasmEngine\";\n\n    /**\n     * Descent respects a collection of locks over nodes that should not move\n     * @class Locks\n     */\n    export class Locks {\n        locks: { [key:number]:number[]} = {};\n        /**\n         * add a lock on the node at index id\n         * @method add\n         * @param id index of node to be locked\n         * @param x required position for node\n         */\n        add(id: number, x: number[]) {\n/* DEBUG\n            if (isNaN(x[0]) || isNaN(x[1])) debugger;\nDEBUG */\n            this.locks[id] = x;\n        }\n        /**\n         * @method clear clear all locks\n         */\n        clear() {\n            this.locks = {};\n        }\n        /**\n         * @isEmpty\n         * @returns false if no locks exist\n         */\n        isEmpty(): boolean {\n            for (var l in this.locks) return false;\n            return true;\n        }\n        /**\n         * perform an operation on each lock\n         * @apply\n         */\n        apply(f: (id: number, x: number[]) => void) {\n            for (var l in this.locks) {\n                f(Number(l), this.locks[l]);\n            }\n        }\n    }\n\n    const BYTES_PER_F32 = 32 / 8;\n\n    /**\n     * Uses a gradient descent approach to reduce a stress or p-stress goal function over a graph with specified ideal edge lengths or a square matrix of dissimilarities.\n     * The standard stress function over a graph nodes with position vectors x,y,z is (mathematica input):\n     *   stress[x_,y_,z_,D_,w_]:=Sum[w[[i,j]] (length[x[[i]],y[[i]],z[[i]],x[[j]],y[[j]],z[[j]]]-d[[i,j]])^2,{i,Length[x]-1},{j,i+1,Length[x]}]\n     * where: D is a square matrix of ideal separations between nodes, w is matrix of weights for those separations\n     *        length[x1_, y1_, z1_, x2_, y2_, z2_] = Sqrt[(x1 - x2)^2 + (y1 - y2)^2 + (z1 - z2)^2]\n     * below, we use wij = 1/(Dij^2)\n     *\n     * @class Descent\n     */\n    export class Descent {\n        private wasm: DerivativeComputerWasmInst;\n        private ctxPtr: number;\n        private ptr0: number;\n        private size0: number;\n        private ptr1: number;\n        private size1: number;\n\n        private ptr2: number;\n        private size2: number;\n\n        public threshold: number = 0.0001;\n        /** gradient vector\n         * @property g {Float32Array[]}\n         */\n        public get g(): Float32Array[] {\n            const memory: WebAssembly.Memory = this.wasm.get_memory();\n            const memoryView = new Float32Array(memory.buffer);\n\n            const gPtr = this.k === 2 ? this.wasm.get_g_2d(this.ctxPtr) : this.wasm.get_g_3d(this.ctxPtr);\n            const gOffset = gPtr / BYTES_PER_F32;\n            return new Array(this.k)\n                .fill(null)\n                .map((_, i) => memoryView.subarray(gOffset + i * this.n, gOffset + i * this.n + this.n));\n        }\n        public set G(newG: Float32Array[] | null)  {\n            const allG = (() => {\n                if (newG) {\n                    const allG = new Float32Array(this.n * this.n);\n                    newG.forEach((Gn, i) => allG.set(Gn, i * this.n));\n                    return allG;\n                } else {\n                    return new Float32Array();\n                }\n            })();\n\n            if (this.k === 2) {\n                // @ts-ignore\n                this.ptr2 = this.wasm.set_G_2d(this.ctxPtr, allG);\n                this.size2 = allG.length * 4;\n            } else if (this.k === 3) {\n                // @ts-ignore\n                this.ptr2 = this.wasm.set_G_3d(this.ctxPtr, allG);\n                this.size2 = allG.length * 4;\n            } else {\n                throw new Error('Invalid dimensionality');\n            }\n        }\n       /** positions vector\n         * @property x {number[][]}\n         */\n        public x: Float32Array[];\n        /**\n         * @property k {number} dimensionality\n         */\n        public k: number;\n        /**\n         * number of data-points / nodes / size of vectors/matrices\n         * @property n {number}\n         */\n        public n: number;\n        /**\n         * matrix of desired distances between pairs of nodes\n         */\n         public get D(): Float32Array[] {\n            const memory: WebAssembly.Memory = this.wasm.get_memory();\n            const memoryView = new Float32Array(memory.buffer);\n\n            const DPtr = this.k === 2 ? this.wasm.get_D_2d(this.ctxPtr) : this.wasm.get_D_3d(this.ctxPtr);\n            const DOffset = DPtr / BYTES_PER_F32;\n            return new Array(this.n)\n                .fill(null)\n                .map((_, i) => memoryView.subarray(DOffset + i * this.n, DOffset + i * this.n + this.n));\n        }\n\n        public computeDerivatives(x: Float32Array[]) {\n            if (this.k === 2) {\n                const packedX = (() => {\n                    const packed = new Float32Array(x[0].length * this.k);\n                    x.forEach((xn, i) => packed.set(xn, i * this.n));\n                    return packed;\n                })();\n                const outX = this.wasm.compute_2d(this.ctxPtr, packedX);\n\n                if (x) {\n                    x.forEach((xn, i) => {\n                        const slice = outX.subarray(i * this.n, i * this.n + this.n);\n                        xn.set(slice);\n                    })\n                }\n            } else if (this.k === 3) {\n                const packedX = (() => {\n                    const packed = new Float32Array(x[0].length * this.k);\n                    x.forEach((xn, i) => packed.set(xn, i * this.n));\n                    return packed;\n                })();\n                const outX = this.wasm.compute_3d(this.ctxPtr, packedX);\n\n                if (x) {\n                    x.forEach((xn, i) => {\n                        const slice = outX.subarray(i * this.n, i * this.n + this.n);\n                        xn.set(slice);\n                    })\n                }\n            } else {\n                throw new Error('Invalid dimensionality');\n            }\n\n            if (!this.locks.isEmpty()) {\n                this.locks.apply((u, p) => {\n                    if (this.k === 2) {\n                        this.wasm.apply_lock_2d(this.ctxPtr, u, p[0], p[1], x[0][u], x[1][u]);\n                    } else if (this.k === 3) {\n                        this.wasm.apply_lock_3d(this.ctxPtr, u, p[0], p[1], p[2], x[0][u], x[1][u], x[2][u]);\n                    } else {\n                        throw new Error('Invalid dimensionality');\n                    }\n                });\n            }\n        }\n\n        public locks: Locks;\n\n        private static zeroDistance: number = 1e-10;\n        private minD: number;\n\n        // pool of arrays of size n used internally, allocated in constructor\n        private a: Float32Array[];\n        private b: Float32Array[];\n        private c: Float32Array[];\n        private d: Float32Array[];\n        private e: Float32Array[];\n        private ia: Float32Array[];\n        private ib: Float32Array[];\n        private xtmp: number[][];\n\n\n        // Parameters for grid snap stress.\n        // TODO: Make a pluggable \"StressTerm\" class instead of this\n        // mess.\n        public numGridSnapNodes: number = 0;\n        public snapGridSize: number = 100;\n        public snapStrength: number = 1000;\n        public scaleSnapByMaxH: boolean = false;\n\n        private random = new PseudoRandom();\n\n        public project: { (x0: Float32Array, y0: Float32Array, r: Float32Array): void }[] = null;\n\n        public cleanWasmMemory() {\n            // @ts-ignore\n            this.wasm.getWasm().__wbindgen_free(this.ptr0, this.size0);\n            // @ts-ignore\n            this.wasm.getWasm().__wbindgen_free(this.ptr1, this.size1);\n            // @ts-ignore\n            this.wasm.getWasm().__wbindgen_free(this.ptr2, this.size2);\n        }\n\n        private setupWasm(D: number[][], G: number[][] | null = null) {\n            const allD = new Float32Array(this.n * this.n);\n            const allG = G ? new Float32Array(this.n * this.k) : new Float32Array(0);\n            D.forEach((dn, i) => {\n                allD.set(dn, i * this.n);\n            });\n            if (G) {\n                G.forEach((gn, i) => {\n                    allG.set(gn, i * this.n);\n                });\n            }\n\n            allD.forEach((d, i) => {\n                if (d === Infinity) {\n                    allD[i] = -10000000; // ideal distance\n                    allG[i] = 1000.; // weight\n                }\n            });\n\n            const createrFn = this.k === 2 ? this.wasm.create_derivative_computer_ctx_2d : this.wasm.create_derivative_computer_ctx_3d;\n            const arr = createrFn(this.n, allD, allG) as any as [number, number, number];;\n            const [ctxPtr, ptr0, ptr1] = arr;\n            this.ctxPtr = ctxPtr;\n            this.ptr0 = ptr0;\n            this.ptr1 = ptr1;\n            this.size0 = allD.length * 4;\n            this.size1 = allG.length * 4;\n        }\n\n        /**\n         * @method constructor\n         * @param x {number[][]} initial coordinates for nodes\n         * @param D {number[][]} matrix of desired distances between pairs of nodes\n         * @param G {number[][]} [default=null] if specified, G is a matrix of weights for goal terms between pairs of nodes.\n         * If G[i][j] > 1 and the separation between nodes i and j is greater than their ideal distance, then there is no contribution for this pair to the goal\n         * If G[i][j] <= 1 then it is used as a weighting on the contribution of the variance between ideal and actual separation between i and j to the goal function\n         */\n        constructor(x: number[][], D: number[][], G: number[][] = null, wasm: DerivativeComputerWasmInst) {\n            this.wasm = wasm;\n            this.x = x.map(xn => new Float32Array(xn));\n            this.k = x.length; // dimensionality\n            var n = this.n = x[0].length; // number of nodes\n\n            // Set up Wasm context\n            this.setupWasm(D, G);\n\n            this.a = new Array(this.k);\n            this.b = new Array(this.k);\n            this.c = new Array(this.k);\n            this.d = new Array(this.k);\n            this.e = new Array(this.k);\n            this.ia = new Array(this.k);\n            this.ib = new Array(this.k);\n            this.xtmp = new Array(this.k);\n            this.locks = new Locks();\n            this.minD = Number.MAX_VALUE;\n            var i = n, j;\n            while (i--) {\n                j = n;\n                while (--j > i) {\n                    var d = D[i][j];\n                    if (d > 0 && d < this.minD) {\n                        this.minD = d;\n                    }\n                }\n            }\n            if (this.minD === Number.MAX_VALUE) this.minD = 1;\n            i = this.k;\n            while (i--) {\n                j = n;\n                this.a[i] = new Float32Array(n);\n                this.b[i] = new Float32Array(n);\n                this.c[i] = new Float32Array(n);\n                this.d[i] = new Float32Array(n);\n                this.e[i] = new Float32Array(n);\n                this.ia[i] = new Float32Array(n);\n                this.ib[i] = new Float32Array(n);\n                this.xtmp[i] = new Array(n);\n            }\n        }\n\n        public static createSquareMatrix(n: number, f: (i: number, j: number) => number): number[][] {\n            var M = new Array(n);\n            for (var i = 0; i < n; ++i) {\n                M[i] = new Array(n);\n                for (var j = 0; j < n; ++j) {\n                    M[i][j] = f(i, j);\n                }\n            }\n            return M;\n        }\n\n        private offsetDir(): number[] {\n            var u = new Array(this.k);\n            var l = 0;\n            for (var i = 0; i < this.k; ++i) {\n                var x = u[i] = this.random.getNextBetween(0.01, 1) - 0.5;\n                l += x * x;\n            }\n            l = Math.sqrt(l);\n            return u.map(x=> x *= this.minD / l);\n        }\n\n        private static dotProd(a: Float32Array, b: Float32Array): number {\n            var x = 0, i = a.length;\n            while (i--) x += a[i] * b[i];\n            return x;\n        }\n\n        // result r = matrix m * vector v\n        private static rightMultiply(m: Float32Array[], v: Float32Array, r: Float32Array) {\n            var i = m.length;\n            while (i--) r[i] = Descent.dotProd(m[i], v);\n        }\n\n        // computes the optimal step size to take in direction d using the\n        // derivative information in this.g and this.H\n        // returns the scalar multiplier to apply to d to get the optimal step\n        public computeStepSize(): number {\n            if (this.k === 2) {\n                return this.wasm.compute_step_size_2d(this.ctxPtr);\n            } else if (this.k === 3) {\n                return this.wasm.compute_step_size_3d(this.ctxPtr);\n            } else {\n                throw new Error('Invalid dimensionality');\n            }\n        }\n\n        public reduceStress(): number {\n            this.computeDerivatives(this.x);\n            var alpha = this.computeStepSize();\n            const thisG = this.g;\n            for (var i = 0; i < this.k; ++i) {\n                this.takeDescentStep(this.x[i], thisG[i], alpha);\n            }\n            return this.computeStress();\n        }\n\n        private static copy(a: Float32Array[], b: Float32Array[]): void {\n            var m = a.length, n = b[0].length;\n            for (var i = 0; i < m; ++i) {\n                for (var j = 0; j < n; ++j) {\n                    b[i][j] = a[i][j];\n                }\n            }\n        }\n\n        // takes a step of stepSize * d from x0, and then project against any constraints.\n        // result is returned in r.\n        // x0: starting positions\n        // r: result positions will be returned here\n        // d: unconstrained descent vector\n        // stepSize: amount to step along d\n        private stepAndProject(x0: Float32Array[], r: Float32Array[], d: Float32Array[], stepSize: number): void {\n            Descent.copy(x0, r);\n            this.takeDescentStep(r[0], d[0], stepSize);\n            if (this.project) this.project[0](x0[0], x0[1], r[0]);\n            this.takeDescentStep(r[1], d[1], stepSize);\n            if (this.project) this.project[1](r[0], x0[1], r[1]);\n\n            // todo: allow projection against constraints in higher dimensions\n            for (var i = 2; i < this.k; i++)\n                this.takeDescentStep(r[i], d[i], stepSize);\n\n            // the following makes locks extra sticky... but hides the result of the projection from the consumer\n            //if (!this.locks.isEmpty()) {\n            //    this.locks.apply((u, p) => {\n            //        for (var i = 0; i < this.k; i++) {\n            //            r[i][u] = p[i];\n            //        }\n            //    });\n            //}\n        }\n\n        private static mApply(m: number, n: number, f: (i: number, j: number) => any) {\n            var i = m; while (i-- > 0) {\n                var j = n; while (j-- > 0) f(i, j);\n            }\n        }\n        private matrixApply(f: (i: number, j: number) => any) {\n            Descent.mApply(this.k, this.n, f);\n        }\n\n        private computeNextPosition(x0: Float32Array[], r: Float32Array[]): void {\n            this.computeDerivatives(x0);\n            const alpha = this.computeStepSize();\n            this.stepAndProject(x0, r, this.g, alpha);\n/* DEBUG\n            for (var u: number = 0; u < this.n; ++u)\n                for (var i = 0; i < this.k; ++i)\n                    if (isNaN(r[i][u])) debugger;\nDEBUG */\n            if (this.project) {\n                // This functionality is not yet implemented with the Wasm port\n                throw new Error('Computing step with with `this.project` set is not yet implemented in Wasm port');\n                // this.matrixApply((i, j) => this.e[i][j] = x0[i][j] - r[i][j]);\n                // var beta = this.computeStepSize(this.e);\n                // beta = Math.max(0.2, Math.min(beta, 1));\n                // this.stepAndProject(x0, r, this.e, beta);\n            }\n        }\n\n        public run(iterations: number): number {\n            var stress = Number.MAX_VALUE, converged = false;\n            while (!converged && iterations-- > 0) {\n                var s = this.rungeKutta();\n                converged = Math.abs(stress / s - 1) < this.threshold;\n                stress = s;\n            }\n            return stress;\n        }\n\n        public rungeKutta(): number {\n            this.computeNextPosition(this.x, this.a);\n            Descent.mid(this.x, this.a, this.ia);\n            this.computeNextPosition(this.ia, this.b);\n            Descent.mid(this.x, this.b, this.ib);\n            this.computeNextPosition(this.ib, this.c);\n            this.computeNextPosition(this.c, this.d);\n            var disp = 0;\n            this.matrixApply((i, j) => {\n                var x = (this.a[i][j] + 2.0 * this.b[i][j] + 2.0 * this.c[i][j] + this.d[i][j]) / 6.0,\n                    d = this.x[i][j] - x;\n                disp += d * d;\n                this.x[i][j] = x;\n            });\n            return disp;\n        }\n\n        private static mid(a: Float32Array[], b: Float32Array[], m: Float32Array[]): void {\n            Descent.mApply(a.length, a[0].length, (i, j) =>\n                m[i][j] = a[i][j] + (b[i][j] - a[i][j]) / 2.0);\n        }\n\n        public takeDescentStep(x: Float32Array, d: Float32Array, stepSize: number): void {\n            for (var i = 0; i < this.n; ++i) {\n                x[i] = x[i] - stepSize * d[i];\n            }\n        }\n\n        public computeStress(): number {\n            var stress = 0;\n            for (var u = 0, nMinus1 = this.n - 1; u < nMinus1; ++u) {\n                for (var v = u + 1, n = this.n; v < n; ++v) {\n                    var l = 0;\n                    for (var i = 0; i < this.k; ++i) {\n                        var dx = this.x[i][u] - this.x[i][v];\n                        l += dx * dx;\n                    }\n                    l = Math.sqrt(l);\n                    var d = this.D[u][v];\n                    if (!isFinite(d)) continue;\n                    var rl = d - l;\n                    var d2 = d * d;\n                    stress += rl * rl / d2;\n                }\n            }\n            return stress;\n        }\n    }\n\n    // Linear congruential pseudo random number generator\n    export class PseudoRandom {\n        private a: number = 214013;\n        private c: number = 2531011;\n        private m: number = 2147483648;\n        private range: number = 32767;\n\n        constructor(public seed: number = 1) { }\n\n        // random real between 0 and 1\n        getNext(): number {\n            this.seed = (this.seed * this.a + this.c) % this.m;\n            return (this.seed >> 16) / this.range;\n        }\n\n        // random real between min and max\n        getNextBetween(min: number, max: number) {\n            return min + this.getNext() * (max - min);\n        }\n    }\n","    export class PositionStats {\n        AB: number = 0;\n        AD: number = 0;\n        A2: number = 0;\n\n        constructor(public scale: number) {}\n\n        addVariable(v: Variable): void {\n            var ai = this.scale / v.scale;\n            var bi = v.offset / v.scale;\n            var wi = v.weight;\n            this.AB += wi * ai * bi;\n            this.AD += wi * ai * v.desiredPosition;\n            this.A2 += wi * ai * ai;\n        }\n\n        getPosn(): number {\n            return (this.AD - this.AB) / this.A2;\n        }\n    }\n\n    export class Constraint {\n        lm: number;\n        active: boolean = false;\n        unsatisfiable: boolean = false;\n\n        constructor(public left: Variable, public right: Variable, public gap: number, public equality: boolean = false) {\n            this.left = left;\n            this.right = right;\n            this.gap = gap;\n            this.equality = equality;\n        }\n\n        slack(): number {\n            return this.unsatisfiable ? Number.MAX_VALUE\n                : this.right.scale * this.right.position() - this.gap\n                - this.left.scale * this.left.position();\n        }\n    }\n\n    export class Variable {\n        offset: number = 0;\n        block: Block;\n        cIn: Constraint[];\n        cOut: Constraint[];\n\n        constructor(public desiredPosition: number, public weight: number = 1, public scale: number = 1) {}\n\n        dfdv(): number {\n            return 2.0 * this.weight * (this.position() - this.desiredPosition);\n        }\n\n        position(): number {\n            return (this.block.ps.scale * this.block.posn + this.offset) / this.scale;\n        }\n\n        // visit neighbours by active constraints within the same block\n        visitNeighbours(prev: Variable, f: (c: Constraint, next: Variable) => void ): void {\n            var ff = (c, next) => c.active && prev !== next && f(c, next);\n            this.cOut.forEach(c=> ff(c, c.right));\n            this.cIn.forEach(c=> ff(c, c.left));\n        }\n    }\n\n    export class Block {\n        vars: Variable[] = [];\n        posn: number;\n        ps: PositionStats;\n        blockInd: number;\n\n        constructor(v: Variable) {\n            v.offset = 0;\n            this.ps = new PositionStats(v.scale);\n            this.addVariable(v);\n        }\n\n        private addVariable(v: Variable): void {\n            v.block = this;\n            this.vars.push(v);\n            this.ps.addVariable(v);\n            this.posn = this.ps.getPosn();\n        }\n\n        // move the block where it needs to be to minimize cost\n        updateWeightedPosition(): void {\n            this.ps.AB = this.ps.AD = this.ps.A2 = 0;\n            for (var i = 0, n = this.vars.length; i < n; ++i)\n                this.ps.addVariable(this.vars[i]);\n            this.posn = this.ps.getPosn();\n        }\n\n        private compute_lm(v: Variable, u: Variable, postAction: (c: Constraint)=>void): number {\n            var dfdv = v.dfdv();\n            v.visitNeighbours(u, (c, next) => {\n                var _dfdv = this.compute_lm(next, v, postAction);\n                if (next === c.right) {\n                    dfdv += _dfdv * c.left.scale;\n                    c.lm = _dfdv;\n                } else {\n                    dfdv += _dfdv * c.right.scale;\n                    c.lm = -_dfdv;\n                }\n                postAction(c);\n            });\n            return dfdv / v.scale;\n        }\n\n        private populateSplitBlock(v: Variable, prev: Variable): void {\n            v.visitNeighbours(prev, (c, next) => {\n                next.offset = v.offset + (next === c.right ? c.gap : -c.gap);\n                this.addVariable(next);\n                this.populateSplitBlock(next, v);\n            });\n        }\n\n        // traverse the active constraint tree applying visit to each active constraint\n        traverse(visit: (c: Constraint) => any, acc: any[], v: Variable = this.vars[0], prev: Variable=null) {\n            v.visitNeighbours(prev, (c, next) => {\n                acc.push(visit(c));\n                this.traverse(visit, acc, next, v);\n            });\n        }\n\n        // calculate lagrangian multipliers on constraints and\n        // find the active constraint in this block with the smallest lagrangian.\n        // if the lagrangian is negative, then the constraint is a split candidate.\n        findMinLM(): Constraint {\n            var m: Constraint = null;\n            this.compute_lm(this.vars[0], null, c=> {\n                if (!c.equality && (m === null || c.lm < m.lm)) m = c;\n            });\n            return m;\n        }\n\n        private findMinLMBetween(lv: Variable, rv: Variable): Constraint {\n            this.compute_lm(lv, null, () => {});\n            var m = null;\n            this.findPath(lv, null, rv, (c, next)=> {\n                if (!c.equality && c.right === next && (m === null || c.lm < m.lm)) m = c;\n            });\n            return m;\n        }\n\n        private findPath(v: Variable, prev: Variable, to: Variable, visit: (c: Constraint, next:Variable)=>void): boolean {\n            var endFound = false;\n            v.visitNeighbours(prev, (c, next) => {\n                if (!endFound && (next === to || this.findPath(next, v, to, visit)))\n                {\n                    endFound = true;\n                    visit(c, next);\n                }\n            });\n            return endFound;\n        }\n\n        // Search active constraint tree from u to see if there is a directed path to v.\n        // Returns true if path is found.\n        isActiveDirectedPathBetween(u: Variable, v: Variable) : boolean {\n            if (u === v) return true;\n            var i = u.cOut.length;\n            while(i--) {\n                var c = u.cOut[i];\n                if (c.active && this.isActiveDirectedPathBetween(c.right, v))\n                    return true;\n            }\n            return false;\n        }\n\n        // split the block into two by deactivating the specified constraint\n        static split(c: Constraint): Block[]{\n/* DEBUG\n            console.log(\"split on \" + c);\n            console.assert(c.active, \"attempt to split on inactive constraint\");\nDEBUG */\n            c.active = false;\n            return [Block.createSplitBlock(c.left), Block.createSplitBlock(c.right)];\n        }\n\n        private static createSplitBlock(startVar: Variable): Block {\n            var b = new Block(startVar);\n            b.populateSplitBlock(startVar, null);\n            return b;\n        }\n\n        // find a split point somewhere between the specified variables\n        splitBetween(vl: Variable, vr: Variable): { constraint: Constraint; lb: Block; rb: Block } {\n/* DEBUG\n            console.assert(vl.block === this);\n            console.assert(vr.block === this);\nDEBUG */\n            var c = this.findMinLMBetween(vl, vr);\n            if (c !== null) {\n                var bs = Block.split(c);\n                return { constraint: c, lb: bs[0], rb: bs[1] };\n            }\n            // couldn't find a split point - for example the active path is all equality constraints\n            return null;\n        }\n\n        mergeAcross(b: Block, c: Constraint, dist: number): void {\n            c.active = true;\n            for (var i = 0, n = b.vars.length; i < n; ++i) {\n                var v = b.vars[i];\n                v.offset += dist;\n                this.addVariable(v);\n            }\n            this.posn = this.ps.getPosn();\n        }\n\n        cost(): number {\n            var sum = 0, i = this.vars.length;\n            while (i--) {\n                var v = this.vars[i],\n                    d = v.position() - v.desiredPosition;\n                sum += d * d * v.weight;\n            }\n            return sum;\n        }\n\n/* DEBUG\n        toString(): string {\n            var cs = [];\n            this.traverse(c=> c.toString() + \"\\n\", cs)\n            return \"b\"+this.blockInd + \"@\" + this.posn + \": vars=\" + this.vars.map(v=> v.toString()+\":\"+v.offset) + \";\\n cons=\\n\" + cs;\n        }\nDEBUG */\n    }\n\n    export class Blocks {\n        private list: Block[];\n\n        constructor(public vs: Variable[]) {\n            var n = vs.length;\n            this.list = new Array(n);\n            while (n--) {\n                var b = new Block(vs[n]);\n                this.list[n] = b;\n                b.blockInd = n;\n            }\n        }\n\n        cost(): number {\n            var sum = 0, i = this.list.length;\n            while (i--) sum += this.list[i].cost();\n            return sum;\n        }\n\n        insert(b: Block) {\n/* DEBUG\n            console.assert(!this.contains(b), \"blocks error: tried to reinsert block \" + b.blockInd)\nDEBUG */\n            b.blockInd = this.list.length;\n            this.list.push(b);\n/* DEBUG\n            console.log(\"insert block: \" + b.blockInd);\n            this.contains(b);\nDEBUG */\n        }\n\n        remove(b: Block) {\n/* DEBUG\n            console.log(\"remove block: \" + b.blockInd);\n            console.assert(this.contains(b));\nDEBUG */\n            var last = this.list.length - 1;\n            var swapBlock = this.list[last];\n            this.list.length = last;\n            if (b !== swapBlock) {\n                this.list[b.blockInd] = swapBlock;\n                swapBlock.blockInd = b.blockInd;\n/* DEBUG\n                console.assert(this.contains(swapBlock));\nDEBUG */\n            }\n        }\n\n        // merge the blocks on either side of the specified constraint, by copying the smaller block into the larger\n        // and deleting the smaller.\n        merge(c: Constraint): void {\n            var l = c.left.block, r = c.right.block;\n/* DEBUG\n            console.assert(l!==r, \"attempt to merge within the same block\");\nDEBUG */\n            var dist = c.right.offset - c.left.offset - c.gap;\n            if (l.vars.length < r.vars.length) {\n                r.mergeAcross(l, c, dist);\n                this.remove(l);\n            } else {\n                l.mergeAcross(r, c, -dist);\n                this.remove(r);\n            }\n/* DEBUG\n            console.assert(Math.abs(c.slack()) < 1e-6, \"Error: Constraint should be at equality after merge!\");\n            console.log(\"merged on \" + c);\nDEBUG */\n        }\n\n        forEach(f: (b: Block, i: number) => void ) {\n            this.list.forEach(f);\n        }\n\n        // useful, for example, after variable desired positions change.\n        updateBlockPositions(): void {\n            this.list.forEach(b=> b.updateWeightedPosition());\n        }\n\n        // split each block across its constraint with the minimum lagrangian\n        split(inactive: Constraint[]): void {\n            this.updateBlockPositions();\n            this.list.forEach(b=> {\n                var v = b.findMinLM();\n                if (v !== null && v.lm < Solver.LAGRANGIAN_TOLERANCE) {\n                    b = v.left.block;\n                    Block.split(v).forEach(nb=>this.insert(nb));\n                    this.remove(b);\n                    inactive.push(v);\n/* DEBUG\n                    console.assert(this.contains(v.left.block));\n                    console.assert(this.contains(v.right.block));\nDEBUG */\n                }\n            });\n        }\n\n/* DEBUG\n        // checks b is in the block, and does a sanity check over list index integrity\n        contains(b: Block): boolean {\n            var result = false;\n            this.list.forEach((bb, i) => {\n                if (bb.blockInd !== i) {\n                    console.error(\"blocks error, blockInd \" + b.blockInd + \" found at \" + i);\n                    return false;\n                }\n                result = result || b === bb;\n            });\n            return result;\n        }\n\n        toString(): string {\n            return this.list.toString();\n        }\nDEBUG */\n    }\n\n    export class Solver {\n        bs: Blocks;\n        inactive: Constraint[];\n\n        static LAGRANGIAN_TOLERANCE = -1e-4;\n        static ZERO_UPPERBOUND = -1e-10;\n\n        constructor(public vs: Variable[], public cs: Constraint[]) {\n            this.vs = vs;\n            vs.forEach(v => {\n                v.cIn = [], v.cOut = [];\n/* DEBUG\n                v.toString = () => \"v\" + vs.indexOf(v);\nDEBUG */\n            });\n            this.cs = cs;\n            cs.forEach(c => {\n                c.left.cOut.push(c);\n                c.right.cIn.push(c);\n/* DEBUG\n                c.toString = () => c.left + \"+\" + c.gap + \"<=\" + c.right + \" slack=\" + c.slack() + \" active=\" + c.active;\nDEBUG */\n            });\n            this.inactive = cs.map(c=> { c.active = false; return c; });\n            this.bs = null;\n        }\n\n        cost(): number {\n            return this.bs.cost();\n        }\n\n        // set starting positions without changing desired positions.\n        // Note: it throws away any previous block structure.\n        setStartingPositions(ps: Float32Array): void {\n            this.inactive = this.cs.map(c=> { c.active = false; return c; });\n            this.bs = new Blocks(this.vs);\n            this.bs.forEach((b, i) => b.posn = ps[i]);\n        }\n\n        setDesiredPositions(ps: Float32Array): void {\n            this.vs.forEach((v, i) => v.desiredPosition = ps[i]);\n        }\n\n/* DEBUG\n        private getId(v: Variable): number {\n            return this.vs.indexOf(v);\n        }\n\n        // sanity check of the index integrity of the inactive list\n        checkInactive(): void {\n            var inactiveCount = 0;\n            this.cs.forEach(c=> {\n                var i = this.inactive.indexOf(c);\n                console.assert(!c.active && i >= 0 || c.active && i < 0, \"constraint should be in the inactive list if it is not active: \" + c);\n                if (i >= 0) {\n                    inactiveCount++;\n                } else {\n                    console.assert(c.active, \"inactive constraint not found in inactive list: \" + c);\n                }\n            });\n            console.assert(inactiveCount === this.inactive.length, inactiveCount + \" inactive constraints found, \" + this.inactive.length + \"in inactive list\");\n        }\n        // after every call to satisfy the following should check should pass\n        checkSatisfied(): void {\n            this.cs.forEach(c=>console.assert(c.slack() >= vpsc.Solver.ZERO_UPPERBOUND, \"Error: Unsatisfied constraint! \"+c));\n        }\nDEBUG */\n\n        private mostViolated(): Constraint {\n            var minSlack = Number.MAX_VALUE,\n                v: Constraint = null,\n                l = this.inactive,\n                n = l.length,\n                deletePoint = n;\n            for (var i = 0; i < n; ++i) {\n                var c = l[i];\n                if (c.unsatisfiable) continue;\n                var slack = c.slack();\n                if (c.equality || slack < minSlack) {\n                    minSlack = slack;\n                    v = c;\n                    deletePoint = i;\n                    if (c.equality) break;\n                }\n            }\n            if (deletePoint !== n &&\n                (minSlack < Solver.ZERO_UPPERBOUND && !v.active || v.equality))\n            {\n                l[deletePoint] = l[n - 1];\n                l.length = n - 1;\n            }\n            return v;\n        }\n\n        // satisfy constraints by building block structure over violated constraints\n        // and moving the blocks to their desired positions\n        satisfy(): void {\n            if (this.bs == null) {\n                this.bs = new Blocks(this.vs);\n            }\n/* DEBUG\n            console.log(\"satisfy: \" + this.bs);\nDEBUG */\n            this.bs.split(this.inactive);\n            var v: Constraint = null;\n            while ((v = this.mostViolated()) && (v.equality || v.slack() < Solver.ZERO_UPPERBOUND && !v.active)) {\n                var lb = v.left.block, rb = v.right.block;\n/* DEBUG\n                console.log(\"most violated is: \" + v);\n                this.bs.contains(lb);\n                this.bs.contains(rb);\nDEBUG */\n                if (lb !== rb) {\n                    this.bs.merge(v);\n                } else {\n                    if (lb.isActiveDirectedPathBetween(v.right, v.left)) {\n                        // cycle found!\n                        v.unsatisfiable = true;\n                        continue;\n                    }\n                    // constraint is within block, need to split first\n                    var split = lb.splitBetween(v.left, v.right);\n                    if (split !== null) {\n                        this.bs.insert(split.lb);\n                        this.bs.insert(split.rb);\n                        this.bs.remove(lb);\n                        this.inactive.push(split.constraint);\n                    } else {\n/* DEBUG\n                        console.log(\"unsatisfiable constraint found\");\nDEBUG */\n                        v.unsatisfiable = true;\n                        continue;\n                    }\n                    if (v.slack() >= 0) {\n/* DEBUG\n                        console.log(\"violated constraint indirectly satisfied: \" + v);\nDEBUG */\n                        // v was satisfied by the above split!\n                        this.inactive.push(v);\n                    } else {\n/* DEBUG\n                        console.log(\"merge after split:\");\nDEBUG */\n                        this.bs.merge(v);\n                    }\n                }\n/* DEBUG\n                this.bs.contains(v.left.block);\n                this.bs.contains(v.right.block);\n                this.checkInactive();\nDEBUG */\n            }\n/* DEBUG\n            this.checkSatisfied();\nDEBUG */\n        }\n\n        // repeatedly build and split block structure until we converge to an optimal solution\n        solve(): number {\n            this.satisfy();\n            var lastcost = Number.MAX_VALUE, cost = this.bs.cost();\n            while (Math.abs(lastcost - cost) > 0.0001) {\n                this.satisfy();\n                lastcost = cost;\n                cost = this.bs.cost();\n            }\n            return cost;\n        }\n    }\n    /**\n      * Remove overlap between spans while keeping their centers as close as possible to the specified desiredCenters.\n      * Lower and upper bounds will be respected if the spans physically fit between them\n      * (otherwise they'll be moved and their new position returned).\n      * If no upper/lower bound is specified then the bounds of the moved spans will be returned.\n      * returns a new center for each span.\n      */\n    export function removeOverlapInOneDimension(spans: { size: number, desiredCenter: number }[], lowerBound?: number, upperBound?: number)\n        : { newCenters: number[], lowerBound: number, upperBound: number }\n    {\n        const vs: Variable[] = spans.map(s => new Variable(s.desiredCenter));\n        const cs: Constraint[] = [];\n        const n = spans.length;\n        for (var i = 0; i < n - 1; i++) {\n            const left = spans[i], right = spans[i + 1];\n            cs.push(new Constraint(vs[i], vs[i + 1], (left.size + right.size) / 2));\n        }\n        const leftMost = vs[0],\n            rightMost = vs[n - 1],\n            leftMostSize = spans[0].size / 2,\n            rightMostSize = spans[n - 1].size / 2;\n        let vLower: Variable = null, vUpper: Variable = null;\n        if (lowerBound) {\n            vLower = new Variable(lowerBound, leftMost.weight * 1000);\n            vs.push(vLower);\n            cs.push(new Constraint(vLower, leftMost, leftMostSize));\n        }\n        if (upperBound) {\n            vUpper = new Variable(upperBound, rightMost.weight * 1000);\n            vs.push(vUpper);\n            cs.push(new Constraint(rightMost, vUpper, rightMostSize));\n        }\n        var solver = new Solver(vs, cs);\n        solver.solve();\n        return {\n            newCenters: vs.slice(0, spans.length).map(v => v.position()),\n            lowerBound: vLower ? vLower.position() : leftMost.position() - leftMostSize,\n            upperBound: vUpper ? vUpper.position() : rightMost.position() + rightMostSize\n        };\n    }\n","    //Based on js_es:\n    //\n    //https://github.com/vadimg/js_bintrees\n    //\n    //Copyright (C) 2011 by Vadim Graboys\n    //\n    //Permission is hereby granted, free of charge, to any person obtaining a copy\n    //of this software and associated documentation files (the \"Software\"), to deal\n    //in the Software without restriction, including without limitation the rights\n    //to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    //copies of the Software, and to permit persons to whom the Software is\n    //furnished to do so, subject to the following conditions:\n    //\n    //The above copyright notice and this permission notice shall be included in\n    //all copies or substantial portions of the Software.\n    //\n    //THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    //IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    //FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    //AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    //LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    //OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n    //THE SOFTWARE.\n    export class TreeBase {\n        _root;\n        size;\n        _comparator;\n        // removes all nodes from the tree\n        clear() {\n            this._root = null;\n            this.size = 0;\n        };\n\n        // returns node data if found, null otherwise\n        find(data) {\n            var res = this._root;\n\n            while (res !== null) {\n                var c = this._comparator(data, res.data);\n                if (c === 0) {\n                    return res.data;\n                }\n                else {\n                    res = res.get_child(c > 0);\n                }\n            }\n\n            return null;\n        };\n\n        // returns iterator to node if found, null otherwise\n        findIter = function (data) {\n            var res = this._root;\n            var iter = this.iterator();\n\n            while (res !== null) {\n                var c = this._comparator(data, res.data);\n                if (c === 0) {\n                    iter._cursor = res;\n                    return iter;\n                }\n                else {\n                    iter._ancestors.push(res);\n                    res = res.get_child(c > 0);\n                }\n            }\n\n            return null;\n        };\n\n        // Returns an interator to the tree node immediately before (or at) the element\n        lowerBound(data) {\n            return this._bound(data, this._comparator);\n        };\n\n        // Returns an interator to the tree node immediately after (or at) the element\n        upperBound(data) {\n            var cmp = this._comparator;\n\n            function reverse_cmp(a, b) {\n                return cmp(b, a);\n            }\n\n            return this._bound(data, reverse_cmp);\n        };\n\n        // returns null if tree is empty\n        min() {\n            var res = this._root;\n            if (res === null) {\n                return null;\n            }\n\n            while (res.left !== null) {\n                res = res.left;\n            }\n\n            return res.data;\n        };\n\n        // returns null if tree is empty\n        max() {\n            var res = this._root;\n            if (res === null) {\n                return null;\n            }\n\n            while (res.right !== null) {\n                res = res.right;\n            }\n\n            return res.data;\n        };\n\n        // returns a null iterator\n        // call next() or prev() to point to an element\n        iterator(): Iterator {\n            return new Iterator(this);\n        };\n\n        // calls cb on each node's data, in order\n        each(cb) {\n            var it = this.iterator(), data;\n            while ((data = it.next()) !== null) {\n                cb(data);\n            }\n        };\n\n        // calls cb on each node's data, in reverse order\n        reach(cb) {\n            var it = this.iterator(), data;\n            while ((data = it.prev()) !== null) {\n                cb(data);\n            }\n        };\n\n        // used for lowerBound and upperBound\n        _bound(data, cmp) {\n            var cur = this._root;\n            var iter = this.iterator();\n\n            while (cur !== null) {\n                var c = this._comparator(data, cur.data);\n                if (c === 0) {\n                    iter._cursor = cur;\n                    return iter;\n                }\n                iter._ancestors.push(cur);\n                cur = cur.get_child(c > 0);\n            }\n\n            for (var i = iter._ancestors.length - 1; i >= 0; --i) {\n                cur = iter._ancestors[i];\n                if (cmp(data, cur.data) > 0) {\n                    iter._cursor = cur;\n                    iter._ancestors.length = i;\n                    return iter;\n                }\n            }\n\n            iter._ancestors.length = 0;\n            return iter;\n        };\n    }\n    export class Iterator {\n        _tree;\n        _ancestors;\n        _cursor;\n        constructor(tree) {\n            this._tree = tree;\n            this._ancestors = [];\n            this._cursor = null;\n        }\n\n        data() {\n            return this._cursor !== null ? this._cursor.data : null;\n        };\n\n        // if null-iterator, returns first node\n        // otherwise, returns next node\n        next() {\n            if (this._cursor === null) {\n                var root = this._tree._root;\n                if (root !== null) {\n                    this._minNode(root);\n                }\n            }\n            else {\n                if (this._cursor.right === null) {\n                    // no greater node in subtree, go up to parent\n                    // if coming from a right child, continue up the stack\n                    var save;\n                    do {\n                        save = this._cursor;\n                        if (this._ancestors.length) {\n                            this._cursor = this._ancestors.pop();\n                        }\n                        else {\n                            this._cursor = null;\n                            break;\n                        }\n                    } while (this._cursor.right === save);\n                }\n                else {\n                    // get the next node from the subtree\n                    this._ancestors.push(this._cursor);\n                    this._minNode(this._cursor.right);\n                }\n            }\n            return this._cursor !== null ? this._cursor.data : null;\n        };\n\n        // if null-iterator, returns last node\n        // otherwise, returns previous node\n        prev() {\n            if (this._cursor === null) {\n                var root = this._tree._root;\n                if (root !== null) {\n                    this._maxNode(root);\n                }\n            }\n            else {\n                if (this._cursor.left === null) {\n                    var save;\n                    do {\n                        save = this._cursor;\n                        if (this._ancestors.length) {\n                            this._cursor = this._ancestors.pop();\n                        }\n                        else {\n                            this._cursor = null;\n                            break;\n                        }\n                    } while (this._cursor.left === save);\n                }\n                else {\n                    this._ancestors.push(this._cursor);\n                    this._maxNode(this._cursor.left);\n                }\n            }\n            return this._cursor !== null ? this._cursor.data : null;\n        };\n\n        _minNode(start) {\n            while (start.left !== null) {\n                this._ancestors.push(start);\n                start = start.left;\n            }\n            this._cursor = start;\n        };\n\n        _maxNode(start) {\n            while (start.right !== null) {\n                this._ancestors.push(start);\n                start = start.right;\n            }\n            this._cursor = start;\n        };\n    }\n\n    class Node {\n        data;\n        left;\n        right;\n        red;\n        constructor(data) {\n            this.data = data;\n            this.left = null;\n            this.right = null;\n            this.red = true;\n        }\n\n        get_child(dir) {\n            return dir ? this.right : this.left;\n        };\n\n        set_child(dir, val) {\n            if (dir) {\n                this.right = val;\n            }\n            else {\n                this.left = val;\n            }\n        };\n    }\n\n    export class RBTree<T> extends TreeBase {\n\n        _root;\n        _comparator;\n        size;\n        constructor(comparator: (a: T, b: T) => number) {\n            super();\n            this._root = null;\n            this._comparator = comparator;\n            this.size = 0;\n        }\n\n        // returns true if inserted, false if duplicate\n        insert(data) {\n            var ret = false;\n\n            if (this._root === null) {\n                // empty tree\n                this._root = new Node(data);\n                ret = true;\n                this.size++;\n            }\n            else {\n                var head = new Node(undefined); // fake tree root\n\n                var dir = false;\n                var last = false;\n\n                // setup\n                var gp = null; // grandparent\n                var ggp = head; // grand-grand-parent\n                var p = null; // parent\n                var node = this._root;\n                ggp.right = this._root;\n\n                // search down\n                while (true) {\n                    if (node === null) {\n                        // insert new node at the bottom\n                        node = new Node(data);\n                        p.set_child(dir, node);\n                        ret = true;\n                        this.size++;\n                    }\n                    else if (RBTree.is_red(node.left) && RBTree.is_red(node.right)) {\n                        // color flip\n                        node.red = true;\n                        node.left.red = false;\n                        node.right.red = false;\n                    }\n\n                    // fix red violation\n                    if (RBTree.is_red(node) && RBTree.is_red(p)) {\n                        var dir2 = ggp.right === gp;\n\n                        if (node === p.get_child(last)) {\n                            ggp.set_child(dir2, RBTree.single_rotate(gp, !last));\n                        }\n                        else {\n                            ggp.set_child(dir2, RBTree.double_rotate(gp, !last));\n                        }\n                    }\n\n                    var cmp = this._comparator(node.data, data);\n\n                    // stop if found\n                    if (cmp === 0) {\n                        break;\n                    }\n\n                    last = dir;\n                    dir = cmp < 0;\n\n                    // update helpers\n                    if (gp !== null) {\n                        ggp = gp;\n                    }\n                    gp = p;\n                    p = node;\n                    node = node.get_child(dir);\n                }\n\n                // update root\n                this._root = head.right;\n            }\n\n            // make root black\n            this._root.red = false;\n\n            return ret;\n        };\n\n        // returns true if removed, false if not found\n        remove(data) {\n            if (this._root === null) {\n                return false;\n            }\n\n            var head = new Node(undefined); // fake tree root\n            var node = head;\n            node.right = this._root;\n            var p = null; // parent\n            var gp = null; // grand parent\n            var found = null; // found item\n            var dir = true;\n\n            while (node.get_child(dir) !== null) {\n                var last = dir;\n\n                // update helpers\n                gp = p;\n                p = node;\n                node = node.get_child(dir);\n\n                var cmp = this._comparator(data, node.data);\n\n                dir = cmp > 0;\n\n                // save found node\n                if (cmp === 0) {\n                    found = node;\n                }\n\n                // push the red node down\n                if (!RBTree.is_red(node) && !RBTree.is_red(node.get_child(dir))) {\n                    if (RBTree.is_red(node.get_child(!dir))) {\n                        var sr = RBTree.single_rotate(node, dir);\n                        p.set_child(last, sr);\n                        p = sr;\n                    }\n                    else if (!RBTree.is_red(node.get_child(!dir))) {\n                        var sibling = p.get_child(!last);\n                        if (sibling !== null) {\n                            if (!RBTree.is_red(sibling.get_child(!last)) && !RBTree.is_red(sibling.get_child(last))) {\n                                // color flip\n                                p.red = false;\n                                sibling.red = true;\n                                node.red = true;\n                            }\n                            else {\n                                var dir2 = gp.right === p;\n\n                                if (RBTree.is_red(sibling.get_child(last))) {\n                                    gp.set_child(dir2, RBTree.double_rotate(p, last));\n                                }\n                                else if (RBTree.is_red(sibling.get_child(!last))) {\n                                    gp.set_child(dir2, RBTree.single_rotate(p, last));\n                                }\n\n                                // ensure correct coloring\n                                var gpc = gp.get_child(dir2);\n                                gpc.red = true;\n                                node.red = true;\n                                gpc.left.red = false;\n                                gpc.right.red = false;\n                            }\n                        }\n                    }\n                }\n            }\n\n            // replace and remove if found\n            if (found !== null) {\n                found.data = node.data;\n                p.set_child(p.right === node, node.get_child(node.left === null));\n                this.size--;\n            }\n\n            // update root and make it black\n            this._root = head.right;\n            if (this._root !== null) {\n                this._root.red = false;\n            }\n\n            return found !== null;\n        };\n\n        static is_red(node) {\n            return node !== null && node.red;\n        }\n\n        static single_rotate(root, dir) {\n            var save = root.get_child(!dir);\n\n            root.set_child(!dir, save.get_child(dir));\n            save.set_child(dir, root);\n\n            root.red = true;\n            save.red = false;\n\n            return save;\n        }\n\n        static double_rotate(root, dir) {\n            root.set_child(!dir, RBTree.single_rotate(root.get_child(!dir), !dir));\n            return RBTree.single_rotate(root, dir);\n        }\n    }\n","import {Constraint, Variable, Solver} from './vpsc'\nimport {RBTree} from './rbtree'\nimport {Point} from './geom'\n\n    export interface Leaf {\n        bounds: Rectangle;\n        variable: Variable;\n    }\n\n    export interface ProjectionGroup {\n        bounds: Rectangle;\n        padding: number;\n        stiffness: number;\n        leaves: Leaf[];\n        groups: ProjectionGroup[];\n        minVar: Variable;\n        maxVar: Variable;\n    }\n\n    export function computeGroupBounds(g: ProjectionGroup): Rectangle {\n        g.bounds = typeof g.leaves !== \"undefined\" ?\n            g.leaves.reduce((r: Rectangle, c) => c.bounds.union(r), Rectangle.empty()) :\n            Rectangle.empty();\n        if (typeof g.groups !== \"undefined\")\n            g.bounds = <Rectangle>g.groups.reduce((r: Rectangle, c) => computeGroupBounds(c).union(r), g.bounds);\n        g.bounds = g.bounds.inflate(g.padding);\n        return g.bounds;\n    }\n\n    export class Rectangle {\n        constructor(\n            public x: number,\n            public X: number,\n            public y: number,\n            public Y: number) { }\n\n        static empty(): Rectangle { return new Rectangle(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY); }\n\n        cx(): number { return (this.x + this.X) / 2; }\n\n        cy(): number { return (this.y + this.Y) / 2; }\n\n        overlapX(r: Rectangle): number {\n            var ux = this.cx(), vx = r.cx();\n            if (ux <= vx && r.x < this.X) return this.X - r.x;\n            if (vx <= ux && this.x < r.X) return r.X - this.x;\n            return 0;\n        }\n\n        overlapY(r: Rectangle): number {\n            var uy = this.cy(), vy = r.cy();\n            if (uy <= vy && r.y < this.Y) return this.Y - r.y;\n            if (vy <= uy && this.y < r.Y) return r.Y - this.y;\n            return 0;\n        }\n\n        setXCentre(cx: number): void {\n            var dx = cx - this.cx();\n            this.x += dx;\n            this.X += dx;\n        }\n\n        setYCentre(cy: number): void {\n            var dy = cy - this.cy();\n            this.y += dy;\n            this.Y += dy;\n        }\n\n        width(): number {\n            return this.X - this.x;\n        }\n\n        height(): number {\n            return this.Y - this.y;\n        }\n\n        union(r: Rectangle): Rectangle {\n            return new Rectangle(Math.min(this.x, r.x), Math.max(this.X, r.X), Math.min(this.y, r.y), Math.max(this.Y, r.Y));\n        }\n\n        /**\n         * return any intersection points between the given line and the sides of this rectangle\n         * @method lineIntersection\n         * @param x1 number first x coord of line\n         * @param y1 number first y coord of line\n         * @param x2 number second x coord of line\n         * @param y2 number second y coord of line\n         * @return any intersection points found\n         */\n        lineIntersections(x1: number, y1: number, x2: number, y2: number): Array<Point> {\n            var sides = [[this.x, this.y, this.X, this.y],\n                    [this.X, this.y, this.X, this.Y],\n                    [this.X, this.Y, this.x, this.Y],\n                [this.x, this.Y, this.x, this.y]];\n            var intersections = [];\n            for (var i = 0; i < 4; ++i) {\n                var r = Rectangle.lineIntersection(x1, y1, x2, y2, sides[i][0], sides[i][1], sides[i][2], sides[i][3]);\n                if (r !== null) intersections.push({ x: r.x, y: r.y });\n            }\n            return intersections;\n        }\n\n        /**\n         * return any intersection points between a line extending from the centre of this rectangle to the given point,\n         *  and the sides of this rectangle\n         * @method lineIntersection\n         * @param x2 number second x coord of line\n         * @param y2 number second y coord of line\n         * @return any intersection points found\n         */\n        rayIntersection(x2: number, y2: number): Point {\n            var ints = this.lineIntersections(this.cx(), this.cy(), x2, y2);\n            return ints.length > 0 ? ints[0] : null;\n        }\n\n        vertices(): Point[] {\n            return [\n                { x: this.x, y: this.y },\n                { x: this.X, y: this.y },\n                { x: this.X, y: this.Y },\n                { x: this.x, y: this.Y }];\n        }\n\n        static lineIntersection(\n            x1: number, y1: number,\n            x2: number, y2: number,\n            x3: number, y3: number,\n            x4: number, y4: number): Point {\n            var dx12 = x2 - x1, dx34 = x4 - x3,\n                dy12 = y2 - y1, dy34 = y4 - y3,\n                denominator = dy34 * dx12 - dx34 * dy12;\n            if (denominator == 0) return null;\n            var dx31 = x1 - x3, dy31 = y1 - y3,\n                numa = dx34 * dy31 - dy34 * dx31,\n                a = numa / denominator,\n                numb = dx12 * dy31 - dy12 * dx31,\n                b = numb / denominator;\n            if (a >= 0 && a <= 1 && b >= 0 && b <= 1) {\n                return {\n                    x: x1 + a * dx12,\n                    y: y1 + a * dy12\n                };\n            }\n            return null;\n        }\n\n        inflate(pad: number): Rectangle {\n            return new Rectangle(this.x - pad, this.X + pad, this.y - pad, this.Y + pad);\n        }\n    }\n\n    /**\n     * Returns the endpoints of a line that connects the centre of two rectangles.\n     * @param {Rectangle} [source] The source Rectangle.\n     * @param {Rectangle} [target] The target Rectangle.\n     * @param {number} [ah] The size of the arrow head, a distance to shorten the\n     *                      line by.\n     * @return An object with three point properties, the intersection with the\n     *         source rectangle (sourceIntersection), the intersection with then\n     *         target rectangle (targetIntersection), and the point an arrow\n     *         head of the specified size would need to start (arrowStart).\n     */\n    export function makeEdgeBetween(source: Rectangle, target: Rectangle, ah: number)\n        : { sourceIntersection: Point; targetIntersection: Point; arrowStart: Point } {\n        const si = source.rayIntersection(target.cx(), target.cy()) || { x: source.cx(), y: source.cy() },\n            ti = target.rayIntersection(source.cx(), source.cy()) || { x: target.cx(), y: target.cy() },\n            dx = ti.x - si.x,\n            dy = ti.y - si.y,\n            l = Math.sqrt(dx * dx + dy * dy), al = l - ah;\n        return {\n            sourceIntersection: si,\n            targetIntersection: ti,\n            arrowStart: { x: si.x + al * dx / l, y: si.y + al * dy / l }\n        }\n    }\n\n    /**\n     * Returns the intersection of a line from the given point to the centre\n     * of the target rectangle where it intersects the rectanngle.\n     * @param [source] The source point.\n     * @param {Rectangle} [target] The target Rectangle.\n     * @param {number} [ah] The size of the arrow head, a distance to shorten the\n     *                      line by.\n     * @return The point an arrow head of the specified size would need to start.\n     */\n    export function makeEdgeTo(s: { x: number; y: number }, target: Rectangle, ah: number): Point {\n        var ti = target.rayIntersection(s.x, s.y);\n        if (!ti) ti = { x: target.cx(), y: target.cy() };\n        var dx = ti.x - s.x,\n            dy = ti.y - s.y,\n            l = Math.sqrt(dx * dx + dy * dy);\n        return { x: ti.x - ah * dx / l, y: ti.y - ah * dy / l };\n    }\n\n    class Node {\n        prev: RBTree<Node>;\n        next: RBTree<Node>;\n\n        constructor(public v: Variable, public r: Rectangle, public pos: number) {\n            this.prev = makeRBTree();\n            this.next = makeRBTree();\n        }\n    }\n\n    class Event {\n        constructor(public isOpen: boolean, public v: Node, public pos: number) {}\n    }\n\n    function compareEvents(a: Event, b: Event): number {\n        if (a.pos > b.pos) {\n            return 1;\n        }\n        if (a.pos < b.pos) {\n            return -1;\n        }\n        if (a.isOpen) {\n            // open must come before close\n            return -1;\n        }\n        if (b.isOpen) {\n            // open must come before close\n            return 1;\n        }\n        return 0;\n    }\n\n    function makeRBTree(): RBTree<Node> {\n        return new RBTree<Node>((a, b) => a.pos - b.pos);\n    }\n\n    interface RectAccessors {\n        getCentre: (r: Rectangle) => number;\n        getOpen: (r: Rectangle) => number;\n        getClose: (r: Rectangle) => number;\n        getSize: (r: Rectangle) => number;\n        makeRect: (open: number, close: number, center: number, size: number) => Rectangle;\n        findNeighbours: (v: Node, scanline: RBTree<Node>) => void;\n    }\n\n    var xRect: RectAccessors = {\n        getCentre: r=> r.cx(),\n        getOpen: r=> r.y,\n        getClose: r=> r.Y,\n        getSize: r=> r.width(),\n        makeRect: (open, close, center, size) => new Rectangle(center - size / 2, center + size / 2, open, close) ,\n        findNeighbours: findXNeighbours\n    };\n\n    var yRect: RectAccessors = {\n        getCentre: r=> r.cy(),\n        getOpen: r=> r.x,\n        getClose: r=> r.X,\n        getSize: r=> r.height(),\n        makeRect: (open, close, center, size) => new Rectangle(open, close, center - size / 2, center + size / 2),\n        findNeighbours: findYNeighbours\n    };\n\n    function generateGroupConstraints(root: ProjectionGroup, f: RectAccessors, minSep: number, isContained: boolean = false): Constraint[]\n    {\n        var padding = root.padding,\n            gn = typeof root.groups !== 'undefined' ? root.groups.length : 0,\n            ln = typeof root.leaves !== 'undefined' ? root.leaves.length : 0,\n            childConstraints: Constraint[] = !gn ? []\n            : root.groups.reduce((ccs: Constraint[], g) => ccs.concat(generateGroupConstraints(g, f, minSep, true)), []),\n            n = (isContained ? 2 : 0) + ln + gn,\n            vs: Variable[] = new Array(n),\n            rs: Rectangle[] = new Array(n),\n            i = 0,\n            add = (r, v) => { rs[i] = r; vs[i++] = v };\n        if (isContained) {\n            // if this group is contained by another, then we add two dummy vars and rectangles for the borders\n            var b: Rectangle = root.bounds,\n                c = f.getCentre(b), s = f.getSize(b) / 2,\n                open = f.getOpen(b), close = f.getClose(b),\n                min = c - s + padding / 2, max = c + s - padding / 2;\n            root.minVar.desiredPosition = min;\n            add(f.makeRect(open, close, min, padding), root.minVar);\n            root.maxVar.desiredPosition = max;\n            add(f.makeRect(open, close, max, padding), root.maxVar);\n        }\n        if (ln) root.leaves.forEach(l => add(l.bounds, l.variable));\n        if (gn) root.groups.forEach(g => {\n            var b: Rectangle = g.bounds;\n            add(f.makeRect(f.getOpen(b), f.getClose(b), f.getCentre(b), f.getSize(b)), g.minVar);\n        });\n        var cs = generateConstraints(rs, vs, f, minSep);\n        if (gn) {\n            vs.forEach(v => { v.cOut = [], v.cIn = [] });\n            cs.forEach(c => { c.left.cOut.push(c), c.right.cIn.push(c) });\n            root.groups.forEach(g => {\n                var gapAdjustment = (g.padding - f.getSize(g.bounds)) / 2;\n                g.minVar.cIn.forEach(c => c.gap += gapAdjustment);\n                g.minVar.cOut.forEach(c => { c.left = g.maxVar; c.gap += gapAdjustment; });\n            });\n        }\n        return childConstraints.concat(cs);\n    }\n\n    function generateConstraints(rs: Rectangle[], vars: Variable[],\n        rect: RectAccessors, minSep: number): Constraint[]\n    {\n        var i, n = rs.length;\n        var N = 2 * n;\n        console.assert(vars.length >= n);\n        var events = new Array<Event>(N);\n        for (i = 0; i < n; ++i) {\n            var r = rs[i];\n            var v = new Node(vars[i], r, rect.getCentre(r));\n            events[i] = new Event(true, v, rect.getOpen(r));\n            events[i + n] = new Event(false, v, rect.getClose(r));\n        }\n        events.sort(compareEvents);\n        var cs = new Array<Constraint>();\n        var scanline = makeRBTree();\n        for (i = 0; i < N; ++i) {\n            var e = events[i];\n            var v = e.v;\n            if (e.isOpen) {\n                scanline.insert(v);\n                rect.findNeighbours(v, scanline);\n            } else {\n                // close event\n                scanline.remove(v);\n                var makeConstraint = (l, r) => {\n                    var sep = (rect.getSize(l.r) + rect.getSize(r.r)) / 2 + minSep;\n                    cs.push(new Constraint(l.v, r.v, sep));\n                };\n                var visitNeighbours = (forward, reverse, mkcon) => {\n                    var u, it = v[forward].iterator();\n                    while ((u = it[forward]()) !== null) {\n                        mkcon(u, v);\n                        u[reverse].remove(v);\n                    }\n                };\n                visitNeighbours(\"prev\", \"next\", (u, v) => makeConstraint(u, v));\n                visitNeighbours(\"next\", \"prev\", (u, v) => makeConstraint(v, u));\n            }\n        }\n        console.assert(scanline.size === 0);\n        return cs;\n    }\n\n    function findXNeighbours(v: Node, scanline: RBTree<Node>): void {\n        var f = (forward, reverse) => {\n            var it = scanline.findIter(v);\n            var u;\n            while ((u = it[forward]()) !== null) {\n                var uovervX = u.r.overlapX(v.r);\n                if (uovervX <= 0 || uovervX <= u.r.overlapY(v.r)) {\n                    v[forward].insert(u);\n                    u[reverse].insert(v);\n                }\n                if (uovervX <= 0) {\n                    break;\n                }\n            }\n        }\n        f(\"next\", \"prev\");\n        f(\"prev\", \"next\");\n    }\n\n    function findYNeighbours(v: Node, scanline: RBTree<Node>): void {\n        var f = (forward, reverse) => {\n            var u = scanline.findIter(v)[forward]();\n            if (u !== null && u.r.overlapX(v.r) > 0) {\n                v[forward].insert(u);\n                u[reverse].insert(v);\n            }\n        }\n        f(\"next\", \"prev\");\n        f(\"prev\", \"next\");\n    }\n\n    export function generateXConstraints(rs: Rectangle[], vars: Variable[]): Constraint[] {\n        return generateConstraints(rs, vars, xRect, 1e-6);\n    }\n\n    export function generateYConstraints(rs: Rectangle[], vars: Variable[]): Constraint[] {\n        return generateConstraints(rs, vars, yRect, 1e-6);\n    }\n\n    export function generateXGroupConstraints(root: ProjectionGroup): Constraint[] {\n        return generateGroupConstraints(root, xRect, 1e-6);\n    }\n\n    export function generateYGroupConstraints(root: ProjectionGroup): Constraint[] {\n        return generateGroupConstraints(root, yRect, 1e-6);\n    }\n\n    export function removeOverlaps(rs: Rectangle[]): void {\n        var vs = rs.map(r => new Variable(r.cx()));\n        var cs = generateXConstraints(rs, vs);\n        var solver = new Solver(vs, cs);\n        solver.solve();\n        vs.forEach((v, i) => rs[i].setXCentre(v.position()));\n        vs = rs.map(r=> new Variable(r.cy()));\n        cs = generateYConstraints(rs, vs);\n        solver = new Solver(vs, cs);\n        solver.solve();\n        vs.forEach((v, i) => rs[i].setYCentre(v.position()));\n    }\n\n    export interface GraphNode extends Leaf {\n        fixed: boolean;\n        fixedWeight?: number;\n        width: number;\n        height: number;\n        x: number;\n        y: number;\n        px: number;\n        py: number;\n    }\n\n    export class IndexedVariable extends Variable {\n        constructor(public index: number, w: number) {\n            super(0, w);\n        }\n    }\n\n    export class Projection {\n        private xConstraints: Constraint[];\n        private yConstraints: Constraint[];\n        private variables: Variable[];\n\n        constructor(private nodes: GraphNode[],\n            private groups: ProjectionGroup[],\n            private rootGroup: ProjectionGroup = null,\n            constraints: any[]= null,\n            private avoidOverlaps: boolean = false)\n        {\n            this.variables = nodes.map((v, i) => {\n                return v.variable = new IndexedVariable(i, 1);\n            });\n\n            if (constraints) this.createConstraints(constraints);\n\n            if (avoidOverlaps && rootGroup && typeof rootGroup.groups !== 'undefined') {\n                nodes.forEach(v => {\n\t\t\t\t\tif (!v.width || !v.height)\n\t\t\t\t\t{\n\t\t\t\t\t\t//If undefined, default to nothing\n\t\t\t\t\t\tv.bounds = new Rectangle(v.x, v.x, v.y, v.y);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n                    var w2 = v.width / 2, h2 = v.height / 2;\n                    v.bounds = new Rectangle(v.x - w2, v.x + w2, v.y - h2, v.y + h2);\n                });\n                computeGroupBounds(rootGroup);\n                var i = nodes.length;\n                groups.forEach(g => {\n                    this.variables[i] = g.minVar = new IndexedVariable(i++, typeof g.stiffness !== \"undefined\" ? g.stiffness : 0.01);\n                    this.variables[i] = g.maxVar = new IndexedVariable(i++, typeof g.stiffness !== \"undefined\" ? g.stiffness : 0.01);\n                });\n            }\n        }\n\n\n        private createSeparation(c: any) : Constraint {\n            return new Constraint(\n                this.nodes[c.left].variable,\n                this.nodes[c.right].variable,\n                c.gap,\n                typeof c.equality !== \"undefined\" ? c.equality : false);\n        }\n\n        // simple satisfaction of alignment constraints to ensure initial feasibility\n        private makeFeasible(c: any) {\n            if (!this.avoidOverlaps) return;\n            // sort nodes in constraint by position (along \"guideline\")\n            var axis = 'x', dim = 'width';\n            if (c.axis === 'x') axis = 'y', dim = 'height';\n            var vs: GraphNode[] = c.offsets.map(o => this.nodes[o.node]).sort((a, b) => a[axis] - b[axis]);\n            var p: GraphNode = null;\n            vs.forEach(v => {\n                // if two nodes overlap then shove the second one along\n                if (p) {\n                    let nextPos = p[axis] + p[dim];\n                    if (nextPos > v[axis]) {\n                        v[axis] = nextPos;\n                    }\n                }\n                p = v;\n            });\n        }\n\n        private createAlignment(c: any) {\n            var u = this.nodes[c.offsets[0].node].variable;\n            this.makeFeasible(c);\n            var cs = c.axis === 'x' ? this.xConstraints : this.yConstraints;\n            c.offsets.slice(1).forEach(o => {\n                var v = this.nodes[o.node].variable;\n                cs.push(new Constraint(u, v, o.offset, true));\n            });\n        }\n\n        private createConstraints(constraints: any[]) {\n            var isSep = c => typeof c.type === 'undefined' || c.type === 'separation';\n            this.xConstraints = constraints\n                .filter(c => c.axis === \"x\" && isSep(c))\n                .map(c => this.createSeparation(c));\n            this.yConstraints = constraints\n                .filter(c => c.axis === \"y\" && isSep(c))\n                .map(c => this.createSeparation(c));\n            constraints\n                .filter(c => c.type === 'alignment')\n                .forEach(c => this.createAlignment(c));\n        }\n\n        private setupVariablesAndBounds(x0: Float32Array, y0: Float32Array, desired: Float32Array, getDesired: (v: GraphNode) => number) {\n            this.nodes.forEach((v, i) => {\n                if (v.fixed) {\n                    v.variable.weight = v.fixedWeight ? v.fixedWeight : 1000;\n                    desired[i] = getDesired(v);\n                } else {\n                    v.variable.weight = 1;\n                }\n                var w = (v.width || 0) / 2, h = (v.height || 0) / 2;\n                var ix = x0[i], iy = y0[i];\n                v.bounds = new Rectangle(ix - w, ix + w, iy - h, iy + h);\n            });\n        }\n\n        xProject(x0: Float32Array, y0: Float32Array, x: Float32Array) {\n            if (!this.rootGroup && !(this.avoidOverlaps || this.xConstraints)) return;\n            this.project(x0, y0, x0, x, v=> v.px, this.xConstraints, generateXGroupConstraints,\n                v => v.bounds.setXCentre(x[(<IndexedVariable>v.variable).index] = v.variable.position()),\n                g => {\n                    var xmin = x[(<IndexedVariable>g.minVar).index] = g.minVar.position();\n                    var xmax = x[(<IndexedVariable>g.maxVar).index] = g.maxVar.position();\n                    var p2 = g.padding / 2;\n                    g.bounds.x = xmin - p2;\n                    g.bounds.X = xmax + p2;\n                });\n        }\n\n        yProject(x0: Float32Array, y0: Float32Array, y: Float32Array) {\n            if (!this.rootGroup && !this.yConstraints) return;\n            this.project(x0, y0, y0, y, v=> v.py, this.yConstraints, generateYGroupConstraints,\n                v => v.bounds.setYCentre(y[(<IndexedVariable>v.variable).index] = v.variable.position()),\n                g => {\n                    var ymin = y[(<IndexedVariable>g.minVar).index] = g.minVar.position();\n                    var ymax = y[(<IndexedVariable>g.maxVar).index] = g.maxVar.position();\n                    var p2 = g.padding / 2;\n                    g.bounds.y = ymin - p2;;\n                    g.bounds.Y = ymax + p2;\n                });\n        }\n\n        projectFunctions(): { (x0: Float32Array, y0: Float32Array, r: Float32Array): void }[]{\n            return [\n                (x0, y0, x) => this.xProject(x0, y0, x),\n                (x0, y0, y) => this.yProject(x0, y0, y)\n            ];\n        }\n\n        private project(x0: Float32Array, y0: Float32Array, start: Float32Array, desired: Float32Array,\n            getDesired: (v: GraphNode) => number,\n            cs: Constraint[],\n            generateConstraints: (g: ProjectionGroup) => Constraint[],\n            updateNodeBounds: (v: GraphNode) => any,\n            updateGroupBounds: (g: ProjectionGroup) => any)\n        {\n            this.setupVariablesAndBounds(x0, y0, desired, getDesired);\n            if (this.rootGroup && this.avoidOverlaps) {\n                computeGroupBounds(this.rootGroup);\n                cs = cs.concat(generateConstraints(this.rootGroup));\n            }\n            this.solve(this.variables, cs, start, desired);\n            this.nodes.forEach(updateNodeBounds);\n            if (this.rootGroup && this.avoidOverlaps) {\n                this.groups.forEach(updateGroupBounds);\n                computeGroupBounds(this.rootGroup);\n            }\n        }\n\n        private solve(vs: Variable[], cs: Constraint[], starting: Float32Array, desired: Float32Array) {\n            var solver = new Solver(vs, cs);\n            solver.setStartingPositions(starting);\n            solver.setDesiredPositions(desired);\n            solver.solve();\n        }\n    }\n","\nexport class PairingHeap<T> {\n    private subheaps : PairingHeap<T>[];\n    // from: https://gist.github.com/nervoussystem\n    //{elem:object, subheaps:[array of heaps]}\n    constructor(public elem: T) {\n        this.subheaps = [];\n    }\n\n    public toString(selector) : string {\n        var str = \"\", needComma = false;\n        for (var i = 0; i < this.subheaps.length; ++i) {\n            var subheap: PairingHeap<T> = this.subheaps[i];\n            if (!subheap.elem) {\n                needComma = false;\n                continue;\n            }\n            if (needComma) {\n                str = str + \",\";\n            }\n            str = str + subheap.toString(selector);\n            needComma = true;\n        }\n        if (str !== \"\") {\n            str = \"(\" + str + \")\";\n        }\n        return (this.elem ? selector(this.elem) : \"\") + str;\n    }\n\n    public forEach(f) {\n        if (!this.empty()) {\n            f(this.elem, this);\n            this.subheaps.forEach(s => s.forEach(f));\n        }\n    }\n\n    public count(): number {\n        return this.empty() ? 0 : 1 + this.subheaps.reduce((n: number, h: PairingHeap<T>) => {\n            return n + h.count();\n        }, 0);\n    }\n\n    public min() : T {\n        return this.elem;\n    }\n\n    public empty() : boolean {\n        return this.elem == null;\n    }\n\n    public contains(h: PairingHeap<T>): boolean {\n        if (this === h) return true;\n        for (var i = 0; i < this.subheaps.length; i++) {\n            if (this.subheaps[i].contains(h)) return true;\n        }\n        return false;\n    }\n\n    public isHeap(lessThan: (a: T, b: T) => boolean): boolean {\n        return this.subheaps.every(h=> lessThan(this.elem, h.elem) && h.isHeap(lessThan));\n    }\n\n    public insert(obj : T, lessThan) : PairingHeap<T> {\n        return this.merge(new PairingHeap<T>(obj), lessThan);\n    }\n\n    public merge(heap2: PairingHeap<T>, lessThan): PairingHeap<T> {\n        if (this.empty()) return heap2;\n        else if (heap2.empty()) return this;\n        else if (lessThan(this.elem, heap2.elem)) {\n            this.subheaps.push(heap2);\n            return this;\n        } else {\n            heap2.subheaps.push(this);\n            return heap2;\n        }\n    }\n\n    public removeMin(lessThan: (a: T, b: T) => boolean): PairingHeap<T> {\n        if (this.empty()) return null;\n        else return this.mergePairs(lessThan);\n    }\n\n    public mergePairs(lessThan: (a: T, b: T) => boolean) : PairingHeap<T> {\n        if (this.subheaps.length == 0) return new PairingHeap<T>(null);\n        else if (this.subheaps.length == 1) { return this.subheaps[0]; }\n        else {\n            var firstPair = this.subheaps.pop().merge(this.subheaps.pop(), lessThan);\n            var remaining = this.mergePairs(lessThan);\n            return firstPair.merge(remaining, lessThan);\n        }\n    }\n    public decreaseKey(subheap: PairingHeap<T>, newValue: T, setHeapNode: (e: T, h: PairingHeap<T>)=>void, lessThan: (a: T, b: T) => boolean): PairingHeap<T> {\n        var newHeap = subheap.removeMin(lessThan);\n        //reassign subheap values to preserve tree\n        subheap.elem = newHeap.elem;\n        subheap.subheaps = newHeap.subheaps;\n        if (setHeapNode !== null && newHeap.elem !== null) {\n            setHeapNode(subheap.elem, subheap);\n        }\n        var pairingNode = new PairingHeap(newValue);\n        if (setHeapNode !== null) {\n            setHeapNode(newValue, pairingNode);\n        }\n        return this.merge(pairingNode, lessThan);\n    }\n}\n\n/**\n * @class PriorityQueue a min priority queue backed by a pairing heap\n */\nexport class PriorityQueue<T> {\n    private root : PairingHeap<T>;\n    constructor(private lessThan: (a: T, b: T) => boolean) { }\n    /**\n     * @method top\n     * @return the top element (the min element as defined by lessThan)\n     */\n    public top() : T {\n        if (this.empty()) { return null; }\n        return this.root.elem;\n    }\n    /**\n     * @method push\n     * put things on the heap\n     */\n    public push(...args: T[]): PairingHeap<T> {\n        var pairingNode;\n        for (var i = 0, arg; arg=args[i]; ++i) {\n            pairingNode = new PairingHeap(arg);\n            this.root = this.empty() ?\n                pairingNode : this.root.merge(pairingNode, this.lessThan);\n        }\n        return pairingNode;\n    }\n    /**\n     * @method empty\n     * @return true if no more elements in queue\n     */\n    public empty(): boolean {\n        return !this.root || !this.root.elem;\n    }\n    /**\n     * @method isHeap check heap condition (for testing)\n     * @return true if queue is in valid state\n     */\n    public isHeap(): boolean {\n        return this.root.isHeap(this.lessThan);\n    }\n    /**\n     * @method forEach apply f to each element of the queue\n     * @param f function to apply\n     */\n    public forEach(f) {\n        this.root.forEach(f);\n    }\n    /**\n     * @method pop remove and return the min element from the queue\n     */\n    public pop(): T {\n        if (this.empty()) {\n            return null;\n        }\n        var obj = this.root.min();\n        this.root = this.root.removeMin(this.lessThan);\n        return obj;\n    }\n    /**\n     * @method reduceKey reduce the key value of the specified heap node\n     */\n    public reduceKey(heapNode: PairingHeap<T>, newKey: T, setHeapNode: (e: T, h: PairingHeap<T>)=>void = null): void {\n        this.root = this.root.decreaseKey(heapNode, newKey, setHeapNode, this.lessThan);\n    }\n    public toString(selector) {\n        return this.root.toString(selector);\n    }\n    /**\n     * @method count\n     * @return number of elements in queue\n     */\n    public count() {\n        return this.root.count();\n    }\n}\n","import {PairingHeap, PriorityQueue} from './pqueue'\n\nclass Neighbour {\n    constructor(public id: number, public distance: number) { }\n}\n\nclass Node {\n    constructor(public id: number) {\n        this.neighbours = [];\n    }\n    neighbours: Neighbour[];\n    d: number;\n    prev: Node;\n    q: PairingHeap<Node>;\n}\n\nclass QueueEntry {\n    constructor(public node: Node, public prev: QueueEntry, public d: number) {}\n}\n\n/**\n * calculates all-pairs shortest paths or shortest paths from a single node\n * @class Calculator\n * @constructor\n * @param n {number} number of nodes\n * @param es {Edge[]} array of edges\n */\nexport class Calculator<Link> {\n    private neighbours: Node[];\n\n    constructor(public n: number, public es: Link[], getSourceIndex: (l: Link) => number, getTargetIndex: (l: Link) => number, getLength: (l: Link) => number) {\n        this.neighbours = new Array(this.n);\n        var i = this.n; while (i--) this.neighbours[i] = new Node(i);\n\n        i = this.es.length; while (i--) {\n            var e = this.es[i];\n            var u: number = getSourceIndex(e), v: number = getTargetIndex(e);\n            var d = getLength(e);\n            this.neighbours[u].neighbours.push(new Neighbour(v, d));\n            this.neighbours[v].neighbours.push(new Neighbour(u, d));\n        }\n    }\n\n    /**\n     * compute shortest paths for graph over n nodes with edges an array of source/target pairs\n     * edges may optionally have a length attribute.  1 is the default.\n     * Uses Johnson's algorithm.\n     *\n     * @method DistanceMatrix\n     * @return the distance matrix\n     */\n    DistanceMatrix(): number[][] {\n        var D = new Array(this.n);\n        for (var i = 0; i < this.n; ++i) {\n            D[i] = this.dijkstraNeighbours(i);\n        }\n        return D;\n    }\n\n    /**\n     * get shortest paths from a specified start node\n     * @method DistancesFromNode\n     * @param start node index\n     * @return array of path lengths\n     */\n    DistancesFromNode(start: number): number[] {\n        return this.dijkstraNeighbours(start);\n    }\n\n    PathFromNodeToNode(start: number, end: number): number[] {\n        return this.dijkstraNeighbours(start, end);\n    }\n\n    // find shortest path from start to end, with the opportunity at\n    // each edge traversal to compute a custom cost based on the\n    // previous edge.  For example, to penalise bends.\n    PathFromNodeToNodeWithPrevCost(\n        start: number,\n        end: number,\n        prevCost: (u:number,v:number,w:number)=>number): number[]\n    {\n        var q = new PriorityQueue<QueueEntry>((a, b) => a.d <= b.d),\n            u: Node = this.neighbours[start],\n            qu: QueueEntry = new QueueEntry(u,null,0),\n            visitedFrom = {};\n        q.push(qu);\n        while(!q.empty()) {\n            qu = q.pop();\n            u = qu.node;\n            if (u.id === end) {\n                break;\n            }\n            var i = u.neighbours.length; while (i--) {\n                var neighbour = u.neighbours[i],\n                    v = this.neighbours[neighbour.id];\n\n                // don't double back\n                if (qu.prev && v.id === qu.prev.node.id) continue;\n\n                // don't retraverse an edge if it has already been explored\n                // from a lower cost route\n                var viduid = v.id + ',' + u.id;\n                if(viduid in visitedFrom && visitedFrom[viduid] <= qu.d)\n                    continue;\n\n                var cc = qu.prev ? prevCost(qu.prev.node.id, u.id, v.id) : 0,\n                    t = qu.d + neighbour.distance + cc;\n\n                // store cost of this traversal\n                visitedFrom[viduid] = t;\n                q.push(new QueueEntry(v, qu, t));\n            }\n        }\n        var path:number[] = [];\n        while (qu.prev) {\n            qu = qu.prev;\n            path.push(qu.node.id);\n        }\n        return path;\n    }\n\n    private dijkstraNeighbours(start: number, dest: number = -1): number[] {\n        var q = new PriorityQueue<Node>((a, b) => a.d <= b.d),\n            i = this.neighbours.length,\n            d: number[] = new Array(i);\n        while (i--) {\n            var node: Node = this.neighbours[i];\n            node.d = i === start ? 0 : Number.POSITIVE_INFINITY;\n            node.q = q.push(node);\n        }\n        while (!q.empty()) {\n            // console.log(q.toString(function (u) { return u.id + \"=\" + (u.d === Number.POSITIVE_INFINITY ? \"\\u221E\" : u.d.toFixed(2) )}));\n            var u = q.pop();\n            d[u.id] = u.d;\n            if (u.id === dest) {\n                var path: number[] = [];\n                var v = u;\n                while (typeof v.prev !== 'undefined') {\n                    path.push(v.prev.id);\n                    v = v.prev;\n                }\n                return path;\n            }\n            i = u.neighbours.length; while (i--) {\n                var neighbour = u.neighbours[i];\n                var v = this.neighbours[neighbour.id];\n                var t = u.d + neighbour.distance;\n                if (u.d !== Number.MAX_VALUE && v.d > t) {\n                    v.d = t;\n                    v.prev = u;\n                    q.reduceKey(v.q, v, (e,q)=>e.q = q);\n                }\n            }\n        }\n        return d;\n    }\n}\n","import {Rectangle} from './rectangle'\n    export class Point {\n        x: number;\n        y: number;\n    }\n\n    export class LineSegment {\n        constructor(public x1: number, public y1: number, public x2: number, public y2: number) { }\n    }\n\n    export class PolyPoint extends Point {\n        polyIndex: number;\n    }\n\n    /** tests if a point is Left|On|Right of an infinite line.\n     * @param points P0, P1, and P2\n     * @return >0 for P2 left of the line through P0 and P1\n     *            =0 for P2 on the line\n     *            <0 for P2 right of the line\n     */\n    export function isLeft(P0: Point, P1: Point, P2: Point): number {\n        return (P1.x - P0.x) * (P2.y - P0.y) - (P2.x - P0.x) * (P1.y - P0.y);\n    }\n\n    function above(p: Point, vi: Point, vj: Point): boolean {\n        return isLeft(p, vi, vj) > 0;\n    }\n\n    function below(p: Point, vi: Point, vj: Point): boolean {\n        return isLeft(p, vi, vj) < 0;\n    }\n\n\n    /**\n     * returns the convex hull of a set of points using Andrew's monotone chain algorithm\n     * see: http://geomalgorithms.com/a10-_hull-1.html#Monotone%20Chain\n     * @param S array of points\n     * @return the convex hull as an array of points\n     */\n    export function ConvexHull(S: Point[]): Point[] {\n        var P = S.slice(0).sort((a, b) => a.x !== b.x ? b.x - a.x : b.y - a.y);\n        var n = S.length, i;\n        var minmin = 0;\n        var xmin = P[0].x;\n        for (i = 1; i < n; ++i) {\n            if (P[i].x !== xmin) break;\n        }\n        var minmax = i - 1;\n        var H: Point[] = [];\n        H.push(P[minmin]); // push minmin point onto stack\n        if (minmax === n - 1) { // degenerate case: all x-coords == xmin\n            if (P[minmax].y !== P[minmin].y) // a  nontrivial segment\n                H.push(P[minmax]);\n        } else {\n            // Get the indices of points with max x-coord and min|max y-coord\n            var maxmin, maxmax = n - 1;\n            var xmax = P[n - 1].x;\n            for (i = n - 2; i >= 0; i--)\n                if (P[i].x !== xmax) break;\n            maxmin = i + 1;\n\n            // Compute the lower hull on the stack H\n            i = minmax;\n            while (++i <= maxmin) {\n                // the lower line joins P[minmin]  with P[maxmin]\n                if (isLeft(P[minmin], P[maxmin], P[i]) >= 0 && i < maxmin)\n                    continue; // ignore P[i] above or on the lower line\n\n                while (H.length > 1) // there are at least 2 points on the stack\n                {\n                    // test if  P[i] is left of the line at the stack top\n                    if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)\n                        break; // P[i] is a new hull  vertex\n                    else\n                        H.length -= 1; // pop top point off  stack\n                }\n                if (i != minmin) H.push(P[i]);\n            }\n\n            // Next, compute the upper hull on the stack H above the bottom hull\n            if (maxmax != maxmin) // if  distinct xmax points\n                H.push(P[maxmax]); // push maxmax point onto stack\n            var bot = H.length; // the bottom point of the upper hull stack\n            i = maxmin;\n            while (--i >= minmax) {\n                // the upper line joins P[maxmax]  with P[minmax]\n                if (isLeft(P[maxmax], P[minmax], P[i]) >= 0 && i > minmax)\n                    continue; // ignore P[i] below or on the upper line\n\n                while (H.length > bot) // at least 2 points on the upper stack\n                {\n                    // test if  P[i] is left of the line at the stack top\n                    if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)\n                        break; // P[i] is a new hull  vertex\n                    else\n                        H.length -= 1; // pop top point off  stack\n                }\n                if (i != minmin) H.push(P[i]); // push P[i] onto stack\n            }\n        }\n        return H;\n    }\n\n    // apply f to the points in P in clockwise order around the point p\n    export function clockwiseRadialSweep(p: Point, P: Point[], f: (p: Point) => void) {\n        P.slice(0).sort(\n            (a, b) => Math.atan2(a.y - p.y, a.x - p.x) - Math.atan2(b.y - p.y, b.x - p.x)\n            ).forEach(f);\n    }\n\n    function nextPolyPoint(p: PolyPoint, ps: PolyPoint[]): PolyPoint {\n        if (p.polyIndex === ps.length - 1) return ps[0];\n        return ps[p.polyIndex + 1];\n    }\n\n    function prevPolyPoint(p: PolyPoint, ps: PolyPoint[]): PolyPoint {\n        if (p.polyIndex === 0) return ps[ps.length - 1];\n        return ps[p.polyIndex - 1];\n    }\n\n    // tangent_PointPolyC(): fast binary search for tangents to a convex polygon\n    //    Input:  P = a 2D point (exterior to the polygon)\n    //            n = number of polygon vertices\n    //            V = array of vertices for a 2D convex polygon\n    //    Output: rtan = index of rightmost tangent point V[rtan]\n    //            ltan = index of leftmost tangent point V[ltan]\n    function tangent_PointPolyC(P: Point, V: Point[]): { rtan: number; ltan: number } {\n        // Rtangent_PointPolyC and Ltangent_PointPolyC require polygon to be\n        // \"closed\" with the first vertex duplicated at end, so V[n-1] = V[0].\n        let Vclosed = V.slice(0);  // Copy V\n        Vclosed.push(V[0]);        // Add V[0] at end\n\n        return { rtan: Rtangent_PointPolyC(P, Vclosed), ltan: Ltangent_PointPolyC(P, Vclosed) };\n    }\n\n\n    // Rtangent_PointPolyC(): binary search for convex polygon right tangent\n    //    Input:  P = a 2D point (exterior to the polygon)\n    //            n = number of polygon vertices\n    //            V = array of vertices for a 2D convex polygon with first\n    //                vertex duplicated as last, so V[n-1] = V[0]\n    //    Return: index \"i\" of rightmost tangent point V[i]\n    function Rtangent_PointPolyC(P: Point, V: Point[]): number {\n        var n = V.length - 1;\n\n        // use binary search for large convex polygons\n        var a: number, b: number, c: number;            // indices for edge chain endpoints\n        var upA: boolean, dnC: boolean;           // test for up direction of edges a and c\n\n        // rightmost tangent = maximum for the isLeft() ordering\n        // test if V[0] is a local maximum\n        if (below(P, V[1], V[0]) && !above(P, V[n - 1], V[0]))\n            return 0;               // V[0] is the maximum tangent point\n\n        for (a = 0, b = n; ;) {          // start chain = [0,n] with V[n]=V[0]\n            if (b - a === 1)\n                if (above(P, V[a], V[b]))\n                    return a;\n                else\n                    return b;\n\n            c = Math.floor((a + b) / 2);        // midpoint of [a,b], and 0<c<n\n            dnC = below(P, V[c + 1], V[c]);\n            if (dnC && !above(P, V[c - 1], V[c]))\n                return c;          // V[c] is the maximum tangent point\n\n            // no max yet, so continue with the binary search\n            // pick one of the two subchains [a,c] or [c,b]\n            upA = above(P, V[a + 1], V[a]);\n            if (upA) {                       // edge a points up\n                if (dnC)                         // edge c points down\n                    b = c;                           // select [a,c]\n                else {                           // edge c points up\n                    if (above(P, V[a], V[c]))     // V[a] above V[c]\n                        b = c;                       // select [a,c]\n                    else                          // V[a] below V[c]\n                        a = c;                       // select [c,b]\n                }\n            }\n            else {                           // edge a points down\n                if (!dnC)                        // edge c points up\n                    a = c;                           // select [c,b]\n                else {                           // edge c points down\n                    if (below(P, V[a], V[c]))     // V[a] below V[c]\n                        b = c;                       // select [a,c]\n                    else                          // V[a] above V[c]\n                        a = c;                       // select [c,b]\n                }\n            }\n        }\n    }\n\n    // Ltangent_PointPolyC(): binary search for convex polygon left tangent\n    //    Input:  P = a 2D point (exterior to the polygon)\n    //            n = number of polygon vertices\n    //            V = array of vertices for a 2D convex polygon with first\n    //                vertex duplicated as last, so V[n-1] = V[0]\n    //    Return: index \"i\" of leftmost tangent point V[i]\n    function Ltangent_PointPolyC(P: Point, V: Point[]): number {\n        var n = V.length - 1;\n        // use binary search for large convex polygons\n        var a: number, b: number, c: number;             // indices for edge chain endpoints\n        var dnA: boolean, dnC: boolean;           // test for down direction of edges a and c\n\n        // leftmost tangent = minimum for the isLeft() ordering\n        // test if V[0] is a local minimum\n        if (above(P, V[n - 1], V[0]) && !below(P, V[1], V[0]))\n            return 0;               // V[0] is the minimum tangent point\n\n        for (a = 0, b = n; ;) {          // start chain = [0,n] with V[n] = V[0]\n            if (b - a === 1)\n                if (below(P, V[a], V[b]))\n                    return a;\n                else\n                    return b;\n\n            c = Math.floor((a + b) / 2);        // midpoint of [a,b], and 0<c<n\n            dnC = below(P, V[c + 1], V[c]);\n            if (above(P, V[c - 1], V[c]) && !dnC)\n                return c;          // V[c] is the minimum tangent point\n\n            // no min yet, so continue with the binary search\n            // pick one of the two subchains [a,c] or [c,b]\n            dnA = below(P, V[a + 1], V[a]);\n            if (dnA) {                       // edge a points down\n                if (!dnC)                        // edge c points up\n                    b = c;                           // select [a,c]\n                else {                           // edge c points down\n                    if (below(P, V[a], V[c]))     // V[a] below V[c]\n                        b = c;                       // select [a,c]\n                    else                          // V[a] above V[c]\n                        a = c;                       // select [c,b]\n                }\n            }\n            else {                           // edge a points up\n                if (dnC)                         // edge c points down\n                    a = c;                           // select [c,b]\n                else {                           // edge c points up\n                    if (above(P, V[a], V[c]))     // V[a] above V[c]\n                        b = c;                       // select [a,c]\n                    else                          // V[a] below V[c]\n                        a = c;                       // select [c,b]\n                }\n            }\n        }\n    }\n\n    // RLtangent_PolyPolyC(): get the RL tangent between two convex polygons\n    //    Input:  m = number of vertices in polygon 1\n    //            V = array of vertices for convex polygon 1 with V[m]=V[0]\n    //            n = number of vertices in polygon 2\n    //            W = array of vertices for convex polygon 2 with W[n]=W[0]\n    //    Output: *t1 = index of tangent point V[t1] for polygon 1\n    //            *t2 = index of tangent point W[t2] for polygon 2\n    export function tangent_PolyPolyC(V: Point[], W: Point[], t1: (a: Point, b: Point[]) => number, t2: (a: Point, b: Point[]) => number, cmp1: (a: Point, b: Point, c: Point) => boolean, cmp2: (a: Point, b: Point, c: Point) => boolean): { t1: number; t2: number } {\n        var ix1: number, ix2: number;      // search indices for polygons 1 and 2\n\n        // first get the initial vertex on each polygon\n        ix1 = t1(W[0], V);   // right tangent from W[0] to V\n        ix2 = t2(V[ix1], W); // left tangent from V[ix1] to W\n\n        // ping-pong linear search until it stabilizes\n        var done = false;                    // flag when done\n        while (!done) {\n            done = true;                     // assume done until...\n            while (true) {\n                if (ix1 === V.length - 1) ix1 = 0;\n                if (cmp1(W[ix2], V[ix1], V[ix1 + 1])) break;\n                ++ix1;                       // get Rtangent from W[ix2] to V\n            }\n            while (true) {\n                if (ix2 === 0) ix2 = W.length - 1;\n                if (cmp2(V[ix1], W[ix2], W[ix2 - 1])) break;\n                --ix2;                       // get Ltangent from V[ix1] to W\n                done = false;                // not done if had to adjust this\n            }\n        }\n        return { t1: ix1, t2: ix2 };\n    }\n\n    export function LRtangent_PolyPolyC(V: Point[], W: Point[]): { t1: number; t2: number } {\n        var rl = RLtangent_PolyPolyC(W, V);\n        return { t1: rl.t2, t2: rl.t1 };\n    }\n\n    export function RLtangent_PolyPolyC(V: Point[], W: Point[]): { t1: number; t2: number } {\n        return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Ltangent_PointPolyC, above, below);\n    }\n\n    export function LLtangent_PolyPolyC(V: Point[], W: Point[]): { t1: number; t2: number } {\n        return tangent_PolyPolyC(V, W, Ltangent_PointPolyC, Ltangent_PointPolyC, below, below);\n    }\n\n    export function RRtangent_PolyPolyC(V: Point[], W: Point[]): { t1: number; t2: number } {\n        return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Rtangent_PointPolyC, above, above);\n    }\n\n    export class BiTangent {\n        constructor(public t1: number, public t2: number) { }\n    }\n\n    export class BiTangents {\n        rl: BiTangent;\n        lr: BiTangent;\n        ll: BiTangent;\n        rr: BiTangent;\n    }\n\n    export class TVGPoint extends Point {\n        vv: VisibilityVertex;\n    }\n\n    export class VisibilityVertex {\n        constructor(\n            public id: number,\n            public polyid: number,\n            public polyvertid: number,\n            public p: TVGPoint)\n        {\n            p.vv = this;\n        }\n    }\n\n    export class VisibilityEdge {\n        constructor(\n            public source: VisibilityVertex,\n            public target: VisibilityVertex) { }\n        length(): number {\n            var dx = this.source.p.x - this.target.p.x;\n            var dy = this.source.p.y - this.target.p.y;\n            return Math.sqrt(dx * dx + dy * dy);\n        }\n    }\n\n    export class TangentVisibilityGraph {\n        V: VisibilityVertex[] = [];\n        E: VisibilityEdge[] = [];\n        constructor(public P: TVGPoint[][], g0?: { V: VisibilityVertex[]; E: VisibilityEdge[] }) {\n            if (!g0) {\n                var n = P.length;\n                // For each node...\n                for (var i = 0; i < n; i++) {\n                    var p = P[i];\n                    // For each node vertex.\n                    for (var j = 0; j < p.length; ++j) {\n                        var pj = p[j],\n                            vv = new VisibilityVertex(this.V.length, i, j, pj);\n                        this.V.push(vv);\n                        // For the every iteration but the first, generate an\n                        // edge from the previous visibility vertex to the\n                        // current one.\n                        if (j > 0) this.E.push(new VisibilityEdge(p[j - 1].vv, vv));\n                    }\n                    // Add a visibility edge from the first vertex to the last.\n                    if (p.length > 1) this.E.push(new VisibilityEdge(p[0].vv, p[p.length - 1].vv));\n                }\n                for (var i = 0; i < n - 1; i++) {\n                    var Pi = P[i];\n                    for (var j = i + 1; j < n; j++) {\n                        var Pj = P[j],\n                            t = tangents(Pi, Pj);\n                        for (var q in t) {\n                            var c = t[q],\n                                source = Pi[c.t1], target = Pj[c.t2];\n                            this.addEdgeIfVisible(source, target, i, j);\n                        }\n                    }\n                }\n            } else {\n                this.V = g0.V.slice(0);\n                this.E = g0.E.slice(0);\n            }\n        }\n        addEdgeIfVisible(u: TVGPoint, v: TVGPoint, i1: number, i2: number) {\n            if (!this.intersectsPolys(new LineSegment(u.x, u.y, v.x, v.y), i1, i2)) {\n                this.E.push(new VisibilityEdge(u.vv, v.vv));\n            }\n        }\n        addPoint(p: TVGPoint, i1: number): VisibilityVertex {\n            var n = this.P.length;\n            this.V.push(new VisibilityVertex(this.V.length, n, 0, p));\n            for (var i = 0; i < n; ++i) {\n                if (i === i1) continue;\n                var poly = this.P[i],\n                    t = tangent_PointPolyC(p, poly);\n                this.addEdgeIfVisible(p, poly[t.ltan], i1, i);\n                this.addEdgeIfVisible(p, poly[t.rtan], i1, i);\n            }\n            return p.vv;\n        }\n        private intersectsPolys(l: LineSegment, i1: number, i2: number): boolean {\n            for (var i = 0, n = this.P.length; i < n; ++i) {\n                if (i != i1 && i != i2 && intersects(l, this.P[i]).length > 0) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    function intersects(l: LineSegment, P: Point[]) {\n        var ints = [];\n        for (var i = 1, n = P.length; i < n; ++i) {\n            var int = Rectangle.lineIntersection(\n                l.x1, l.y1,\n                l.x2, l.y2,\n                P[i - 1].x, P[i - 1].y,\n                P[i].x, P[i].y\n                );\n            if (int) ints.push(int);\n        }\n        return ints;\n    }\n\n    export function tangents(V: Point[], W: Point[]): BiTangents\n    {\n        var m = V.length - 1, n = W.length - 1;\n        var bt = new BiTangents();\n        for (var i = 0; i <= m; ++i) {\n            for (var j = 0; j <= n; ++j) {\n                var v1 = V[i == 0 ? m : i - 1];\n                var v2 = V[i];\n                var v3 = V[i == m ? 0 : i + 1];\n                var w1 = W[j == 0 ? n : j - 1];\n                var w2 = W[j];\n                var w3 = W[j == n ? 0 : j + 1];\n                var v1v2w2 = isLeft(v1, v2, w2);\n                var v2w1w2 = isLeft(v2, w1, w2);\n                var v2w2w3 = isLeft(v2, w2, w3);\n                var w1w2v2 = isLeft(w1, w2, v2);\n                var w2v1v2 = isLeft(w2, v1, v2);\n                var w2v2v3 = isLeft(w2, v2, v3);\n                if (v1v2w2 >= 0 && v2w1w2 >= 0 && v2w2w3 < 0\n                    && w1w2v2 >= 0 && w2v1v2 >= 0 && w2v2v3 < 0) {\n                        bt.ll = new BiTangent(i, j);\n                } else if (v1v2w2 <= 0 && v2w1w2 <= 0 && v2w2w3 > 0\n                    && w1w2v2 <= 0 && w2v1v2 <= 0 && w2v2v3 > 0) {\n                        bt.rr = new BiTangent(i, j);\n                } else if (v1v2w2 <= 0 && v2w1w2 > 0 && v2w2w3 <= 0\n                    && w1w2v2 >= 0 && w2v1v2 < 0 && w2v2v3 >= 0) {\n                        bt.rl = new BiTangent(i, j);\n                } else if (v1v2w2 >= 0 && v2w1w2 < 0 && v2w2w3 >= 0\n                    && w1w2v2 <= 0 && w2v1v2 > 0 && w2v2v3 <= 0) {\n                        bt.lr = new BiTangent(i, j);\n                }\n            }\n        }\n        return bt;\n    }\n\n    function isPointInsidePoly(p: Point, poly: Point[]): boolean {\n        for (var i = 1, n = poly.length; i < n; ++i)\n            if (below(poly[i - 1], poly[i], p)) return false;\n        return true;\n    }\n\n    function isAnyPInQ(p: Point[], q: Point[]): boolean {\n        return !p.every(v => !isPointInsidePoly(v, q));\n    }\n\n    export function polysOverlap(p: Point[], q: Point[]): boolean {\n        if (isAnyPInQ(p, q)) return true;\n        if (isAnyPInQ(q, p)) return true;\n        for (var i = 1, n = p.length; i < n; ++i) {\n            var v = p[i], u = p[i - 1];\n            if (intersects(new LineSegment(u.x, u.y, v.x, v.y), q).length > 0) return true;\n        }\n        return false;\n    }\n","    var packingOptions = {\n        PADDING: 10,\n        GOLDEN_SECTION: (1 + Math.sqrt(5)) / 2,\n        FLOAT_EPSILON: 0.0001,\n        MAX_INERATIONS: 100\n    };\n\n    // assign x, y to nodes while using box packing algorithm for disconnected graphs\n    export function applyPacking(graphs:Array<any>, w, h, node_size, desired_ratio = 1, centerGraph = true) {\n\n        var init_x = 0,\n            init_y = 0,\n\n            svg_width = w,\n            svg_height = h,\n\n            desired_ratio = typeof desired_ratio !== 'undefined' ? desired_ratio : 1,\n            node_size = typeof node_size !== 'undefined' ? node_size : 0,\n\n            real_width = 0,\n            real_height = 0,\n            min_width = 0,\n\n            global_bottom = 0,\n            line = [];\n\n        if (graphs.length == 0)\n            return;\n\n        /// that would take care of single nodes problem\n        // graphs.forEach(function (g) {\n        //     if (g.array.length == 1) {\n        //         g.array[0].x = 0;\n        //         g.array[0].y = 0;\n        //     }\n        // });\n\n        calculate_bb(graphs);\n        apply(graphs, desired_ratio);\n        if(centerGraph) {\n            put_nodes_to_right_positions(graphs);\n        }\n\n        // get bounding boxes for all separate graphs\n        function calculate_bb(graphs) {\n\n            graphs.forEach(function (g) {\n                calculate_single_bb(g)\n            });\n\n            function calculate_single_bb(graph) {\n                var min_x = Number.MAX_VALUE, min_y = Number.MAX_VALUE,\n                    max_x = 0, max_y = 0;\n\n                graph.array.forEach(function (v) {\n                    var w = typeof v.width !== 'undefined' ? v.width : node_size;\n                    var h = typeof v.height !== 'undefined' ? v.height : node_size;\n                    w /= 2;\n                    h /= 2;\n                    max_x = Math.max(v.x + w, max_x);\n                    min_x = Math.min(v.x - w, min_x);\n                    max_y = Math.max(v.y + h, max_y);\n                    min_y = Math.min(v.y - h, min_y);\n                });\n\n                graph.width = max_x - min_x;\n                graph.height = max_y - min_y;\n            }\n        }\n\n        //function plot(data, left, right, opt_x, opt_y) {\n        //    // plot the cost function\n        //    var plot_svg = d3.select(\"body\").append(\"svg\")\n        //        .attr(\"width\", function () { return 2 * (right - left); })\n        //        .attr(\"height\", 200);\n\n\n        //    var x = d3.time.scale().range([0, 2 * (right - left)]);\n\n        //    var xAxis = d3.svg.axis().scale(x).orient(\"bottom\");\n        //    plot_svg.append(\"g\").attr(\"class\", \"x axis\")\n        //        .attr(\"transform\", \"translate(0, 199)\")\n        //        .call(xAxis);\n\n        //    var lastX = 0;\n        //    var lastY = 0;\n        //    var value = 0;\n        //    for (var r = left; r < right; r += 1) {\n        //        value = step(data, r);\n        //        // value = 1;\n\n        //        plot_svg.append(\"line\").attr(\"x1\", 2 * (lastX - left))\n        //            .attr(\"y1\", 200 - 30 * lastY)\n        //            .attr(\"x2\", 2 * r - 2 * left)\n        //            .attr(\"y2\", 200 - 30 * value)\n        //            .style(\"stroke\", \"rgb(6,120,155)\");\n\n        //        lastX = r;\n        //        lastY = value;\n        //    }\n\n        //    plot_svg.append(\"circle\").attr(\"cx\", 2 * opt_x - 2 * left).attr(\"cy\", 200 - 30 * opt_y)\n        //        .attr(\"r\", 5).style('fill', \"rgba(0,0,0,0.5)\");\n\n        //}\n\n        // actual assigning of position to nodes\n        function put_nodes_to_right_positions(graphs) {\n            graphs.forEach(function (g) {\n                // calculate current graph center:\n                var center = { x: 0, y: 0 };\n\n                g.array.forEach(function (node) {\n                    center.x += node.x;\n                    center.y += node.y;\n                });\n\n                center.x /= g.array.length;\n                center.y /= g.array.length;\n\n                // calculate current top left corner:\n                var corner = { x: center.x - g.width / 2, y: center.y - g.height / 2 };\n                var offset = { x: g.x - corner.x + svg_width / 2 - real_width / 2, y: g.y - corner.y + svg_height / 2 - real_height / 2};\n\n                // put nodes:\n                g.array.forEach(function (node) {\n                    node.x += offset.x;\n                    node.y += offset.y;\n                });\n            });\n        }\n\n        // starts box packing algorithm\n        // desired ratio is 1 by default\n        function apply(data, desired_ratio) {\n            var curr_best_f = Number.POSITIVE_INFINITY;\n            var curr_best = 0;\n            data.sort(function (a, b) { return b.height - a.height; });\n\n            min_width = data.reduce(function (a, b) {\n                return a.width < b.width ? a.width : b.width;\n            });\n\n            var left = x1 = min_width;\n            var right = x2 = get_entire_width(data);\n            var iterationCounter = 0;\n\n            var f_x1 = Number.MAX_VALUE;\n            var f_x2 = Number.MAX_VALUE;\n            var flag = -1; // determines which among f_x1 and f_x2 to recompute\n\n\n            var dx = Number.MAX_VALUE;\n            var df = Number.MAX_VALUE;\n\n            while ((dx > min_width) || df > packingOptions.FLOAT_EPSILON) {\n\n                if (flag != 1) {\n                    var x1 = right - (right - left) / packingOptions.GOLDEN_SECTION;\n                    var f_x1 = step(data, x1);\n                }\n                if (flag != 0) {\n                    var x2 = left + (right - left) / packingOptions.GOLDEN_SECTION;\n                    var f_x2 = step(data, x2);\n                }\n\n                dx = Math.abs(x1 - x2);\n                df = Math.abs(f_x1 - f_x2);\n\n                if (f_x1 < curr_best_f) {\n                    curr_best_f = f_x1;\n                    curr_best = x1;\n                }\n\n                if (f_x2 < curr_best_f) {\n                    curr_best_f = f_x2;\n                    curr_best = x2;\n                }\n\n                if (f_x1 > f_x2) {\n                    left = x1;\n                    x1 = x2;\n                    f_x1 = f_x2;\n                    flag = 1;\n                } else {\n                    right = x2;\n                    x2 = x1;\n                    f_x2 = f_x1;\n                    flag = 0;\n                }\n\n                if (iterationCounter++ > 100) {\n                    break;\n                }\n            }\n            // plot(data, min_width, get_entire_width(data), curr_best, curr_best_f);\n            step(data, curr_best);\n        }\n\n        // one iteration of the optimization method\n        // (gives a proper, but not necessarily optimal packing)\n        function step(data, max_width) {\n            line = [];\n            real_width = 0;\n            real_height = 0;\n            global_bottom = init_y;\n\n            for (var i = 0; i < data.length; i++) {\n                var o = data[i];\n                put_rect(o, max_width);\n            }\n\n            return Math.abs(get_real_ratio() - desired_ratio);\n        }\n\n        // looking for a position to one box\n        function put_rect(rect, max_width) {\n\n\n            var parent = undefined;\n\n            for (var i = 0; i < line.length; i++) {\n                if ((line[i].space_left >= rect.height) && (line[i].x + line[i].width + rect.width + packingOptions.PADDING - max_width) <= packingOptions.FLOAT_EPSILON) {\n                    parent = line[i];\n                    break;\n                }\n            }\n\n            line.push(rect);\n\n            if (parent !== undefined) {\n                rect.x = parent.x + parent.width + packingOptions.PADDING;\n                rect.y = parent.bottom;\n                rect.space_left = rect.height;\n                rect.bottom = rect.y;\n                parent.space_left -= rect.height + packingOptions.PADDING;\n                parent.bottom += rect.height + packingOptions.PADDING;\n            } else {\n                rect.y = global_bottom;\n                global_bottom += rect.height + packingOptions.PADDING;\n                rect.x = init_x;\n                rect.bottom = rect.y;\n                rect.space_left = rect.height;\n            }\n\n            if (rect.y + rect.height - real_height > -packingOptions.FLOAT_EPSILON) real_height = rect.y + rect.height - init_y;\n            if (rect.x + rect.width - real_width > -packingOptions.FLOAT_EPSILON) real_width = rect.x + rect.width - init_x;\n        };\n\n        function get_entire_width(data) {\n            var width = 0;\n            data.forEach(function (d) { return width += d.width + packingOptions.PADDING; });\n            return width;\n        }\n\n        function get_real_ratio() {\n            return (real_width / real_height);\n        }\n    }\n\n    /**\n     * connected components of graph\n     * returns an array of {}\n     */\n    export function separateGraphs(nodes, links) {\n        var marks = {};\n        var ways = {};\n        var graphs = [];\n        var clusters = 0;\n\n        for (var i = 0; i < links.length; i++) {\n            var link = links[i];\n            var n1 = link.source;\n            var n2 = link.target;\n            if (ways[n1.index])\n                ways[n1.index].push(n2);\n            else\n                ways[n1.index] = [n2];\n\n            if (ways[n2.index])\n                ways[n2.index].push(n1);\n            else\n                ways[n2.index] = [n1];\n        }\n\n        for (var i = 0; i < nodes.length; i++) {\n            var node = nodes[i];\n            if (marks[node.index]) continue;\n            explore_node(node, true);\n        }\n\n        function explore_node(n, is_new) {\n            if (marks[n.index] !== undefined) return;\n            if (is_new) {\n                clusters++;\n                graphs.push({ array: [] });\n            }\n            marks[n.index] = clusters;\n            graphs[clusters - 1].array.push(n);\n            var adjacent = ways[n.index];\n            if (!adjacent) return;\n\n            for (var j = 0; j < adjacent.length; j++) {\n                explore_node(adjacent[j], false);\n            }\n        }\n\n        return graphs;\n    }\n","let wasm; export async function setWasm(wasmModule) { const inst = await WebAssembly.instantiate(wasmModule, { \"./derivative_computer_bg.js\": { __wbindgen_memory } }); wasm = inst.exports; } export function getWasm() { return wasm; }\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nlet cachegetFloat32Memory0 = null;\nfunction getFloat32Memory0() {\n    if (cachegetFloat32Memory0 === null || cachegetFloat32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetFloat32Memory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachegetFloat32Memory0;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArrayF32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4);\n    getFloat32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n* @param {number} node_count\n* @param {Float32Array} D\n* @param {Float32Array} G\n* @returns {number}\n*/\nexport function create_derivative_computer_ctx_2d(node_count, D, G) {\n    var ptr0 = passArrayF32ToWasm0(D, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ptr1 = passArrayF32ToWasm0(G, wasm.__wbindgen_malloc);\n    var len1 = WASM_VECTOR_LEN;\n    var ret = wasm.create_derivative_computer_ctx_2d(node_count, ptr0, len0, ptr1, len1);\n    return [ret, ptr0, ptr1];\n}\n\n/**\n* @param {number} node_count\n* @param {Float32Array} D\n* @param {Float32Array} G\n* @returns {number}\n*/\nexport function create_derivative_computer_ctx_3d(node_count, D, G) {\n    var ptr0 = passArrayF32ToWasm0(D, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ptr1 = passArrayF32ToWasm0(G, wasm.__wbindgen_malloc);\n    var len1 = WASM_VECTOR_LEN;\n    var ret = wasm.create_derivative_computer_ctx_3d(node_count, ptr0, len0, ptr1, len1);\n    return [ret, ptr0, ptr1];\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nfunction getArrayF32FromWasm0(ptr, len) {\n    return getFloat32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n/**\n* @param {number} ctx_ptr\n* @param {Float32Array} x\n* @returns {Float32Array}\n*/\nexport function compute_2d(ctx_ptr, x) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        var ptr0 = passArrayF32ToWasm0(x, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.compute_2d(retptr, ctx_ptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v1 = getArrayF32FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 4);\n        return v1;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {number} ctx_ptr\n* @param {Float32Array} x\n* @returns {Float32Array}\n*/\nexport function compute_3d(ctx_ptr, x) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        var ptr0 = passArrayF32ToWasm0(x, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.compute_3d(retptr, ctx_ptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v1 = getArrayF32FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 4);\n        return v1;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {number} ctx_ptr\n* @param {number} u\n* @param {number} p_0\n* @param {number} p_1\n* @param {number} x_0_u\n* @param {number} x_1_u\n*/\nexport function apply_lock_2d(ctx_ptr, u, p_0, p_1, x_0_u, x_1_u) {\n    wasm.apply_lock_2d(ctx_ptr, u, p_0, p_1, x_0_u, x_1_u);\n}\n\n/**\n* @param {number} ctx_ptr\n* @param {number} u\n* @param {number} p_0\n* @param {number} p_1\n* @param {number} p_2\n* @param {number} x_0_u\n* @param {number} x_1_u\n* @param {number} x_2_u\n*/\nexport function apply_lock_3d(ctx_ptr, u, p_0, p_1, p_2, x_0_u, x_1_u, x_2_u) {\n    wasm.apply_lock_3d(ctx_ptr, u, p_0, p_1, p_2, x_0_u, x_1_u, x_2_u);\n}\n\n/**\n* @param {number} ctx_ptr\n* @returns {number}\n*/\nexport function compute_step_size_2d(ctx_ptr) {\n    var ret = wasm.compute_step_size_2d(ctx_ptr);\n    return ret;\n}\n\n/**\n* @param {number} ctx_ptr\n* @returns {number}\n*/\nexport function compute_step_size_3d(ctx_ptr) {\n    var ret = wasm.compute_step_size_3d(ctx_ptr);\n    return ret;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n/**\n* @returns {any}\n*/\nexport function get_memory() {\n    var ret = wasm.get_memory();\n    return takeObject(ret);\n}\n\n/**\n* @param {number} ctx\n* @returns {number}\n*/\nexport function get_D_2d(ctx) {\n    var ret = wasm.get_D_2d(ctx);\n    return ret;\n}\n\n/**\n* @param {number} ctx\n* @returns {number}\n*/\nexport function get_D_3d(ctx) {\n    var ret = wasm.get_D_3d(ctx);\n    return ret;\n}\n\n/**\n* @param {number} ctx\n* @returns {number}\n*/\nexport function get_g_2d(ctx) {\n    var ret = wasm.get_g_2d(ctx);\n    return ret;\n}\n\n/**\n* @param {number} ctx\n* @returns {number}\n*/\nexport function get_g_3d(ctx) {\n    var ret = wasm.get_D_2d(ctx);\n    return ret;\n}\n\n/**\n* @param {number} ctx\n* @param {Float32Array} new_G\n*/\nexport function set_G_2d(ctx, new_G) {\n    var ptr0 = passArrayF32ToWasm0(new_G, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    wasm.set_G_2d(ctx, ptr0, len0);\n    return ptr0;\n}\n\n/**\n* @param {number} ctx\n* @param {Float32Array} new_G\n*/\nexport function set_G_3d(ctx, new_G) {\n    var ptr0 = passArrayF32ToWasm0(new_G, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    wasm.set_G_3d(ctx, ptr0, len0);\n    return ptr0;\n}\n\nexport const __wbindgen_memory = function() {\n    var ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\n","let wasm; export async function setWasm(wasmModule) { const inst = await WebAssembly.instantiate(wasmModule, { \"./derivative_computer_bg.js\": { __wbindgen_memory } }); wasm = inst.exports; } export function getWasm() { return wasm; }\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nlet cachegetFloat32Memory0 = null;\nfunction getFloat32Memory0() {\n    if (cachegetFloat32Memory0 === null || cachegetFloat32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetFloat32Memory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachegetFloat32Memory0;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArrayF32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4);\n    getFloat32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n* @param {number} node_count\n* @param {Float32Array} D\n* @param {Float32Array} G\n* @returns {number}\n*/\nexport function create_derivative_computer_ctx_2d(node_count, D, G) {\n    var ptr0 = passArrayF32ToWasm0(D, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ptr1 = passArrayF32ToWasm0(G, wasm.__wbindgen_malloc);\n    var len1 = WASM_VECTOR_LEN;\n    var ret = wasm.create_derivative_computer_ctx_2d(node_count, ptr0, len0, ptr1, len1);\n    return [ret, ptr0, ptr1];\n}\n\n/**\n* @param {number} node_count\n* @param {Float32Array} D\n* @param {Float32Array} G\n* @returns {number}\n*/\nexport function create_derivative_computer_ctx_3d(node_count, D, G) {\n    var ptr0 = passArrayF32ToWasm0(D, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ptr1 = passArrayF32ToWasm0(G, wasm.__wbindgen_malloc);\n    var len1 = WASM_VECTOR_LEN;\n    var ret = wasm.create_derivative_computer_ctx_3d(node_count, ptr0, len0, ptr1, len1);\n    return [ret, ptr0, ptr1];\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nfunction getArrayF32FromWasm0(ptr, len) {\n    return getFloat32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n/**\n* @param {number} ctx_ptr\n* @param {Float32Array} x\n* @returns {Float32Array}\n*/\nexport function compute_2d(ctx_ptr, x) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        var ptr0 = passArrayF32ToWasm0(x, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.compute_2d(retptr, ctx_ptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v1 = getArrayF32FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 4);\n        return v1;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {number} ctx_ptr\n* @param {Float32Array} x\n* @returns {Float32Array}\n*/\nexport function compute_3d(ctx_ptr, x) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        var ptr0 = passArrayF32ToWasm0(x, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.compute_3d(retptr, ctx_ptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v1 = getArrayF32FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 4);\n        return v1;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {number} ctx_ptr\n* @param {number} u\n* @param {number} p_0\n* @param {number} p_1\n* @param {number} x_0_u\n* @param {number} x_1_u\n*/\nexport function apply_lock_2d(ctx_ptr, u, p_0, p_1, x_0_u, x_1_u) {\n    wasm.apply_lock_2d(ctx_ptr, u, p_0, p_1, x_0_u, x_1_u);\n}\n\n/**\n* @param {number} ctx_ptr\n* @param {number} u\n* @param {number} p_0\n* @param {number} p_1\n* @param {number} p_2\n* @param {number} x_0_u\n* @param {number} x_1_u\n* @param {number} x_2_u\n*/\nexport function apply_lock_3d(ctx_ptr, u, p_0, p_1, p_2, x_0_u, x_1_u, x_2_u) {\n    wasm.apply_lock_3d(ctx_ptr, u, p_0, p_1, p_2, x_0_u, x_1_u, x_2_u);\n}\n\n/**\n* @param {number} ctx_ptr\n* @returns {number}\n*/\nexport function compute_step_size_2d(ctx_ptr) {\n    var ret = wasm.compute_step_size_2d(ctx_ptr);\n    return ret;\n}\n\n/**\n* @param {number} ctx_ptr\n* @returns {number}\n*/\nexport function compute_step_size_3d(ctx_ptr) {\n    var ret = wasm.compute_step_size_3d(ctx_ptr);\n    return ret;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n/**\n* @returns {any}\n*/\nexport function get_memory() {\n    var ret = wasm.get_memory();\n    return takeObject(ret);\n}\n\n/**\n* @param {number} ctx\n* @returns {number}\n*/\nexport function get_D_2d(ctx) {\n    var ret = wasm.get_D_2d(ctx);\n    return ret;\n}\n\n/**\n* @param {number} ctx\n* @returns {number}\n*/\nexport function get_D_3d(ctx) {\n    var ret = wasm.get_D_3d(ctx);\n    return ret;\n}\n\n/**\n* @param {number} ctx\n* @returns {number}\n*/\nexport function get_g_2d(ctx) {\n    var ret = wasm.get_g_2d(ctx);\n    return ret;\n}\n\n/**\n* @param {number} ctx\n* @returns {number}\n*/\nexport function get_g_3d(ctx) {\n    var ret = wasm.get_D_2d(ctx);\n    return ret;\n}\n\n/**\n* @param {number} ctx\n* @param {Float32Array} new_G\n*/\nexport function set_G_2d(ctx, new_G) {\n    var ptr0 = passArrayF32ToWasm0(new_G, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    wasm.set_G_2d(ctx, ptr0, len0);\n    return ptr0;\n}\n\n/**\n* @param {number} ctx\n* @param {Float32Array} new_G\n*/\nexport function set_G_3d(ctx, new_G) {\n    var ptr0 = passArrayF32ToWasm0(new_G, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    wasm.set_G_3d(ctx, ptr0, len0);\n    return ptr0;\n}\n\nexport const __wbindgen_memory = function() {\n    var ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\n","import * as powergraph from './powergraph'\nimport {LinkLengthAccessor, symmetricDiffLinkLengths, jaccardLinkLengths, generateDirectedEdgeConstraints} from './linklengths'\nimport {Descent} from './descent'\nimport {Rectangle, Projection, makeEdgeTo, makeEdgeBetween} from './rectangle'\nimport {Calculator} from './shortestpaths'\nimport {TangentVisibilityGraph, TVGPoint} from './geom'\nimport {separateGraphs, applyPacking} from './handledisconnected'\nimport { getDerivativeComputerWasm } from './wasmEngine'\n\n// Kick this off right away since we're going to need it eventually\nconst wasmInstPromise = getDerivativeComputerWasm();\n\n    /**\n     * The layout process fires three events:\n     *  - start: layout iterations started\n     *  - tick: fired once per iteration, listen to this to animate\n     *  - end: layout converged, you might like to zoom-to-fit or something at notification of this event\n     */\n    export enum EventType { start, tick, end };\n    export interface Event {\n        type: EventType;\n        alpha: number;\n        stress?: number;\n        listener?: () => void;\n    }\n    export interface InputNode {\n        /**\n         * index in nodes array, this is initialized by Layout.start()\n         */\n        index?: number;\n        /**\n         * x and y will be computed by layout as the Node's centroid\n         */\n        x?: number;\n        /**\n         * x and y will be computed by layout as the Node's centroid\n         */\n        y?: number;\n        /**\n         * specify a width and height of the node's bounding box if you turn on avoidOverlaps\n         */\n        width?: number;\n        /**\n         * specify a width and height of the node's bounding box if you turn on avoidOverlaps\n         */\n        height?: number;\n        /**\n         * selective bit mask.  !=0 means layout will not move.\n         */\n        fixed?: number;\n    }\n    export interface Node extends InputNode {\n      // Client-passed node may be missing these properties, which will be set\n      // upon ingestion\n      x: number;\n      y: number;\n    }\n\n    export interface Group {\n        bounds?: Rectangle;\n        leaves?: Node[];\n        groups?: Group[];\n        padding?: number;\n    }\n\n    function isGroup(g: any): g is Group {\n        return typeof g.leaves !== 'undefined' || typeof g.groups !== 'undefined';\n    }\n\n    export interface Link<NodeRefType> {\n        source: NodeRefType;\n        target: NodeRefType;\n\n        // ideal length the layout should try to achieve for this link\n        length?: number;\n\n        // how hard we should try to satisfy this link's ideal length\n        // must be in the range: 0 < weight <= 1\n        // if unspecified 1 is the default\n        weight?: number;\n    }\n\n    export type LinkNumericPropertyAccessor = (t: Link<Node | number>) => number;\n\n    export interface LinkLengthTypeAccessor extends LinkLengthAccessor<Link<Node | number>> {\n        getType: LinkNumericPropertyAccessor;\n    }\n    /**\n     * Main interface to cola layout.\n     * @class Layout\n     */\n    export class Layout {\n        private _canvasSize = [1, 1];\n        private _linkDistance: number | LinkNumericPropertyAccessor = 20;\n        private _defaultNodeSize: number = 10;\n        private _linkLengthCalculator = null;\n        private _linkType = null;\n        private _avoidOverlaps = false;\n        private _handleDisconnected = true;\n        private _alpha;\n        private _lastStress;\n        private _running = false;\n        private _nodes = [];\n        private _groups = [];\n        private _rootGroup = null;\n        private _links: Link<Node | number>[] = [];\n        private _constraints = [];\n        private _distanceMatrix = null;\n        private _descent: Descent = null;\n        private _directedLinkConstraints = null;\n        private _threshold = 0.01;\n        private _visibilityGraph = null;\n        private _groupCompactness = 1e-6;\n\n        // sub-class and override this property to replace with a more sophisticated eventing mechanism\n        protected event = null;\n\n        // subscribe a listener to an event\n        // sub-class and override this method to replace with a more sophisticated eventing mechanism\n        public on(e: EventType | string, listener: (event?: Event) => void): this {\n            // override me!\n            if (!this.event) this.event = {};\n            if (typeof e === 'string') {\n                this.event[EventType[e]] = listener;\n            } else {\n                this.event[e] = listener;\n            }\n            return this;\n        }\n\n        // a function that is notified of events like \"tick\"\n        // sub-classes can override this method to replace with a more sophisticated eventing mechanism\n        protected trigger(e: Event) {\n            if (this.event && typeof this.event[e.type] !== 'undefined') {\n                this.event[e.type](e);\n            }\n        }\n\n        // a function that kicks off the iteration tick loop\n        // it calls tick() repeatedly until tick returns true (is converged)\n        // subclass and override it with something fancier (e.g. dispatch tick on a timer)\n        protected kick(): void {\n            while (!this.tick());\n        }\n\n        /**\n         * iterate the layout.  Returns true when layout converged.\n         */\n        protected tick(): boolean {\n            if (this._alpha < this._threshold) {\n                this._running = false;\n                this.trigger({ type: EventType.end, alpha: this._alpha = 0, stress: this._lastStress });\n                return true;\n            }\n            const n = this._nodes.length,\n                  m = this._links.length;\n            let o, i;\n\n            this._descent.locks.clear();\n            for (i = 0; i < n; ++i) {\n                o = this._nodes[i];\n                if (o.fixed) {\n                    if (typeof o.px === 'undefined' || typeof o.py === 'undefined') {\n                        o.px = o.x;\n                        o.py = o.y;\n                    }\n                    var p = [o.px, o.py];\n                    this._descent.locks.add(i, p);\n                }\n            }\n\n            let s1 = this._descent.rungeKutta();\n            //var s1 = descent.reduceStress();\n            if (s1 === 0) {\n                this._alpha = 0;\n            } else if (typeof this._lastStress !== 'undefined') {\n                this._alpha = s1; //Math.abs(Math.abs(this._lastStress / s1) - 1);\n            }\n            this._lastStress = s1;\n\n            this.updateNodePositions();\n\n            this.trigger({ type: EventType.tick, alpha: this._alpha, stress: this._lastStress });\n            return false;\n        }\n\n        // copy positions out of descent instance into each of the nodes' center coords\n        private updateNodePositions(): void {\n            const x = this._descent.x[0], y = this._descent.x[1];\n            let o, i = this._nodes.length;\n            while (i--) {\n                o = this._nodes[i];\n                o.x = x[i];\n                o.y = y[i];\n            }\n        }\n\n        /**\n         * the list of nodes.\n         * If nodes has not been set, but links has, then we instantiate a nodes list here, of the correct size,\n         * before returning it.\n         * @property nodes {Array}\n         * @default empty list\n         */\n        nodes(): Array<Node>\n        nodes(v: Array<InputNode>): this\n        nodes(v?: any): any {\n            if (!v) {\n                if (this._nodes.length === 0 && this._links.length > 0) {\n                    // if we have links but no nodes, create the nodes array now with empty objects for the links to point at.\n                    // in this case the links are expected to be numeric indices for nodes in the range 0..n-1 where n is the number of nodes\n                    var n = 0;\n                    this._links.forEach(function (l) {\n                        n = Math.max(n, <number>l.source, <number>l.target);\n                    });\n                    this._nodes = new Array(++n);\n                    for (var i = 0; i < n; ++i) {\n                        this._nodes[i] = {};\n                    }\n                }\n                return this._nodes;\n            }\n            this._nodes = v;\n            return this;\n        }\n\n        /**\n         * a list of hierarchical groups defined over nodes\n         * @property groups {Array}\n         * @default empty list\n         */\n        groups(): Array<Group>\n        groups(x: Array<Group>): this\n        groups(x?: Array<Group>): any {\n            if (!x) return this._groups;\n            this._groups = x;\n            this._rootGroup = {};\n            this._groups.forEach(g => {\n                if (typeof g.padding === \"undefined\")\n                    g.padding = 1;\n                if (typeof g.leaves !== \"undefined\") {\n                    g.leaves.forEach((v, i) => {\n                        if (typeof v === 'number')\n                            (g.leaves[i] = this._nodes[v]).parent = g\n                    });\n                }\n                if (typeof g.groups !== \"undefined\") {\n                    g.groups.forEach((gi, i) => {\n                        if (typeof gi === 'number')\n                            (g.groups[i] = this._groups[gi]).parent = g\n                    });\n                }\n            });\n            this._rootGroup.leaves = this._nodes.filter(v => typeof v.parent === 'undefined');\n            this._rootGroup.groups = this._groups.filter(g => typeof g.parent === 'undefined');\n            return this;\n        }\n\n        powerGraphGroups(f: Function): this {\n            var g = powergraph.getGroups(this._nodes, this._links, this.linkAccessor, this._rootGroup);\n            this.groups(g.groups);\n            f(g);\n            return this;\n        }\n\n        /**\n         * if true, the layout will not permit overlaps of the node bounding boxes (defined by the width and height properties on nodes)\n         * @property avoidOverlaps\n         * @type bool\n         * @default false\n         */\n        avoidOverlaps(): boolean\n        avoidOverlaps(v: boolean): this\n        avoidOverlaps(v?: boolean): any {\n            if (!arguments.length) return this._avoidOverlaps;\n            this._avoidOverlaps = v;\n            return this;\n        }\n\n        /**\n         * if true, the final step of the start method will be to nicely pack connected components of the graph.\n         * works best if start() is called with a reasonable number of iterations specified and\n         * each node has a bounding box (defined by the width and height properties on nodes).\n         * @property handleDisconnected\n         * @type bool\n         * @default true\n         */\n        handleDisconnected(): boolean\n        handleDisconnected(v: boolean): this\n        handleDisconnected(v?: boolean): any {\n            if (!arguments.length) return this._handleDisconnected;\n            this._handleDisconnected = v;\n            return this;\n        }\n\n        /**\n         * causes constraints to be generated such that directed graphs are laid out either from left-to-right or top-to-bottom.\n         * a separation constraint is generated in the selected axis for each edge that is not involved in a cycle (part of a strongly connected component)\n         * @param axis {string} 'x' for left-to-right, 'y' for top-to-bottom\n         * @param minSeparation {number|link=>number} either a number specifying a minimum spacing required across all links or a function to return the minimum spacing for each link\n         */\n        flowLayout(axis: string, minSeparation: number|((t: any)=>number)): this {\n            if (!arguments.length) axis = 'y';\n            this._directedLinkConstraints = {\n                axis: axis,\n                getMinSeparation: typeof minSeparation === 'number' ? function () { return minSeparation } : minSeparation\n            };\n            return this;\n        }\n\n        /**\n         * links defined as source, target pairs over nodes\n         * @property links {array}\n         * @default empty list\n         */\n        links(): Array<Link<Node|number>>\n        links(x: Array<Link<Node|number>>): this\n        links(x?: Array<Link<Node|number>>): any {\n            if (!arguments.length) return this._links;\n            this._links = x;\n            return this;\n        }\n\n        /**\n         * list of constraints of various types\n         * @property constraints\n         * @type {array}\n         * @default empty list\n         */\n        constraints(): Array<any>\n        constraints(c: Array<any>): this\n        constraints(c?: Array<any>): any {\n            if (!arguments.length) return this._constraints;\n            this._constraints = c;\n            return this;\n        }\n\n        /**\n         * Matrix of ideal distances between all pairs of nodes.\n         * If unspecified, the ideal distances for pairs of nodes will be based on the shortest path distance between them.\n         * @property distanceMatrix\n         * @type {Array of Array of Number}\n         * @default null\n         */\n        distanceMatrix(): Array<Array<number>>\n        distanceMatrix(d: Array<Array<number>>): this\n        distanceMatrix(d?: any): any {\n            if (!arguments.length) return this._distanceMatrix;\n            this._distanceMatrix = d;\n            return this;\n        }\n\n        /**\n         * Size of the layout canvas dimensions [x,y]. Currently only used to determine the midpoint which is taken as the starting position\n         * for nodes with no preassigned x and y.\n         * @property size\n         * @type {Array of Number}\n         */\n        size(): Array<number>\n        size(x: Array<number>): this\n        size(x?: Array<number>): any {\n            if (!x) return this._canvasSize;\n            this._canvasSize = x;\n            return this;\n        }\n\n        /**\n         * Default size (assume nodes are square so both width and height) to use in packing if node width/height are not specified.\n         * @property defaultNodeSize\n         * @type {Number}\n         */\n        defaultNodeSize(): number\n        defaultNodeSize(x: number): this\n        defaultNodeSize(x?: any): any {\n            if (!x) return this._defaultNodeSize;\n            this._defaultNodeSize = x;\n            return this;\n        }\n\n        /**\n         * The strength of attraction between the group boundaries to each other.\n         * @property defaultNodeSize\n         * @type {Number}\n         */\n        groupCompactness(): number\n        groupCompactness(x: number): this\n        groupCompactness(x?: any): any {\n            if (!x) return this._groupCompactness;\n            this._groupCompactness = x;\n            return this;\n        }\n\n        /**\n         * links have an ideal distance, The automatic layout will compute layout that tries to keep links (AKA edges) as close as possible to this length.\n         */\n        linkDistance(): number\n        linkDistance(): LinkNumericPropertyAccessor\n        linkDistance(x: number): this\n        linkDistance(x: LinkNumericPropertyAccessor): this\n        linkDistance(x?: any): any {\n            if (!x) {\n                return this._linkDistance;\n            }\n            this._linkDistance = typeof x === \"function\" ? x : +x;\n            this._linkLengthCalculator = null;\n            return this;\n        }\n\n        linkType(f: Function | number): this {\n            this._linkType = f;\n            return this;\n        }\n\n        convergenceThreshold(): number\n        convergenceThreshold(x: number): this\n        convergenceThreshold(x?: number): any {\n            if (!x) return this._threshold;\n            this._threshold = typeof x === \"function\" ? x : +x;\n            return this;\n        }\n\n        alpha(): number\n        alpha(x: number): this\n        alpha(x?: number): any {\n            if (!arguments.length) return this._alpha;\n            else {\n                x = +x;\n                if (this._alpha) { // if we're already running\n                    if (x > 0) this._alpha = x; // we might keep it hot\n                    else this._alpha = 0; // or, next tick will dispatch \"end\"\n                } else if (x > 0) { // otherwise, fire it up!\n                    if (!this._running) {\n                        this._running = true;\n                        this.trigger({ type: EventType.start, alpha: this._alpha = x});\n                        this.kick();\n                    }\n                }\n                return this;\n            }\n        }\n\n        getLinkLength(link: Link<Node | number>): number {\n            return typeof this._linkDistance === \"function\" ? +((<LinkNumericPropertyAccessor>this._linkDistance)(link)) : <number>this._linkDistance;\n        }\n\n        static setLinkLength(link: Link<Node|number>, length: number) {\n            link.length = length;\n        }\n\n        getLinkType(link: Link<Node | number>): number {\n            return typeof this._linkType === \"function\" ? this._linkType(link) : 0;\n        }\n\n        linkAccessor: LinkLengthTypeAccessor = {\n            getSourceIndex: Layout.getSourceIndex,\n            getTargetIndex: Layout.getTargetIndex,\n            setLength: Layout.setLinkLength,\n            getType: l => typeof this._linkType === \"function\" ? this._linkType(l) : 0\n        };\n\n        /**\n         * compute an ideal length for each link based on the graph structure around that link.\n         * you can use this (for example) to create extra space around hub-nodes in dense graphs.\n         * In particular this calculation is based on the \"symmetric difference\" in the neighbour sets of the source and target:\n         * i.e. if neighbours of source is a and neighbours of target are b then calculation is: sqrt(|a union b| - |a intersection b|)\n         * Actual computation based on inspection of link structure occurs in start(), so links themselves\n         * don't have to have been assigned before invoking this function.\n         * @param {number} [idealLength] the base length for an edge when its source and start have no other common neighbours (e.g. 40)\n         * @param {number} [w] a multiplier for the effect of the length adjustment (e.g. 0.7)\n         */\n        symmetricDiffLinkLengths(idealLength: number, w: number = 1): this {\n            this.linkDistance(l => idealLength * l.length);\n            this._linkLengthCalculator = () => symmetricDiffLinkLengths(this._links, this.linkAccessor, w);\n            return this;\n        }\n\n        /**\n         * compute an ideal length for each link based on the graph structure around that link.\n         * you can use this (for example) to create extra space around hub-nodes in dense graphs.\n         * In particular this calculation is based on the \"symmetric difference\" in the neighbour sets of the source and target:\n         * i.e. if neighbours of source is a and neighbours of target are b then calculation is: |a intersection b|/|a union b|\n         * Actual computation based on inspection of link structure occurs in start(), so links themselves\n         * don't have to have been assigned before invoking this function.\n         * @param {number} [idealLength] the base length for an edge when its source and start have no other common neighbours (e.g. 40)\n         * @param {number} [w] a multiplier for the effect of the length adjustment (e.g. 0.7)\n         */\n        jaccardLinkLengths(idealLength: number, w: number = 1): this {\n            this.linkDistance(l => idealLength * l.length);\n            this._linkLengthCalculator = () => jaccardLinkLengths(this._links, this.linkAccessor, w);\n            return this;\n        }\n\n        /**\n         * start the layout process\n         * @method start\n         * @param {number} [initialUnconstrainedIterations=0] unconstrained initial layout iterations\n         * @param {number} [initialUserConstraintIterations=0] initial layout iterations with user-specified constraints\n         * @param {number} [initialAllConstraintsIterations=0] initial layout iterations with all constraints including non-overlap\n         * @param {number} [gridSnapIterations=0] iterations of \"grid snap\", which pulls nodes towards grid cell centers - grid of size node[0].width - only really makes sense if all nodes have the same width and height\n         * @param [keepRunning=true] keep iterating shronously via the tick method\n         * @param [centerGraph=true] Center graph on restart\n         */\n        async start(\n            initialUnconstrainedIterations: number = 0,\n            initialUserConstraintIterations: number = 0,\n            initialAllConstraintsIterations: number = 0,\n            gridSnapIterations: number = 0,\n            keepRunning = true,\n            centerGraph = true,\n        ): Promise<this> {\n            var i: number,\n                j: number,\n                n = (<Array<any>>this.nodes()).length,\n                N = n + 2 * this._groups.length,\n                m = this._links.length,\n                w = this._canvasSize[0],\n                h = this._canvasSize[1];\n\n            var x = new Array(N), y = new Array(N);\n\n            var G = null;\n\n            var ao = this._avoidOverlaps;\n\n            this._nodes.forEach((v, i) => {\n                v.index = i;\n                if (typeof v.x === 'undefined') {\n                    v.x = w / 2, v.y = h / 2;\n                }\n                x[i] = v.x, y[i] = v.y;\n            });\n\n            if (this._linkLengthCalculator) this._linkLengthCalculator();\n\n            //should we do this to clearly label groups?\n            //this._groups.forEach((g, i) => g.groupIndex = i);\n\n            var distances;\n            if (this._distanceMatrix) {\n                // use the user specified distanceMatrix\n                distances = this._distanceMatrix;\n            } else {\n                // construct an n X n distance matrix based on shortest paths through graph (with respect to edge.length).\n                distances = (new Calculator(N, this._links, Layout.getSourceIndex, Layout.getTargetIndex, l=> this.getLinkLength(l))).DistanceMatrix();\n\n                // G is a square matrix with G[i][j] = 1 iff there exists an edge between node i and node j\n                // otherwise 2. (\n                G = Descent.createSquareMatrix(N, () => 2);\n                this._links.forEach(l => {\n                    if (typeof l.source == \"number\") l.source = this._nodes[<number>l.source];\n                    if (typeof l.target == \"number\") l.target = this._nodes[<number>l.target];\n                });\n                this._links.forEach(e => {\n                    const u = Layout.getSourceIndex(e), v = Layout.getTargetIndex(e);\n                    G[u][v] = G[v][u] = e.weight || 1;\n                });\n            }\n\n            var D = Descent.createSquareMatrix(N, function (i, j) {\n                return distances[i][j];\n            });\n\n            if (this._rootGroup && typeof this._rootGroup.groups !== 'undefined') {\n                var i = n;\n                var addAttraction = (i, j, strength, idealDistance) => {\n                    G[i][j] = G[j][i] = strength;\n                    D[i][j] = D[j][i] = idealDistance;\n                };\n                this._groups.forEach(g => {\n                    addAttraction(i, i + 1, this._groupCompactness, 0.1);\n\n                    // todo: add terms here attracting children of the group to the group dummy nodes\n                    //if (typeof g.leaves !== 'undefined')\n                    //    g.leaves.forEach(l => {\n                    //        addAttraction(l.index, i, 1e-4, 0.1);\n                    //        addAttraction(l.index, i + 1, 1e-4, 0.1);\n                    //    });\n                    //if (typeof g.groups !== 'undefined')\n                    //    g.groups.forEach(g => {\n                    //        var gid = n + g.groupIndex * 2;\n                    //        addAttraction(gid, i, 0.1, 0.1);\n                    //        addAttraction(gid + 1, i, 0.1, 0.1);\n                    //        addAttraction(gid, i + 1, 0.1, 0.1);\n                    //        addAttraction(gid + 1, i + 1, 0.1, 0.1);\n                    //    });\n\n                    if (typeof g.bounds === 'undefined') {\n                        x[i] = w / 2, y[i++] = h / 2;\n                        x[i] = w / 2, y[i++] = h / 2;\n                    } else {\n                        x[i] = g.bounds.x, y[i++] = g.bounds.y;\n                        x[i] = g.bounds.X, y[i++] = g.bounds.Y;\n                    }\n                });\n            } else this._rootGroup = { leaves: this._nodes, groups: [] };\n\n            var curConstraints = this._constraints || [];\n            if (this._directedLinkConstraints) {\n                (<any>this.linkAccessor).getMinSeparation = this._directedLinkConstraints.getMinSeparation;\n                curConstraints = curConstraints.concat(generateDirectedEdgeConstraints(n, this._links, this._directedLinkConstraints.axis, <any>(this.linkAccessor)));\n\n                // todo: add containment constraints between group dummy nodes and their children\n            }\n\n            this.avoidOverlaps(false);\n            const wasmInst = await wasmInstPromise;\n            this._descent = new Descent([x, y], D, undefined, wasmInst);\n\n            this._descent.locks.clear();\n            for (var i = 0; i < n; ++i) {\n                var o = this._nodes[i];\n                if (o.fixed) {\n                    o.px = o.x;\n                    o.py = o.y;\n                    var p = [o.x, o.y];\n                    this._descent.locks.add(i, p);\n                }\n            }\n            this._descent.threshold = this._threshold;\n\n            // apply initialIterations without user constraints or nonoverlap constraints\n            // if groups are specified, dummy nodes and edges will be added to untangle\n            // with respect to group connectivity\n            this.initialLayout(initialUnconstrainedIterations, x, y);\n\n            // apply initialIterations with user constraints but no nonoverlap constraints\n            if (curConstraints.length > 0) this._descent.project = new Projection(this._nodes, this._groups, this._rootGroup, curConstraints).projectFunctions();\n            this._descent.run(initialUserConstraintIterations);\n            this.separateOverlappingComponents(w, h, centerGraph);\n\n            // subsequent iterations will apply all constraints\n            this.avoidOverlaps(ao);\n            if (ao) {\n                this._nodes.forEach(function (v, i) { v.x = x[i], v.y = y[i]; });\n                this._descent.project = new Projection(this._nodes, this._groups, this._rootGroup, curConstraints, true).projectFunctions();\n                this._nodes.forEach(function (v, i) { x[i] = v.x, y[i] = v.y; });\n            }\n\n            // allow not immediately connected nodes to relax apart (p-stress)\n            this._descent.G = G;\n            this._descent.run(initialAllConstraintsIterations);\n\n            // TODO\n            // if (gridSnapIterations) {\n            //     this._descent.snapStrength = 1000;\n            //     this._descent.snapGridSize = this._nodes[0].width;\n            //     this._descent.numGridSnapNodes = n;\n            //     this._descent.scaleSnapByMaxH = n != N; // if we have groups then need to scale hessian so grid forces still apply\n            //     var G0 = Descent.createSquareMatrix(N,(i, j) => {\n            //         if (i >= n || j >= n) return G[i][j];\n            //         return 0\n            //     });\n            //     this._descent.G = G0;\n            //     this._descent.run(gridSnapIterations);\n            // }\n\n            this.updateNodePositions();\n            this.separateOverlappingComponents(w, h, centerGraph);\n            return keepRunning ? this.resume() : this;\n        }\n\n        private initialLayout(iterations: number, x: number[], y: number[]) {\n            if (this._groups.length > 0 && iterations > 0) {\n                // construct a flat graph with dummy nodes for the groups and edges connecting group dummy nodes to their children\n                // todo: edges attached to groups are replaced with edges connected to the corresponding group dummy node\n                var n = this._nodes.length;\n                var edges = this._links.map(e => <any>{ source: (<Node>e.source).index, target: (<Node>e.target).index });\n                var vs = this._nodes.map(v => <any>{ index: v.index });\n                this._groups.forEach((g, i) => {\n                    vs.push(<any>{ index: g.index = n + i });\n                });\n                this._groups.forEach((g, i) => {\n                    if (typeof g.leaves !== 'undefined')\n                        g.leaves.forEach(v => edges.push({ source: g.index, target: v.index }));\n                    if (typeof g.groups !== 'undefined')\n                        g.groups.forEach(gg => edges.push({ source: g.index, target: gg.index }));\n                });\n\n                // layout the flat graph with dummy nodes and edges\n                new Layout()\n                    .size(this.size())\n                    .nodes(vs)\n                    .links(edges)\n                    .avoidOverlaps(false)\n                    .linkDistance(this.linkDistance())\n                    .symmetricDiffLinkLengths(5)\n                    .convergenceThreshold(1e-4)\n                    .start(iterations, 0, 0, 0, false);\n\n                this._nodes.forEach(v => {\n                    x[v.index] = vs[v.index].x;\n                    y[v.index] = vs[v.index].y;\n                });\n            } else {\n                this._descent.run(iterations);\n            }\n        }\n\n        // recalculate nodes position for disconnected graphs\n        private separateOverlappingComponents(width: number, height: number, centerGraph: boolean = true): void {\n            // recalculate nodes position for disconnected graphs\n            if (!this._distanceMatrix && this._handleDisconnected) {\n                let x = this._descent.x[0], y = this._descent.x[1];\n                this._nodes.forEach(function (v, i) { v.x = x[i], v.y = y[i]; });\n                var graphs = separateGraphs(this._nodes, this._links);\n                applyPacking(graphs, width, height, this._defaultNodeSize, 1, centerGraph);\n                this._nodes.forEach((v, i) => {\n                    this._descent.x[0][i] = v.x, this._descent.x[1][i] = v.y;\n                    if (v.bounds) {\n                        v.bounds.setXCentre(v.x);\n                        v.bounds.setYCentre(v.y);\n                    }\n                });\n            }\n        }\n\n        resume(): this {\n            return this.alpha(0.1);\n        }\n\n        pause(): this {\n            return this.alpha(0);\n        }\n\n        stop(): this {\n            if (this._descent) {\n                this._descent.cleanWasmMemory();\n            }\n            return this.alpha(0);\n        }\n\n        /// find a visibility graph over the set of nodes.  assumes all nodes have a\n        /// bounds property (a rectangle) and that no pair of bounds overlaps.\n        prepareEdgeRouting(nodeMargin: number = 0) {\n            this._visibilityGraph = new TangentVisibilityGraph(\n                this._nodes.map(function (v) {\n                    return v.bounds.inflate(-nodeMargin).vertices();\n                }));\n        }\n\n        /**\n         * find a route avoiding node bounds for the given edge.\n         * assumes the visibility graph has been created (by prepareEdgeRouting method)\n         * and also assumes that nodes have an index property giving their position in the\n         * node array.  This index property is created by the start() method.\n         * @param [edge] The edge to generate a route for.\n         * @param {number} [ah] The size of the arrow head, a distance to shorten the end\n         *                      of the edge by.  Defaults to 5.\n         */\n        routeEdge(edge, ah: number = 5, draw) {\n            var lineData = [];\n            //if (d.source.id === 10 && d.target.id === 11) {\n            //    debugger;\n            //}\n            var vg2 = new TangentVisibilityGraph(this._visibilityGraph.P, { V: this._visibilityGraph.V, E: this._visibilityGraph.E }),\n                port1 = <TVGPoint>{ x: edge.source.x, y: edge.source.y },\n                port2 = <TVGPoint>{ x: edge.target.x, y: edge.target.y },\n                start = vg2.addPoint(port1, edge.source.index),\n                end = vg2.addPoint(port2, edge.target.index);\n            vg2.addEdgeIfVisible(port1, port2, edge.source.index, edge.target.index);\n            if (typeof draw !== 'undefined') {\n                draw(vg2);\n            }\n            var sourceInd = e => e.source.id, targetInd = e => e.target.id, length = e => e.length(),\n                spCalc = new Calculator(vg2.V.length, vg2.E, sourceInd, targetInd, length),\n                shortestPath = spCalc.PathFromNodeToNode(start.id, end.id);\n            if (shortestPath.length === 1 || shortestPath.length === vg2.V.length) {\n                let route = makeEdgeBetween(edge.source.innerBounds, edge.target.innerBounds, ah);\n                lineData = [route.sourceIntersection, route.arrowStart];\n            } else {\n                var n = shortestPath.length - 2,\n                    p = vg2.V[shortestPath[n]].p,\n                    q = vg2.V[shortestPath[0]].p,\n                    lineData = [edge.source.innerBounds.rayIntersection(p.x, p.y)];\n                for (var i = n; i >= 0; --i)\n                    lineData.push(vg2.V[shortestPath[i]].p);\n                lineData.push(makeEdgeTo(q, edge.target.innerBounds, ah));\n            }\n            //lineData.forEach((v, i) => {\n            //    if (i > 0) {\n            //        var u = lineData[i - 1];\n            //        this._nodes.forEach(function (node) {\n            //            if (node.id === getSourceIndex(d) || node.id === getTargetIndex(d)) return;\n            //            var ints = node.innerBounds.lineIntersections(u.x, u.y, v.x, v.y);\n            //            if (ints.length > 0) {\n            //                debugger;\n            //            }\n            //        })\n            //    }\n            //})\n            return lineData;\n        }\n\n        //The link source and target may be just a node index, or they may be references to nodes themselves.\n        static getSourceIndex(e: Link<Node | number>): number {\n            return typeof e.source === 'number' ? <number>e.source : (<Node>e.source).index;\n        }\n\n        //The link source and target may be just a node index, or they may be references to nodes themselves.\n        static getTargetIndex(e: Link<Node | number>): number {\n            return typeof e.target === 'number' ? <number>e.target : (<Node>e.target).index;\n        }\n\n        // Get a string ID for a given link.\n        static linkId(e: Link<Node | number>): string {\n            return Layout.getSourceIndex(e) + \"-\" + Layout.getTargetIndex(e);\n        }\n\n        // The fixed property has three bits:\n        // Bit 1 can be set externally (e.g., d.fixed = true) and show persist.\n        // Bit 2 stores the dragging state, from mousedown to mouseup.\n        // Bit 3 stores the hover state, from mouseover to mouseout.\n        static dragStart(d: Node | Group) {\n            if (isGroup(d)) {\n                Layout.storeOffset(d, Layout.dragOrigin(d));\n            } else {\n                Layout.stopNode(d);\n                d.fixed |= 2; // set bit 2\n            }\n        }\n\n        // we clobber any existing desired positions for nodes\n        // in case another tick event occurs before the drag\n        private static stopNode(v: Node) {\n            (<any>v).px = v.x;\n            (<any>v).py = v.y;\n        }\n\n        // we store offsets for each node relative to the centre of the ancestor group\n        // being dragged in a pair of properties on the node\n        private static storeOffset(d: Group, origin: { x: number, y: number }) {\n            if (typeof d.leaves !== 'undefined') {\n                d.leaves.forEach(v => {\n                    v.fixed |= 2;\n                    Layout.stopNode(v);\n                    (<any>v)._dragGroupOffsetX = v.x - origin.x;\n                    (<any>v)._dragGroupOffsetY = v.y - origin.y;\n                });\n            }\n            if (typeof d.groups !== 'undefined') {\n                d.groups.forEach(g => Layout.storeOffset(g, origin));\n            }\n        }\n\n        // the drag origin is taken as the centre of the node or group\n        static dragOrigin(d: Node | Group): { x: number, y: number } {\n            if (isGroup(d)) {\n                return {\n                    x: d.bounds.cx(),\n                    y: d.bounds.cy()\n                };\n            } else {\n                return d;\n            }\n        }\n\n        // for groups, the drag translation is propagated down to all of the children of\n        // the group.\n        static drag(d: Node | Group, position: { x: number, y: number }) {\n            if (isGroup(d)) {\n                if (typeof d.leaves !== 'undefined') {\n                    d.leaves.forEach(v => {\n                        d.bounds.setXCentre(position.x);\n                        d.bounds.setYCentre(position.y);\n                        (<any>v).px = (<any>v)._dragGroupOffsetX + position.x;\n                        (<any>v).py = (<any>v)._dragGroupOffsetY + position.y;\n                    });\n                }\n                if (typeof d.groups !== 'undefined') {\n                    d.groups.forEach(g => Layout.drag(g, position));\n                }\n            } else {\n                (<any>d).px = position.x;\n                (<any>d).py = position.y;\n            }\n        }\n\n        // we unset only bits 2 and 3 so that the user can fix nodes with another a different\n        // bit such that the lock persists between drags\n        static dragEnd(d) {\n            if (isGroup(d)) {\n                if (typeof d.leaves !== 'undefined') {\n                    d.leaves.forEach(v => {\n                        Layout.dragEnd(v);\n                        delete (<any>v)._dragGroupOffsetX;\n                        delete (<any>v)._dragGroupOffsetY;\n                    });\n                }\n                if (typeof d.groups !== 'undefined') {\n                    d.groups.forEach(Layout.dragEnd);\n                }\n            } else {\n                d.fixed &= ~6; // unset bits 2 and 3\n                //d.fixed = 0;\n            }\n        }\n\n        // in d3 hover temporarily locks nodes, currently not used in cola\n        static mouseOver(d) {\n            d.fixed |= 4; // set bit 3\n            d.px = d.x, d.py = d.y; // set velocity to zero\n        }\n\n        // in d3 hover temporarily locks nodes, currently not used in cola\n        static mouseOut(d) {\n            d.fixed &= ~4; // unset bit 3\n        }\n    }\n","/**\n * Loads the WebAssembly module that performs the derivative computations for `descent.ts`\n */\n\nimport * as wasmSIMD from './wasm/build/simd/derivative_computer';\nimport wasmSIMD_bg from './wasm/build/simd/derivative_computer_bg.wasm';\nimport * as wasmNoSIMD from './wasm/build/no_simd/derivative_computer';\nimport wasmNoSIMD_bg from './wasm/build/no_simd/derivative_computer_bg.wasm';\n\n// prettier-ignore\nconst getHasSIMDSupport = async () => WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))\n\nclass AsyncOnce<T> {\n  private getter: () => Promise<T>;\n  private pending: Promise<T> | null = null;\n  private res: null | { value: T };\n\n  public constructor(getter: () => Promise<T>) {\n    this.getter = getter;\n  }\n\n  public async get(): Promise<T> {\n    if (this.res) {\n      return this.res.value;\n    }\n    if (this.pending) {\n      return this.pending;\n    }\n\n    this.pending = new Promise((resolve) =>\n      this.getter().then((res) => {\n        this.res = { value: res };\n        this.pending = null;\n        resolve(res);\n      })\n    );\n    return this.pending!;\n  }\n}\n\nexport const WasmInst = new AsyncOnce(async () => {\n  const hasWasmSIMDSupport = await getHasSIMDSupport();\n  if (!window.location.href.includes('localhost')) {\n    console.log(\n      hasWasmSIMDSupport\n        ? 'Wasm SIMD support detected!'\n        : 'Wasm SIMD support NOT detected; using non-SIMD Wasm'\n    );\n  }\n\n  if (hasWasmSIMDSupport) {\n    const wasmModule = await (wasmSIMD_bg as any)();\n    (wasmSIMD as any).setWasm(wasmModule);\n    return wasmSIMD;\n  } else {\n    const wasmModule = await (wasmNoSIMD_bg as any)();\n    (wasmNoSIMD as any).setWasm(wasmModule);\n    return wasmNoSIMD;\n  }\n});\n\ntype PromiseResolveType<P> = P extends Promise<infer T> ? T : never;\n\nexport type DerivativeComputerWasmInst = PromiseResolveType<ReturnType<typeof WasmInst.get>>;\n\nexport const getDerivativeComputerWasm = (): Promise<DerivativeComputerWasmInst> => WasmInst.get();\n","import {Layout, EventType, Event} from './layout'\n\n    export class LayoutAdaptor extends Layout {\n\n        // dummy functions in case not defined by client\n        trigger(e: Event) {};\n        kick() {};\n        drag() {};\n        on(eventType: EventType | string, listener: () => void) : this { return this; };\n\n        dragstart: (d:any) => void;\n        dragStart: (d:any) => void;\n        dragend: (d:any) => void;\n        dragEnd: (d:any) => void;\n\n        constructor( options ) {\n            super();\n\n            // take in implementation as defined by client\n\n            var self = this;\n            var o = options;\n\n            if ( o.trigger ) {\n                this.trigger = o.trigger;\n            }\n\n            if ( o.kick ){\n                this.kick = o.kick;\n            }\n\n            if ( o.drag ){\n                this.drag = o.drag;\n            }\n\n            if ( o.on ){\n                this.on = o.on;\n            }\n\n            this.dragstart = this.dragStart = Layout.dragStart;\n            this.dragend = this.dragEnd = Layout.dragEnd;\n        }\n    }\n\n    /**\n     * provides an interface for use with any external graph system (e.g. Cytoscape.js):\n     */\n    export function adaptor( options ): LayoutAdaptor {\n        return new LayoutAdaptor( options );\n    }\n","////<reference path=\"../extern/d3v3.d.ts\"/>\n////commented out the reference, because the path ended up in the typings, which\n////makes it impossible import in other projects.\n// declare const d3;\n\n\nimport {Layout, EventType, Event} from './layout';\nimport {ID3StyleLayoutAdaptor} from './d3adaptor'\n\n    /**\n     * @internal\n     */\n    export class D3StyleLayoutAdaptor extends Layout implements ID3StyleLayoutAdaptor {\n        protected readonly event: any;\n\n        trigger(e: Event) {\n            var d3event = { type: EventType[e.type], alpha: e.alpha, stress: e.stress };\n            this.event[d3event.type](d3event); // via d3 dispatcher, e.g. event.start(e);\n        }\n\n        // iterate layout using a d3.timer, which queues calls to tick repeatedly until tick returns true\n        kick() {\n            this.d3Context.timer(() => super.tick());\n        }\n\n        // a function to allow for dragging of nodes\n        drag: () => any;\n\n        private d3Context: any;\n\n        constructor(d3Context: any = self.d3) {\n            super();\n            this.d3Context = d3Context;\n            this.event = d3Context.dispatch(EventType[EventType.start], EventType[EventType.tick], EventType[EventType.end]);\n            // bit of trickyness remapping 'this' so we can reference it in the function body.\n            var d3layout = this;\n            var drag;\n            this.drag = function () {\n                if (!drag) {\n                    var drag = d3Context.behavior.drag()\n                        .origin(Layout.dragOrigin)\n                        .on(\"dragstart.d3adaptor\", Layout.dragStart)\n                        .on(\"drag.d3adaptor\", d => {\n                            Layout.drag(d, <any>d3layout.d3Context.event);\n                            d3layout.resume(); // restart annealing\n                        })\n                        .on(\"dragend.d3adaptor\", Layout.dragEnd);\n                }\n\n                if (!arguments.length) return drag;\n\n                // this is the context of the function, i.e. the d3 selection\n                this//.on(\"mouseover.adaptor\", colaMouseover)\n                //.on(\"mouseout.adaptor\", colaMouseout)\n                    .call(drag);\n            }\n        }\n\n        // a function for binding to events on the adapter\n        on(eventType: EventType | string, listener: () => void): this {\n            if (typeof eventType === 'string') {\n                this.event.on(eventType, listener);\n            } else {\n                this.event.on(EventType[eventType], listener);\n            }\n            return this;\n        }\n    }\n","import {dispatch} from 'd3-dispatch'\nimport {timer} from 'd3-timer'\nimport {drag as d3drag} from 'd3-drag'\nimport {Layout, EventType, Event} from './layout'\nimport {ID3StyleLayoutAdaptor} from './d3adaptor'\n\nexport interface D3Context {\n    timer: typeof timer; \n    drag: typeof d3drag; \n    dispatch: typeof dispatch;\n    event: any;\n}\n\n/**\n * @internal\n */\nexport class D3v4StyleLayoutAdaptor extends Layout implements ID3StyleLayoutAdaptor {\n    event:any;\n    trigger(e: Event) {\n        var d3event = { type: EventType[e.type], alpha: e.alpha, stress: e.stress };\n        // the dispatcher is actually expecting something of type EventTarget as the second argument\n        // so passing the thing above is totally abusing the pattern... not sure what to do about this yet\n        this.event.call(d3event.type, <any>d3event); // via d3 dispatcher, e.g. event.start(e);\n    }\n\n    // iterate layout using a d3.timer, which queues calls to tick repeatedly until tick returns true\n    kick() {\n        var t = this.d3Context.timer(() => super.tick() && t.stop());\n    }\n\n    // a function to allow for dragging of nodes\n    drag: () => any;\n\n    /**\n     * @internal\n     */\n    private readonly d3Context: D3Context;\n\n    constructor(d3Context: D3Context) {\n        super();\n        this.d3Context = d3Context;\n        this.event = d3Context.dispatch(EventType[EventType.start], EventType[EventType.tick], EventType[EventType.end]);\n\n        // bit of trickyness remapping 'this' so we can reference it in the function body.\n        var d3layout = this;\n        var drag;\n        this.drag = function () {\n            if (!drag) {\n                var drag = d3Context.drag()\n                    .subject(Layout.dragOrigin)\n                    .on(\"start.d3adaptor\", Layout.dragStart)\n                    .on(\"drag.d3adaptor\", d => {\n                        Layout.drag(<any>d, d3Context.event);\n                        d3layout.resume(); // restart annealing\n                    })\n                    .on(\"end.d3adaptor\", Layout.dragEnd);\n            }\n\n            if (!arguments.length) return drag;\n\n            // this is the context of the function, i.e. the d3 selection\n            //this//.on(\"mouseover.adaptor\", colaMouseover)\n            //.on(\"mouseout.adaptor\", colaMouseout)\n            arguments[0].call(drag);\n        }\n    }\n\n    // a function for binding to events on the adapter\n    on(eventType: EventType | string, listener: () => void): this {\n        if (typeof eventType === 'string') {\n            this.event.on(eventType, listener);\n        } else {\n            this.event.on(EventType[eventType], listener);\n        }\n        return this;\n    }\n}\n","import {Point} from './geom'\nimport {Rectangle} from './rectangle'\nimport {Constraint, Solver, Variable} from './vpsc'\nimport {Calculator} from './shortestpaths'\n    export interface NodeAccessor<Node>{\n        getChildren(v:Node) : number[];\n        getBounds(v:Node) : Rectangle;\n    }\n    export class NodeWrapper {\n        leaf: boolean;\n        parent: NodeWrapper;\n        ports: Vert[];\n        constructor(public id: number, public rect: Rectangle, public children: number[]) {\n            this.leaf = typeof children === 'undefined' || children.length === 0;\n        }\n    }\n    export class Vert {\n        constructor(public id: number, public x:number, public y: number, public node: NodeWrapper = null, public line = null) {}\n    }\n\n    export class LongestCommonSubsequence<T> {\n        length: number;\n        si: number;\n        ti: number;\n        reversed: boolean;\n        constructor(public s: T[], public t: T[]) {\n            var mf = LongestCommonSubsequence.findMatch(s, t);\n            var tr = t.slice(0).reverse();\n            var mr = LongestCommonSubsequence.findMatch(s, tr);\n            if (mf.length >= mr.length) {\n                this.length = mf.length;\n                this.si = mf.si;\n                this.ti = mf.ti;\n                this.reversed = false;\n            } else {\n                this.length = mr.length;\n                this.si = mr.si;\n                this.ti = t.length - mr.ti - mr.length;\n                this.reversed = true;\n            }\n        }\n        private static findMatch<T>(s: T[], t: T[]) {\n            var m = s.length;\n            var n = t.length;\n            var match = { length: 0, si: -1, ti: -1 };\n            var l = new Array(m);\n            for (var i = 0; i < m; i++) {\n                l[i] = new Array(n);\n                for (var j = 0; j < n; j++)\n                    if (s[i] === t[j]) {\n                        var v = l[i][j] = (i === 0 || j === 0) ? 1 : l[i - 1][j - 1] + 1;\n                        if (v > match.length) {\n                            match.length = v;\n                            match.si = i - v + 1;\n                            match.ti = j - v + 1;\n                        };\n                    } else l[i][j] = 0;\n            }\n            return match;\n        }\n        getSequence(): T[]{\n            return this.length >= 0 ? this.s.slice(this.si, this.si + this.length) : [];\n        }\n    }\n    // a horizontal or vertical line of nodes\n    export interface GridLine {\n        nodes: NodeWrapper[];\n        pos: number;\n    }\n    export class GridRouter<Node> {\n        leaves: NodeWrapper[] = null;\n        groups: NodeWrapper[];\n        nodes: NodeWrapper[];\n        cols: GridLine[];\n        rows: GridLine[];\n        root;\n        verts: Vert[];\n        edges;\n        backToFront;\n        obstacles;\n        passableEdges;\n        private avg(a) { return a.reduce((x, y) => x + y) / a.length }\n\n        // in the given axis, find sets of leaves overlapping in that axis\n        // center of each GridLine is average of all nodes in column\n        private getGridLines(axis): GridLine[] {\n            var columns = [];\n            var ls = this.leaves.slice(0, this.leaves.length);\n            while (ls.length > 0) {\n                // find a column of all leaves overlapping in axis with the first leaf\n                let overlapping = ls.filter(v=> v.rect['overlap' + axis.toUpperCase()](ls[0].rect));\n                let col = {\n                    nodes: overlapping,\n                    pos: this.avg(overlapping.map(v=> v.rect['c' + axis]()))\n                };\n                columns.push(col);\n                col.nodes.forEach(v=> ls.splice(ls.indexOf(v), 1));\n            }\n            columns.sort((a, b) => a.pos - b.pos)\n            return columns;\n        }\n\n        // get the depth of the given node in the group hierarchy\n        private getDepth(v) {\n            var depth = 0;\n            while (v.parent !== this.root) {\n                depth++;\n                v = v.parent;\n            }\n            return depth;\n        }\n\n        // medial axes between node centres and also boundary lines for the grid\n        private midPoints(a) {\n            if (a.length === 1) {\n                return [a[0]]\n            }\n\n            var gap = a[1] - a[0];\n            var mids = [a[0] - gap / 2];\n            for (var i = 1; i < a.length; i++) {\n                mids.push((a[i] + a[i - 1]) / 2);\n            }\n            mids.push(a[a.length - 1] + gap / 2);\n            return mids;\n        }\n\n        constructor(public originalnodes: Node[], accessor: NodeAccessor<Node>, public groupPadding: number = 12) {\n            this.nodes = originalnodes.map((v, i) => new NodeWrapper(i, accessor.getBounds(v), accessor.getChildren(v)));\n            this.leaves = this.nodes.filter(v=> v.leaf);\n            this.groups = this.nodes.filter(g=> !g.leaf);\n            this.cols = this.getGridLines('x');\n            this.rows = this.getGridLines('y');\n\n            // create parents for each node or group that is a member of another's children\n            this.groups.forEach(v=>\n                v.children.forEach(c=> this.nodes[<number>c].parent = v));\n\n            // root claims the remaining orphans\n            this.root = { children: [] };\n            this.nodes.forEach(v=> {\n                if (typeof v.parent === 'undefined') {\n                    v.parent = this.root;\n                    this.root.children.push(v.id);\n                }\n\n                // each node will have grid vertices associated with it,\n                // some inside the node and some on the boundary\n                // leaf nodes will have exactly one internal node at the center\n                // and four boundary nodes\n                // groups will have potentially many of each\n                v.ports = []\n            });\n\n            // nodes ordered by their position in the group hierarchy\n            this.backToFront = this.nodes.slice(0);\n            this.backToFront.sort((x, y) => this.getDepth(x) - this.getDepth(y));\n\n            // compute boundary rectangles for each group\n            // has to be done from front to back, i.e. inside groups to outside groups\n            // such that each can be made large enough to enclose its interior\n            var frontToBackGroups = this.backToFront.slice(0).reverse().filter(g=> !g.leaf);\n            frontToBackGroups.forEach(v=> {\n                var r = Rectangle.empty();\n                v.children.forEach(c=> r = r.union(this.nodes[c].rect));\n                v.rect = r.inflate(this.groupPadding);\n            });\n\n            var colMids = this.midPoints(this.cols.map(r=> r.pos));\n            var rowMids = this.midPoints(this.rows.map(r=> r.pos));\n\n            // setup extents of lines\n            var rowx = colMids[0], rowX = colMids[colMids.length - 1];\n            var coly = rowMids[0], colY = rowMids[rowMids.length - 1];\n\n            // horizontal lines\n            var hlines = this.rows.map(r=> <any>{ x1: rowx, x2: rowX, y1: r.pos, y2: r.pos })\n                .concat(rowMids.map(m=> <any>{ x1: rowx, x2: rowX, y1: m, y2: m }));\n\n            // vertical lines\n            var vlines = this.cols.map(c=> <any>{ x1: c.pos, x2: c.pos, y1: coly, y2: colY })\n                .concat(colMids.map(m=> <any>{ x1: m, x2: m, y1: coly, y2: colY }));\n\n            // the full set of lines\n            var lines = hlines.concat(vlines);\n\n            // we record the vertices associated with each line\n            lines.forEach(l=> l.verts = []);\n\n            // the routing graph\n            this.verts = [];\n            this.edges = [];\n\n            // create vertices at the crossings of horizontal and vertical grid-lines\n            hlines.forEach(h=>\n                vlines.forEach(v=> {\n                    var p = new Vert(this.verts.length, v.x1, h.y1);\n                    h.verts.push(p);\n                    v.verts.push(p);\n                    this.verts.push(p);\n\n                    // assign vertices to the nodes immediately under them\n                    var i = this.backToFront.length;\n                    while (i-- > 0) {\n                        var node = this.backToFront[i],\n                            r = node.rect;\n                        var dx = Math.abs(p.x - r.cx()),\n                            dy = Math.abs(p.y - r.cy());\n                        if (dx < r.width() / 2 && dy < r.height() / 2) {\n                            (<any>p).node = node;\n                            break;\n                        }\n                    }\n                })\n                );\n\n            lines.forEach((l, li) => {\n                // create vertices at the intersections of nodes and lines\n                this.nodes.forEach((v, i) => {\n                    v.rect.lineIntersections(l.x1, l.y1, l.x2, l.y2).forEach((intersect, j) => {\n                        //console.log(li+','+i+','+j+':'+intersect.x + ',' + intersect.y);\n                        var p = new Vert(this.verts.length, intersect.x, intersect.y, v, l);\n                        this.verts.push(p);\n                        l.verts.push(p);\n                        v.ports.push(p);\n                    });\n                });\n\n                // split lines into edges joining vertices\n                var isHoriz = Math.abs(l.y1 - l.y2) < 0.1;\n                var delta = (a, b) => isHoriz ? b.x - a.x : b.y - a.y;\n                l.verts.sort(delta);\n                for (var i = 1; i < l.verts.length; i++) {\n                    var u = l.verts[i - 1], v = l.verts[i];\n                    if (u.node && u.node === v.node && u.node.leaf) continue;\n                    this.edges.push({ source: u.id, target: v.id, length: Math.abs(delta(u, v)) });\n                }\n            });\n\n\n\n        }\n\n        // find path from v to root including both v and root\n        private findLineage(v) {\n            var lineage = [v];\n            do {\n                v = v.parent;\n                lineage.push(v);\n            } while (v !== this.root);\n            return lineage.reverse();\n        }\n\n        // find path connecting a and b through their lowest common ancestor\n        private findAncestorPathBetween(a, b) {\n            var aa = this.findLineage(a), ba = this.findLineage(b), i = 0;\n            while (aa[i] === ba[i]) i++;\n            // i-1 to include common ancestor only once (as first element)\n            return { commonAncestor: aa[i - 1], lineages: aa.slice(i).concat(ba.slice(i)) };\n        }\n\n        // when finding a path between two nodes a and b, siblings of a and b on the\n        // paths from a and b to their least common ancestor are obstacles\n        siblingObstacles(a, b) {\n            var path = this.findAncestorPathBetween(a, b);\n            var lineageLookup = {};\n            path.lineages.forEach(v=> lineageLookup[v.id] = {});\n            var obstacles = path.commonAncestor.children.filter(v=> !(v in lineageLookup));\n\n            path.lineages\n                .filter(v=> v.parent !== path.commonAncestor)\n                .forEach(v=> obstacles = obstacles.concat(v.parent.children.filter(c=> c !== v.id)));\n\n            return obstacles.map(v=> this.nodes[v]);\n        }\n\n        // for the given routes, extract all the segments orthogonal to the axis x\n        // and return all them grouped by x position\n        static getSegmentSets(routes, x, y) {\n            // vsegments is a list of vertical segments sorted by x position\n            var vsegments = [];\n            for (var ei = 0; ei < routes.length; ei++) {\n                var route = routes[ei];\n                for (var si = 0; si < route.length; si++) {\n                    var s = <any>route[si];\n                    s.edgeid = ei;\n                    s.i = si;\n                    var sdx = s[1][x] - s[0][x];\n                    if (Math.abs(sdx) < 0.1) {\n                        vsegments.push(s);\n                    }\n                }\n            }\n            vsegments.sort((a, b) => a[0][x] - b[0][x]);\n\n            // vsegmentsets is a set of sets of segments grouped by x position\n            var vsegmentsets = [];\n            var segmentset = null;\n            for (var i = 0; i < vsegments.length; i++) {\n                var s = vsegments[i];\n                if (!segmentset || Math.abs(s[0][x] - segmentset.pos) > 0.1) {\n                    segmentset = { pos: s[0][x], segments: [] };\n                    vsegmentsets.push(segmentset);\n                }\n                segmentset.segments.push(s);\n            }\n            return vsegmentsets;\n        }\n\n        // for all segments in this bundle create a vpsc problem such that\n        // each segment's x position is a variable and separation constraints\n        // are given by the partial order over the edges to which the segments belong\n        // for each pair s1,s2 of segments in the open set:\n        //   e1 = edge of s1, e2 = edge of s2\n        //   if leftOf(e1,e2) create constraint s1.x + gap <= s2.x\n        //   else if leftOf(e2,e1) create cons. s2.x + gap <= s1.x\n        static nudgeSegs(x: string, y: string, routes, segments, leftOf, gap: number) {\n            var n = segments.length;\n            if (n <= 1) return;\n            var vs = segments.map(s => new Variable(s[0][x]));\n            var cs = [];\n            for (var i = 0; i < n; i++) {\n                for (var j = 0; j < n; j++) {\n                    if (i === j) continue;\n                    var s1 = segments[i],\n                        s2 = segments[j],\n                        e1 = s1.edgeid,\n                        e2 = s2.edgeid,\n                        lind = -1,\n                        rind = -1;\n                    // in page coordinates (not cartesian) the notion of 'leftof' is flipped in the horizontal axis from the vertical axis\n                    // that is, when nudging vertical segments, if they increase in the y(conj) direction the segment belonging to the\n                    // 'left' edge actually needs to be nudged to the right\n                    // when nudging horizontal segments, if the segments increase in the x direction\n                    // then the 'left' segment needs to go higher, i.e. to have y pos less than that of the right\n                    if (x == 'x') {\n                        if (leftOf(e1, e2)) {\n                            //console.log('s1: ' + s1[0][x] + ',' + s1[0][y] + '-' + s1[1][x] + ',' + s1[1][y]);\n                            if (s1[0][y] < s1[1][y]) {\n                                lind = j, rind = i;\n                            } else {\n                                lind = i, rind = j;\n                            }\n                        }\n                    } else {\n                        if (leftOf(e1, e2)) {\n                            if (s1[0][y] < s1[1][y]) {\n                                lind = i, rind = j;\n                            } else {\n                                lind = j, rind = i;\n                            }\n                        }\n                    }\n                    if (lind >= 0) {\n                        //console.log(x+' constraint: ' + lind + '<' + rind);\n                        cs.push(new Constraint(vs[lind], vs[rind], gap));\n                    }\n                }\n            }\n            var solver = new Solver(vs, cs);\n            solver.solve();\n            vs.forEach((v, i) => {\n                var s = segments[i];\n                var pos = v.position();\n                s[0][x] = s[1][x] = pos;\n                var route = routes[s.edgeid];\n                if (s.i > 0) route[s.i - 1][1][x] = pos;\n                if (s.i < route.length - 1) route[s.i + 1][0][x] = pos;\n            });\n        }\n\n        static nudgeSegments(routes, x: string, y: string, leftOf: (e1: number, e2: number) => boolean, gap: number) {\n            var vsegmentsets = GridRouter.getSegmentSets(routes, x, y);\n            // scan the grouped (by x) segment sets to find co-linear bundles\n            for (var i = 0; i < vsegmentsets.length; i++) {\n                var ss = vsegmentsets[i];\n                var events = [];\n                for (var j = 0; j < ss.segments.length; j++) {\n                    var s = ss.segments[j];\n                    events.push({ type: 0, s: s, pos: Math.min(s[0][y], s[1][y]) });\n                    events.push({ type: 1, s: s, pos: Math.max(s[0][y], s[1][y]) });\n                }\n                events.sort((a, b) => a.pos - b.pos + a.type - b.type);\n                var open = [];\n                var openCount = 0;\n                events.forEach(e=> {\n                    if (e.type === 0) {\n                        open.push(e.s);\n                        openCount++;\n                    } else {\n                        openCount--;\n                    }\n                    if (openCount == 0) {\n                        GridRouter.nudgeSegs(x, y, routes, open, leftOf, gap);\n                        open = [];\n                    }\n                });\n            }\n        }\n\n        // obtain routes for the specified edges, nicely nudged apart\n        // warning: edge paths may be reversed such that common paths are ordered consistently within bundles!\n        // @param edges list of edges\n        // @param nudgeGap how much to space parallel edge segements\n        // @param source function to retrieve the index of the source node for a given edge\n        // @param target function to retrieve the index of the target node for a given edge\n        // @returns an array giving, for each edge, an array of segments, each segment a pair of points in an array\n        routeEdges<Edge>(edges: Edge[], nudgeGap: number, source: (e: Edge) => number, target: (e: Edge) => number): Point[][][] {\n            var routePaths = edges.map(e=> this.route(source(e), target(e)));\n            var order = GridRouter.orderEdges(routePaths);\n            var routes = routePaths.map(function (e) { return GridRouter.makeSegments(e); });\n            GridRouter.nudgeSegments(routes, 'x', 'y', order, nudgeGap);\n            GridRouter.nudgeSegments(routes, 'y', 'x', order, nudgeGap);\n            GridRouter.unreverseEdges(routes, routePaths);\n            return routes;\n        }\n\n        // path may have been reversed by the subsequence processing in orderEdges\n        // so now we need to restore the original order\n        static unreverseEdges(routes, routePaths) {\n            routes.forEach((segments, i) => {\n                var path = routePaths[i];\n                if ((<any>path).reversed) {\n                    segments.reverse(); // reverse order of segments\n                    segments.forEach(function (segment) {\n                        segment.reverse();  // reverse each segment\n                    });\n                }\n            });\n        }\n\n        static angleBetween2Lines(line1: Point[], line2: Point[]): number {\n            var angle1 = Math.atan2(line1[0].y - line1[1].y,\n                line1[0].x - line1[1].x);\n            var angle2 = Math.atan2(line2[0].y - line2[1].y,\n                line2[0].x - line2[1].x);\n            var diff = angle1 - angle2;\n            if (diff > Math.PI || diff < -Math.PI) {\n                diff = angle2 - angle1;\n            }\n            return diff;\n        }\n\n        // does the path a-b-c describe a left turn?\n        private static isLeft(a, b, c) {\n            return ((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) <= 0;\n        }\n\n        // for the given list of ordered pairs, returns a function that (efficiently) looks-up a specific pair to\n        // see if it exists in the list\n        private static getOrder(pairs: { l: number; r: number }[]): (l: number, r: number) => boolean {\n            var outgoing = {};\n            for (var i = 0; i < pairs.length; i++) {\n                var p = pairs[i];\n                if (typeof outgoing[p.l] === 'undefined') outgoing[p.l] = {};\n                outgoing[p.l][p.r] = true;\n            }\n            return (l, r) => typeof outgoing[l] !== 'undefined' && outgoing[l][r];\n        }\n\n        // returns an ordering (a lookup function) that determines the correct order to nudge the\n        // edge paths apart to minimize crossings\n        static orderEdges(edges) {\n            var edgeOrder = [];\n            for (var i = 0; i < edges.length - 1; i++) {\n                for (var j = i + 1; j < edges.length; j++) {\n                    var e = edges[i],\n                        f = edges[j],\n                        lcs = new LongestCommonSubsequence(e, f);\n                    var u, vi, vj;\n                    if (lcs.length === 0)\n                        continue; // no common subpath\n                    if (lcs.reversed) {\n                        // if we found a common subpath but one of the edges runs the wrong way,\n                        // then reverse f.\n                        f.reverse();\n                        f.reversed = true;\n                        lcs = new LongestCommonSubsequence(e, f);\n                    }\n                    if ((lcs.si <= 0 || lcs.ti <= 0) &&\n                        (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length)) {\n                        // the paths do not diverge, so make an arbitrary ordering decision\n                        edgeOrder.push({ l: i, r: j });\n                        continue;\n                    }\n                    if (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length) {\n                        // if the common subsequence of the\n                        // two edges being considered goes all the way to the\n                        // end of one (or both) of the lines then we have to\n                        // base our ordering decision on the other end of the\n                        // common subsequence\n                        u = e[lcs.si + 1];\n                        vj = e[lcs.si - 1];\n                        vi = f[lcs.ti - 1];\n                    } else {\n                        u = e[lcs.si + lcs.length - 2];\n                        vi = e[lcs.si + lcs.length];\n                        vj = f[lcs.ti + lcs.length];\n                    }\n                    if (GridRouter.isLeft(u, vi, vj)) {\n                        edgeOrder.push({ l: j, r: i });\n                    } else {\n                        edgeOrder.push({ l: i, r: j });\n                    }\n                }\n            }\n            //edgeOrder.forEach(function (e) { console.log('l:' + e.l + ',r:' + e.r) });\n            return GridRouter.getOrder(edgeOrder);\n        }\n\n        // for an orthogonal path described by a sequence of points, create a list of segments\n        // if consecutive segments would make a straight line they are merged into a single segment\n        // segments are over cloned points, not the original vertices\n        static makeSegments(path: Point[]): Point[][] {\n            function copyPoint(p: Point) {\n                return <Point>{ x: p.x, y: p.y };\n            }\n            var isStraight = (a, b, c) => Math.abs((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) < 0.001;\n            var segments = [];\n            var a = copyPoint(path[0]);\n            for (var i = 1; i < path.length; i++) {\n                var b = copyPoint(path[i]), c = i < path.length - 1 ? path[i + 1] : null;\n                if (!c || !isStraight(a, b, c)) {\n                    segments.push([a, b]);\n                    a = b;\n                }\n            }\n            return segments;\n        }\n\n        // find a route between node s and node t\n        // returns an array of indices to verts\n        route(s: number, t: number): Point[] {\n            var source = this.nodes[<number>s], target = this.nodes[<number>t];\n            this.obstacles = this.siblingObstacles(source, target);\n\n            var obstacleLookup = {};\n            this.obstacles.forEach(o => obstacleLookup[o.id] = o);\n            this.passableEdges = this.edges.filter(e=> {\n                var u = this.verts[e.source],\n                    v = this.verts[e.target];\n                return !(u.node && u.node.id in obstacleLookup\n                    || v.node && v.node.id in obstacleLookup);\n            });\n\n            // add dummy segments linking ports inside source and target\n            for (var i = 1; i < source.ports.length; i++) {\n                var u = source.ports[0].id;\n                var v = source.ports[i].id;\n                this.passableEdges.push({\n                    source: u,\n                    target: v,\n                    length: 0\n                });\n            }\n            for (var i = 1; i < target.ports.length; i++) {\n                var u = target.ports[0].id;\n                var v = target.ports[i].id;\n                this.passableEdges.push({\n                    source: u,\n                    target: v,\n                    length: 0\n                });\n            }\n\n            var getSource = e=> e.source,\n                getTarget = e=> e.target,\n                getLength = e=> e.length;\n\n            var shortestPathCalculator = new Calculator(this.verts.length, this.passableEdges, getSource, getTarget, getLength);\n            var bendPenalty = (u, v, w) => {\n                var a = this.verts[u], b = this.verts[v], c = this.verts[w];\n                var dx = Math.abs(c.x - a.x), dy = Math.abs(c.y - a.y);\n                // don't count bends from internal node edges\n                if (a.node === source && a.node === b.node || b.node === target && b.node === c.node)\n                    return 0;\n                return dx > 1 && dy > 1 ? 1000 : 0;\n            };\n\n            // get shortest path\n            var shortestPath = shortestPathCalculator.PathFromNodeToNodeWithPrevCost(\n                source.ports[0].id, target.ports[0].id,\n                bendPenalty);\n\n            // shortest path is reversed and does not include the target port\n            var pathPoints = shortestPath.reverse().map(vi => this.verts[vi]);\n            pathPoints.push(this.nodes[target.id].ports[0]);\n\n            // filter out any extra end points that are inside the source or target (i.e. the dummy segments above)\n            return pathPoints.filter((v, i) =>\n                !(i < pathPoints.length - 1 && pathPoints[i + 1].node === source && v.node === source\n                    || i > 0 && v.node === target && pathPoints[i - 1].node === target));\n        }\n\n        static getRoutePath(route: Point[][], cornerradius: number, arrowwidth: number, arrowheight: number): { routepath: string; arrowpath: string } {\n            var result = {\n                routepath: 'M ' + route[0][0].x + ' ' + route[0][0].y + ' ',\n                arrowpath: ''\n            };\n            if (route.length > 1) {\n                for (var i = 0; i < route.length; i++) {\n                    var li = route[i];\n                    var x = li[1].x, y = li[1].y;\n                    var dx = x - li[0].x;\n                    var dy = y - li[0].y;\n                    if (i < route.length - 1) {\n                        if (Math.abs(dx) > 0) {\n                            x -= dx / Math.abs(dx) * cornerradius;\n                        } else {\n                            y -= dy / Math.abs(dy) * cornerradius;\n                        }\n                        result.routepath += 'L ' + x + ' ' + y + ' ';\n                        var l = route[i + 1];\n                        var x0 = l[0].x, y0 = l[0].y;\n                        var x1 = l[1].x;\n                        var y1 = l[1].y;\n                        dx = x1 - x0;\n                        dy = y1 - y0;\n                        var angle = GridRouter.angleBetween2Lines(li, l) < 0 ? 1 : 0;\n                        //console.log(cola.GridRouter.angleBetween2Lines(li, l))\n                        var x2, y2;\n                        if (Math.abs(dx) > 0) {\n                            x2 = x0 + dx / Math.abs(dx) * cornerradius;\n                            y2 = y0;\n                        } else {\n                            x2 = x0;\n                            y2 = y0 + dy / Math.abs(dy) * cornerradius;\n                        }\n                        var cx = Math.abs(x2 - x);\n                        var cy = Math.abs(y2 - y);\n                        result.routepath += 'A ' + cx + ' ' + cy + ' 0 0 ' + angle + ' ' + x2 + ' ' + y2 + ' ';\n                    } else {\n                        var arrowtip = [x, y];\n                        var arrowcorner1, arrowcorner2;\n                        if (Math.abs(dx) > 0) {\n                            x -= dx / Math.abs(dx) * arrowheight;\n                            arrowcorner1 = [x, y + arrowwidth];\n                            arrowcorner2 = [x, y - arrowwidth];\n                        } else {\n                            y -= dy / Math.abs(dy) * arrowheight;\n                            arrowcorner1 = [x + arrowwidth, y];\n                            arrowcorner2 = [x - arrowwidth, y];\n                        }\n                        result.routepath += 'L ' + x + ' ' + y + ' ';\n                        if (arrowheight > 0) {\n                            result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1]\n                            + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];\n                        }\n                    }\n                }\n            } else {\n                var li = route[0];\n                var x = li[1].x, y = li[1].y;\n                var dx = x - li[0].x;\n                var dy = y - li[0].y;\n                var arrowtip = [x, y];\n                var arrowcorner1, arrowcorner2;\n                if (Math.abs(dx) > 0) {\n                    x -= dx / Math.abs(dx) * arrowheight;\n                    arrowcorner1 = [x, y + arrowwidth];\n                    arrowcorner2 = [x, y - arrowwidth];\n                } else {\n                    y -= dy / Math.abs(dy) * arrowheight;\n                    arrowcorner1 = [x + arrowwidth, y];\n                    arrowcorner2 = [x - arrowwidth, y];\n                }\n                result.routepath += 'L ' + x + ' ' + y + ' ';\n                if (arrowheight > 0) {\n                    result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1]\n                    + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];\n                }\n            }\n            return result;\n        }\n    }\n","import {Calculator} from './shortestpaths'\nimport {Descent} from './descent'\nimport {Projection, GraphNode, Rectangle} from './rectangle'\nimport {Variable} from './vpsc'\nimport {jaccardLinkLengths, LinkLengthAccessor} from './linklengths'\nimport { getDerivativeComputerWasm } from './wasmEngine'\n\n// Kick this off right away since we're going to need it eventually\nconst wasmInstPromise = getDerivativeComputerWasm();\n\nexport class Link3D {\n        length: number;\n        constructor(public source: number, public target: number) { }\n        actualLength(x: number[][]) {\n            return Math.sqrt(\n                x.reduce((c: number, v: number[]) => {\n                    const dx = v[this.target] - v[this.source];\n                    return c + dx * dx;\n                }, 0));\n        }\n    }\n    export class Node3D implements GraphNode {\n        // if fixed, layout will not move the node from its specified starting position\n        fixed: boolean;\n        width: number;\n        height: number;\n        px: number;\n        py: number;\n        bounds: Rectangle;\n        variable: Variable;\n        constructor(\n            public x: number = 0,\n            public y: number = 0,\n            public z: number = 0) { }\n    }\n    export class Layout3D {\n        static dims = ['x', 'y', 'z'];\n        static k = Layout3D.dims.length;\n        result: number[][];\n        constraints: any[] = null;\n\n        constructor(public nodes: Node3D[], public links: Link3D[], public idealLinkLength: number = 1) {\n            this.result = new Array(Layout3D.k);\n            for (var i = 0; i < Layout3D.k; ++i) {\n                this.result[i] = new Array(nodes.length);\n            }\n            nodes.forEach((v, i) => {\n                for (var dim of Layout3D.dims) {\n                    if (typeof v[dim] == 'undefined') v[dim] = Math.random();\n                }\n                this.result[0][i] = v.x;\n                this.result[1][i] = v.y;\n                this.result[2][i] = v.z;\n            });\n        };\n\n        linkLength(l: Link3D): number {\n            return l.actualLength(this.result);\n        }\n\n        useJaccardLinkLengths: boolean = true;\n\n        descent: Descent;\n        async start(iterations: number = 100): Promise<Layout3D> {\n            const n = this.nodes.length;\n\n            var linkAccessor = new LinkAccessor();\n\n            if (this.useJaccardLinkLengths)\n                jaccardLinkLengths(this.links, linkAccessor, 1.5);\n\n            this.links.forEach(e => e.length *= this.idealLinkLength);\n\n            // Create the distance matrix that Cola needs\n            const distanceMatrix = (new Calculator(n, this.links,\n                e=> e.source, e=> e.target, e => e.length)).DistanceMatrix();\n\n            const D = Descent.createSquareMatrix(n, (i, j) => distanceMatrix[i][j]);\n\n            // G is a square matrix with G[i][j] = 1 iff there exists an edge between node i and node j\n            // otherwise 2.\n            var G = Descent.createSquareMatrix(n, function () { return 2 });\n            this.links.forEach(({ source, target }) => G[source][target] = G[target][source] = 1);\n\n            const wasmInst = await wasmInstPromise;\n            this.descent = new Descent(this.result, D, undefined, wasmInst);\n            this.descent.threshold = 1e-3;\n            this.descent.G = G.map(Gn => new Float32Array(Gn));\n            //let constraints = this.links.map(e=> <any>{\n            //    axis: 'y', left: e.source, right: e.target, gap: e.length*1.5\n            //});\n            if (this.constraints)\n                this.descent.project = new Projection(<GraphNode[]>this.nodes, null, null, this.constraints).projectFunctions();\n\n            for (var i = 0; i < this.nodes.length; i++) {\n                var v = this.nodes[i];\n                if (v.fixed) {\n                    this.descent.locks.add(i, [v.x, v.y, v.z]);\n                }\n            }\n\n            this.descent.run(iterations);\n            return this;\n        }\n\n        tick(): number {\n            this.descent.locks.clear();\n            for (var i = 0; i < this.nodes.length; i++) {\n                var v = this.nodes[i];\n                if (v.fixed) {\n                    this.descent.locks.add(i, [v.x, v.y, v.z]);\n                }\n            }\n            return this.descent.rungeKutta();\n        }\n    }\n\n    class LinkAccessor implements LinkLengthAccessor<any> {\n        getSourceIndex(e: any): number { return e.source; }\n        getTargetIndex(e: any): number { return e.target; }\n        getLength(e: any): number { return e.length; }\n        setLength(e: any, l: number) { e.length = l; }\n    }\n","import {D3StyleLayoutAdaptor} from './d3v3adaptor'\nimport {D3Context, D3v4StyleLayoutAdaptor} from './d3v4adaptor'\nimport { Layout, EventType, Event } from './layout';\n\nexport { D3Context } from './d3v4adaptor';\n\nexport interface D3v3Context { version: string };\n\nexport interface ID3StyleLayoutAdaptor {\n    trigger(e: Event): void;\n    kick(): void;\n    drag: () => any;\n\n    on(eventType: EventType | string, listener: () => void): ID3StyleLayoutAdaptor;\n}\n\n\n/**\n * provides an interface for use with d3:\n * Correct way to create way to construct the d3 cola object is to pass the d3 object into the adaptor function, like so:\n * \n *   `var d3cola = cola.d3adaptor(d3);`\n * \n * Internally, it will figure out if d3 is version 3 or 4 from the version tag and set up the right event forwarding. Defaults to version 3 if the d3 object is not passed.\n * - uses the d3 event system to dispatch layout events such as:\n *   o \"start\" (start layout process)\n *   o \"tick\" (after each layout iteration)\n *   o \"end\" (layout converged and complete).\n * - uses the d3 timer to queue layout iterations.\n * - sets up d3.behavior.drag to drag nodes\n *   o use `node.call(<the returned instance of Layout>.drag)` to make nodes draggable\n * returns an instance of the cola.Layout itself with which the user\n * can interact directly.\n */\nexport function d3adaptor(d3Context?: D3Context | D3v3Context): Layout & ID3StyleLayoutAdaptor {\n    if (!d3Context || isD3V3(d3Context)) {\n        return new D3StyleLayoutAdaptor(d3Context);\n    }\n    return new D3v4StyleLayoutAdaptor(d3Context);\n}\n\nfunction isD3V3(d3Context: D3Context | D3v3Context): d3Context is D3v3Context {\n    const v3exp = /^3\\./;\n    return (<any>d3Context).version && (<any>d3Context).version.match(v3exp) !== null;\n}\n","import {Node, Link, Layout} from './layout'\nimport {GridRouter} from './gridrouter'\nimport {Point} from './geom'\n\n/**\n * @property nudgeGap spacing between parallel edge segments\n * @property margin space around nodes\n * @property groupMargin space around groups\n */\nexport function gridify(pgLayout, nudgeGap: number, margin: number, groupMargin: number) {\n    pgLayout.cola.start(0, 0, 0, 10, false);\n    let gridrouter = route(pgLayout.cola.nodes(), pgLayout.cola.groups(), margin, groupMargin);\n    return gridrouter.routeEdges<any>(pgLayout.powerGraph.powerEdges, nudgeGap, e=> e.source.routerNode.id, e=> e.target.routerNode.id);\n}\n\nfunction route(nodes, groups, margin: number, groupMargin: number) {\n    nodes.forEach(d => {\n        d.routerNode = <any>{\n            name: d.name,\n            bounds: d.bounds.inflate(-margin)\n        };\n    });\n    groups.forEach(d => {\n        d.routerNode = <any>{\n            bounds: d.bounds.inflate(-groupMargin),\n            children: (typeof d.groups !== 'undefined' ? d.groups.map(c=> nodes.length + c.id) : [])\n                .concat(typeof d.leaves !== 'undefined' ? d.leaves.map(c=> c.index) : [])\n        };\n    });\n    let gridRouterNodes = nodes.concat(groups).map((d, i) => {\n        d.routerNode.id = i;\n        return d.routerNode;\n    });\n    return new GridRouter(gridRouterNodes, {\n        getChildren: (v: any) => v.children,\n        getBounds: v => v.bounds\n    }, margin - groupMargin);\n}\n\nexport function powerGraphGridLayout(\n    graph: { nodes: Node[], links: Link<Node>[] },\n    size: number[],\n    grouppadding: number)\n{\n    // compute power graph\n    var powerGraph;\n    graph.nodes.forEach((v,i) => (<any>v).index = i);\n    new Layout()\n        .avoidOverlaps(false)\n        .nodes(graph.nodes)\n        .links(graph.links)\n        .powerGraphGroups(function (d) {\n            powerGraph = d;\n            powerGraph.groups.forEach(v=> v.padding = grouppadding);\n        });\n\n    // construct a flat graph with dummy nodes for the groups and edges connecting group dummy nodes to their children\n    // power edges attached to groups are replaced with edges connected to the corresponding group dummy node\n    var n = graph.nodes.length;\n    var edges = [];\n    var vs = graph.nodes.slice(0);\n    vs.forEach((v, i) => (<any>v).index = i);\n    powerGraph.groups.forEach(g => {\n        var sourceInd = g.index = g.id + n;\n        vs.push(g);\n        if (typeof g.leaves !== 'undefined')\n            g.leaves.forEach(v => edges.push({ source: sourceInd, target: v.index }));\n        if (typeof g.groups !== 'undefined')\n            g.groups.forEach(gg => edges.push({ source: sourceInd, target: gg.id + n }));\n    });\n    powerGraph.powerEdges.forEach(e=> {\n        edges.push({ source: e.source.index, target: e.target.index });\n    });\n\n    // layout the flat graph with dummy nodes and edges\n    new Layout()\n        .size(size)\n        .nodes(vs)\n        .links(edges)\n        .avoidOverlaps(false)\n        .linkDistance(30)\n        .symmetricDiffLinkLengths(5)\n        .convergenceThreshold(1e-4)\n        .start(100, 0, 0, 0, false);\n\n    // final layout taking node positions from above as starting positions\n    // subject to group containment constraints\n    // and then gridifying the layout\n    return {\n        cola:\n            new Layout()\n            .convergenceThreshold(1e-3)\n            .size(size)\n            .avoidOverlaps(true)\n            .nodes(graph.nodes)\n            .links(graph.links)\n        //.flowLayout('y', 30)\n            .groupCompactness(1e-4)\n            .linkDistance(30)\n            .symmetricDiffLinkLengths(5)\n            .powerGraphGroups(function (d) {\n                powerGraph = d;\n                powerGraph.groups.forEach(function (v) {\n                    v.padding = grouppadding\n                });\n            }).start(50, 0, 100, 0, false),\n        powerGraph: powerGraph\n    };\n}\n"],"names":["PowerEdge","source","target","type","Configuration","n","edges","linkAccessor","rootGroup","modules","Array","roots","initModulesFromGroup","push","ModuleSet","i","add","this","Module","R","length","forEach","e","s","_this","getSourceIndex","t","getTargetIndex","getType","outgoing","incoming","group","moduleSet","leaves","node","module","id","groups","j","child","definition","prop","hasOwnProperty","LinkSets","merge","a","b","k","inInt","intersection","outInt","children","m","update","o","forAll","ms","linktype","nls","remove","count","rootMerges","rs","merges","ctr","i_","nEdges","greedyMerge","sort","getGroupHierarchy","retargetedEdges","toGroups","isLeaf","g","gid","isIsland","isPredefined","allEdges","_this2","es","getEdges","edgetype","_this3","Object","keys","table","other","result","v","intersectionCount","contains","f","mid","vs","forAllModules","sets","Number","lt","getGroups","nodes","links","la","c","powerEdges","end","unionCount","u","computeLinkLengths","w","neighbours","addNeighbours","getNeighbours","l","setLength","symmetricDiffLinkLengths","Math","sqrt","jaccardLinkLengths","min","generateDirectedEdgeConstraints","axis","components","stronglyConnectedComponents","constraints","ui","vi","left","right","gap","getMinSeparation","numVertices","index","stack","strongConnect","lowlink","onStack","out","component","pop","map","Locks","x","locks","clear","isEmpty","apply","Descent","D","G","wasm","PseudoRandom","xn","Float32Array","setupWasm","d","ia","ib","xtmp","minD","MAX_VALUE","computeDerivatives","packed","packedX","set","outX","compute_2d","ctxPtr","slice","subarray","Error","compute_3d","p","apply_lock_2d","apply_lock_3d","cleanWasmMemory","getWasm","__wbindgen_free","ptr0","size0","ptr1","size1","ptr2","size2","allD","allG","dn","gn","Infinity","arr","create_derivative_computer_ctx_2d","create_derivative_computer_ctx_3d","createSquareMatrix","M","offsetDir","random","getNextBetween","dotProd","rightMultiply","r","computeStepSize","compute_step_size_2d","compute_step_size_3d","reduceStress","alpha","thisG","takeDescentStep","computeStress","copy","stepAndProject","x0","stepSize","project","mApply","matrixApply","computeNextPosition","run","iterations","stress","converged","rungeKutta","abs","threshold","disp","_this4","nMinus1","dx","isFinite","rl","memory","get_memory","memoryView","buffer","gOffset","get_g_2d","get_g_3d","fill","_","_this5","newG","_this6","Gn","set_G_2d","set_G_3d","DOffset","get_D_2d","get_D_3d","_this7","seed","getNext","range","max","PositionStats","scale","addVariable","ai","wi","weight","AB","offset","AD","desiredPosition","A2","getPosn","Constraint","equality","slack","unsatisfiable","position","Variable","dfdv","block","ps","posn","visitNeighbours","prev","ff","next","active","cOut","cIn","Block","vars","updateWeightedPosition","compute_lm","postAction","_dfdv","lm","populateSplitBlock","traverse","visit","acc","findMinLM","findMinLMBetween","lv","rv","findPath","to","endFound","isActiveDirectedPathBetween","split","createSplitBlock","startVar","splitBetween","vl","vr","bs","constraint","lb","rb","mergeAcross","dist","cost","sum","Blocks","list","blockInd","insert","last","swapBlock","updateBlockPositions","inactive","Solver","LAGRANGIAN_TOLERANCE","nb","cs","setStartingPositions","setDesiredPositions","mostViolated","minSlack","deletePoint","ZERO_UPPERBOUND","satisfy","solve","lastcost","TreeBase","data","res","_root","iter","iterator","_comparator","_cursor","_ancestors","get_child","size","find","lowerBound","_bound","upperBound","cmp","Iterator","each","cb","it","reach","cur","tree","_tree","root","_minNode","save","_maxNode","start","Node","red","dir","set_child","val","RBTree","comparator","ret","head","undefined","gp","ggp","is_red","dir2","single_rotate","double_rotate","found","sr","sibling","gpc","computeGroupBounds","bounds","reduce","union","Rectangle","empty","inflate","padding","X","y","Y","POSITIVE_INFINITY","NEGATIVE_INFINITY","cx","cy","overlapX","ux","vx","overlapY","uy","vy","setXCentre","setYCentre","dy","width","height","lineIntersections","x1","y1","x2","y2","sides","intersections","lineIntersection","rayIntersection","ints","vertices","x3","y3","x4","y4","dx12","dx34","dy12","dy34","denominator","dx31","dy31","pad","makeEdgeBetween","ah","si","ti","al","sourceIntersection","targetIntersection","arrowStart","makeEdgeTo","pos","makeRBTree","Event","isOpen","compareEvents","xRect","getCentre","getOpen","getClose","getSize","makeRect","open","close","center","findNeighbours","scanline","forward","reverse","findIter","uovervX","yRect","generateGroupConstraints","minSep","isContained","ln","childConstraints","ccs","concat","minVar","maxVar","variable","generateConstraints","gapAdjustment","rect","N","console","assert","events","makeConstraint","sep","mkcon","generateXConstraints","generateYConstraints","generateXGroupConstraints","generateYGroupConstraints","IndexedVariable","Projection","avoidOverlaps","variables","createConstraints","w2","h2","stiffness","createSeparation","makeFeasible","dim","offsets","nextPos","createAlignment","xConstraints","yConstraints","isSep","filter","setupVariablesAndBounds","y0","desired","getDesired","fixed","fixedWeight","h","ix","iy","xProject","px","xmin","xmax","p2","yProject","py","ymin","ymax","projectFunctions","updateNodeBounds","updateGroupBounds","starting","solver","PairingHeap","elem","subheaps","toString","selector","str","needComma","subheap","isHeap","lessThan","every","obj","heap2","removeMin","mergePairs","firstPair","remaining","decreaseKey","newValue","setHeapNode","newHeap","pairingNode","PriorityQueue","top","arg","reduceKey","heapNode","newKey","Neighbour","distance","QueueEntry","Calculator","getLength","DistanceMatrix","dijkstraNeighbours","DistancesFromNode","PathFromNodeToNode","PathFromNodeToNodeWithPrevCost","prevCost","q","qu","visitedFrom","neighbour","viduid","cc","path","dest","Point","LineSegment","PolyPoint","isLeft","P0","P1","P2","above","vj","below","Rtangent_PointPolyC","P","V","dnC","floor","Ltangent_PointPolyC","tangent_PolyPolyC","W","t1","t2","cmp1","cmp2","ix1","ix2","done","RLtangent_PolyPolyC","BiTangent","BiTangents","TVGPoint","VisibilityVertex","polyid","polyvertid","vv","VisibilityEdge","TangentVisibilityGraph","g0","E","Pi","Pj","tangents","addEdgeIfVisible","i1","i2","intersectsPolys","addPoint","Vclosed","poly","rtan","ltan","intersects","int","bt","v1","v2","v3","w1","w3","v1v2w2","v2w1w2","v2w2w3","w1w2v2","w2v1v2","w2v2v3","ll","rr","lr","isAnyPInQ","isPointInsidePoly","packingOptions","applyPacking","graphs","node_size","desired_ratio","centerGraph","svg_width","svg_height","real_width","real_height","min_width","global_bottom","line","step","max_width","put_rect","parent","space_left","bottom","graph","min_x","min_y","max_x","max_y","array","calculate_bb","curr_best_f","curr_best","get_entire_width","iterationCounter","f_x1","f_x2","flag","df","put_nodes_to_right_positions","separateGraphs","marks","ways","clusters","link","n1","n2","explore_node","is_new","adjacent","setWasm","wasmModule","WebAssembly","instantiate","__wbindgen_memory","inst","exports","heap","heap_next","cachegetFloat32Memory0","getFloat32Memory0","WASM_VECTOR_LEN","passArrayF32ToWasm0","malloc","ptr","cachegetInt32Memory0","getInt32Memory0","Int32Array","getArrayF32FromWasm0","len","idx","addHeapObject","node_count","__wbindgen_malloc","len0","ctx_ptr","retptr","__wbindgen_add_to_stack_pointer","r0","r1","p_0","p_1","x_0_u","x_1_u","p_2","x_2_u","getObject","dropObject","ctx","new_G","EventType","WasmInst","getter","get","value","pending","Promise","resolve","then","validate","Uint8Array","getHasSIMDSupport","hasWasmSIMDSupport","window","location","href","includes","log","wasmSIMD","wasmNoSIMD_bg","wasmNoSIMD","getDerivativeComputerWasm","wasmInstPromise","isGroup","Layout","setLinkLength","_linkType","on","listener","event","trigger","kick","tick","_alpha","_threshold","_running","_lastStress","_nodes","_descent","s1","updateNodePositions","_links","_groups","_rootGroup","gi","powerGraphGroups","powergraph","arguments","_avoidOverlaps","handleDisconnected","_handleDisconnected","flowLayout","minSeparation","_directedLinkConstraints","_constraints","distanceMatrix","_distanceMatrix","_canvasSize","defaultNodeSize","_defaultNodeSize","groupCompactness","_groupCompactness","linkDistance","_linkDistance","_linkLengthCalculator","linkType","convergenceThreshold","getLinkLength","getLinkType","idealLength","initialUnconstrainedIterations","initialUserConstraintIterations","initialAllConstraintsIterations","gridSnapIterations","keepRunning","distances","ao","strength","idealDistance","addAttraction","curConstraints","wasmInst","initialLayout","separateOverlappingComponents","resume","gg","pause","stop","prepareEdgeRouting","nodeMargin","_visibilityGraph","routeEdge","edge","draw","lineData","vg2","port1","port2","shortestPath","route","innerBounds","linkId","dragStart","storeOffset","dragOrigin","stopNode","origin","_dragGroupOffsetX","_dragGroupOffsetY","drag","dragEnd","mouseOver","mouseOut","LayoutAdaptor","options","dragstart","dragend","eventType","D3StyleLayoutAdaptor","d3Context","self","d3","dispatch","d3layout","behavior","call","d3event","timer","D3v4StyleLayoutAdaptor","subject","_Layout","NodeWrapper","leaf","Vert","LongestCommonSubsequence","mf","findMatch","tr","mr","reversed","match","getSequence","GridRouter","originalnodes","accessor","groupPadding","getBounds","getChildren","cols","getGridLines","rows","ports","backToFront","getDepth","colMids","midPoints","rowMids","rowx","rowX","coly","colY","hlines","vlines","lines","verts","li","intersect","isHoriz","delta","avg","columns","ls","overlapping","toUpperCase","col","splice","indexOf","depth","mids","findLineage","lineage","findAncestorPathBetween","aa","ba","commonAncestor","lineages","siblingObstacles","lineageLookup","obstacles","getSegmentSets","routes","vsegments","ei","edgeid","vsegmentsets","segmentset","segments","nudgeSegs","leftOf","e1","e2","lind","rind","nudgeSegments","ss","openCount","routeEdges","nudgeGap","routePaths","order","orderEdges","makeSegments","unreverseEdges","segment","angleBetween2Lines","line1","line2","angle1","atan2","angle2","diff","PI","getOrder","pairs","edgeOrder","lcs","copyPoint","isStraight","obstacleLookup","passableEdges","pathPoints","getRoutePath","cornerradius","arrowwidth","arrowheight","arrowcorner1","arrowcorner2","routepath","arrowpath","angle","arrowtip","Link3D","actualLength","Layout3D","idealLinkLength","dims","z","linkLength","LinkAccessor","useJaccardLinkLengths","descent","S","minmax","H","maxmin","maxmax","bot","version","isD3V3","pgLayout","margin","groupMargin","cola","routerNode","name","gridRouterNodes","powerGraph","grouppadding","sourceInd","spans","desiredCenter","leftMost","rightMost","leftMostSize","rightMostSize","vLower","vUpper","newCenters"],"mappings":"4qCAOiBA,EACT,SACWC,EACAC,EACAC,eAFAF,cACAC,YACAC,GAGFC,wBASGC,EAAWC,EAAuBC,EAAsCC,mCAAtCD,OACrCE,QAAU,IAAIC,MAAML,QACpBM,MAAQ,GACTH,OACKI,qBAAqBJ,OACvB,MACEG,MAAME,KAAK,IAAIC,OACf,IAAIC,EAAI,EAAGA,EAAIV,IAAKU,OAChBJ,MAAM,GAAGK,IAAIC,KAAKR,QAAQM,GAAK,IAAIG,EAAOH,SAElDI,EAAIb,EAAMc,OACfd,EAAMe,SAAQ,SAAAC,OACNC,EAAIC,EAAKf,QAAQF,EAAakB,eAAeH,IAC7CI,EAAIF,EAAKf,QAAQF,EAAaoB,eAAeL,IAC7CnB,EAAOI,EAAaqB,QAAQN,GAChCC,EAAEM,SAASb,IAAIb,EAAMuB,GACrBA,EAAEI,SAASd,IAAIb,EAAMoB,iCAIrBX,qBAAA,SAAqBmB,OACrBC,EAAY,IAAIlB,OACfH,MAAME,KAAKmB,OACX,IAAIjB,EAAI,EAAGA,EAAIgB,EAAME,OAAOb,SAAUL,EAAG,KACtCmB,EAAOH,EAAME,OAAOlB,GACpBoB,EAAS,IAAIjB,EAAOgB,EAAKE,SACxB3B,QAAQyB,EAAKE,IAAMD,EACxBH,EAAUhB,IAAImB,MAEdJ,EAAMM,WACD,IAAIC,EAAI,EAAGA,EAAIP,EAAMM,OAAOjB,SAAUkB,EAAG,KACtCC,EAAQR,EAAMM,OAAOC,GAErBE,EAAa,OACZ,IAAIC,KAAQF,EACA,WAATE,GAA8B,WAATA,GAAqBF,EAAMG,eAAeD,KAC/DD,EAAWC,GAAQF,EAAME,IAEjCT,EAAUhB,IAAI,IAAIE,GAAQ,EAAEoB,EAAG,IAAIK,EAAY,IAAIA,EAAY1B,KAAKL,qBAAqB2B,GAAQC,WAGlGR,KAIXY,MAAA,SAAMC,EAAWC,EAAWC,YAAAA,IAAAA,EAAY,OAChCC,EAAQH,EAAEf,SAASmB,aAAaH,EAAEhB,UAClCoB,EAASL,EAAEhB,SAASoB,aAAaH,EAAEjB,UACnCsB,EAAW,IAAIrC,EACnBqC,EAASnC,IAAI6B,GACbM,EAASnC,IAAI8B,OACTM,EAAI,IAAIlC,EAAOD,KAAKR,QAAQW,OAAQ8B,EAAQF,EAAOG,QAClD1C,QAAQI,KAAKuC,OACdC,EAAS,SAAC9B,EAAaR,EAAWuC,GAClC/B,EAAEgC,QAAO,SAACC,EAAIC,GACVD,EAAGD,QAAO,SAAAlD,OACFqD,EAAgBrD,EAAEU,GACtB2C,EAAI1C,IAAIyC,EAAUL,GAClBM,EAAIC,OAAOF,EAAUZ,GACrBa,EAAIC,OAAOF,EAAUX,GACVD,EAAES,GAAIK,OAAOF,EAAUpD,GACvByC,EAAEQ,GAAIK,OAAOF,EAAUpD,iBAI9CgD,EAAOH,EAAQ,WAAY,YAC3BG,EAAOL,EAAO,WAAY,iBACrB7B,GAAK6B,EAAMY,QAAUV,EAAOU,aAC5BjD,MAAMoC,GAAGY,OAAOd,QAChBlC,MAAMoC,GAAGY,OAAOb,QAChBnC,MAAMoC,GAAG/B,IAAIoC,GACXA,KAGHS,WAAA,SAAWd,YAAAA,IAAAA,EAAY,WAMvBe,EAAK7C,KAAKN,MAAMoC,GAAGtC,UACnBJ,EAAIyD,EAAG1C,OACP2C,EAAS,IAAIrD,MAAML,GAAKA,EAAI,IAC5B2D,EAAM,EACDjD,EAAI,EAAGkD,EAAK5D,EAAI,EAAGU,EAAIkD,IAAMlD,MAC7B,IAAIuB,EAAIvB,EAAE,EAAGuB,EAAIjC,IAAKiC,EAAG,KACtBO,EAAIiB,EAAG/C,GAAI+B,EAAIgB,EAAGxB,GACtByB,EAAOC,GAAO,CAAE5B,GAAI4B,EAAKE,OAAQjD,KAAKiD,OAAOrB,EAAGC,GAAID,EAAGA,EAAGC,EAAGA,GAC7DkB,WAGDD,KAGXI,YAAA,eACS,IAAIpD,EAAI,EAAGA,EAAIE,KAAKN,MAAMS,SAAUL,OAEjCE,KAAKN,MAAMI,GAAGN,UAAUW,OAAS,QAIjCgC,EADKnC,KAAK4C,WAAW9C,GAAGqD,MAAK,SAACvB,EAAGC,UAAMD,EAAEqB,QAAUpB,EAAEoB,OAASrB,EAAET,GAAKU,EAAEV,GAAKS,EAAEqB,OAASpB,EAAEoB,UAClF,QACPd,EAAEc,QAAUjD,KAAKE,eAChByB,MAAMQ,EAAEP,EAAGO,EAAEN,EAAG/B,IACd,MAIPmD,OAAA,SAAOrB,EAAWC,OAClBE,EAAQH,EAAEf,SAASmB,aAAaH,EAAEhB,UAClCoB,EAASL,EAAEhB,SAASoB,aAAaH,EAAEjB,iBAChCZ,KAAKE,EAAI6B,EAAMY,QAAUV,EAAOU,WAG3CS,kBAAA,SAAkBC,cACVjC,EAAS,UA8BrB,SAASkC,EAAS9D,EAAoBsB,EAAOM,GACzC5B,EAAQ8C,QAAO,SAAAH,MACPA,EAAEoB,SACGzC,EAAME,SAAQF,EAAME,OAAS,IAClCF,EAAME,OAAOpB,KAAKuC,EAAEhB,QACjB,KACCqC,EAAI1C,KACRqB,EAAEsB,IAAMrC,EAAOjB,QACVgC,EAAEuB,YAAcvB,EAAEwB,eAAgB,IACnCH,EAAI,CAAErC,GAAIgB,EAAEsB,KACRtB,EAAEwB,mBAEG,IAAInC,KAAQW,EAAEZ,WACfiC,EAAEhC,GAAQW,EAAEZ,WAAWC,GAC1BV,EAAMM,SAAQN,EAAMM,OAAS,IAClCN,EAAMM,OAAOxB,KAAKuC,EAAEsB,KACpBrC,EAAOxB,KAAK4D,GAEhBF,EAASnB,EAAED,SAAUsB,EAAGpC,OA9C5BkC,CAAStD,KAAKN,MAAM,GADT,GACmB0B,GACrBpB,KAAK4D,WACXxD,SAAQ,SAAAC,OACHuB,EAAIiC,EAAKrE,QAAQa,EAAErB,QACnB6C,EAAIgC,EAAKrE,QAAQa,EAAEpB,QACvBoE,EAAgBzD,KAAK,IAAIb,OACJ,IAAV6C,EAAE6B,IAAsBpD,EAAErB,OAASoC,EAAOQ,EAAE6B,UAClC,IAAV5B,EAAE4B,IAAsBpD,EAAEpB,OAASmC,EAAOS,EAAE4B,KACnDpD,EAAEnB,UAGHkC,KAGXwC,SAAA,eACQE,EAAK,UACT3E,EAAc4E,SAAS/D,KAAKN,MAAM,GAAIoE,GAC/BA,KAGJC,SAAP,SAAgBvE,EAAoBsE,GAChCtE,EAAQ8C,QAAO,SAAAH,GACXA,EAAE4B,SAASD,GACX3E,EAAc4E,SAAS5B,EAAED,SAAU4B,YA4BlC7D,wBAIEkB,EACAP,EACAC,EACAqB,EACAX,YAHAX,IAAAA,EAAqB,IAAIc,YACzBb,IAAAA,EAAqB,IAAIa,YACzBQ,IAAAA,EAAsB,IAAIrC,WAH1BsB,gBACAP,gBACAC,gBACAqB,kBACAX,6BAEXwC,SAAA,SAASD,mBACAlD,SAAS0B,QAAO,SAACC,EAAIyB,GACtBzB,EAAGD,QAAO,SAAArD,GACN6E,EAAGlE,KAAK,IAAIb,EAAUkF,EAAK9C,GAAIlC,EAAOkC,GAAI6C,aAKtDT,OAAA,kBACqC,IAA1BvD,KAAKkC,SAASS,WAGzBe,SAAA,kBACqC,IAA1B1D,KAAKY,SAAS+B,SAA2C,IAA1B3C,KAAKa,SAAS8B,WAGxDgB,aAAA,uBACsC,IAApB3D,KAAKuB,iBAUd1B,qCACI,8BACb8C,MAAA,kBACWuB,OAAOC,KAAKnE,KAAKoE,OAAOjE,UAEnC6B,aAAA,SAAaqC,OACLC,EAAS,IAAIzE,SACjByE,EAAOF,MAbf,SAAsBjC,EAAQ/C,OACtBU,EAAI,OACH,IAAIyE,KAAKpC,EAAOoC,KAAKnF,IAAGU,EAAEyE,GAAKpC,EAAEoC,WAC/BzE,EAUYkC,CAAahC,KAAKoE,MAAOC,EAAMD,OACvCE,KAEXE,kBAAA,SAAkBH,UACPrE,KAAKgC,aAAaqC,GAAO1B,WAEpC8B,SAAA,SAAStD,UACEA,KAAMnB,KAAKoE,SAEtBrE,IAAA,SAAIoC,QACKiC,MAAMjC,EAAEhB,IAAMgB,KAEvBO,OAAA,SAAOP,UACInC,KAAKoE,MAAMjC,EAAEhB,OAExBmB,OAAA,SAAOoC,OACE,IAAIC,KAAO3E,KAAKoE,MACjBM,EAAE1E,KAAKoE,MAAMO,OAGrBnF,QAAA,eACQoF,EAAK,eACJtC,QAAO,SAAAH,GACHA,EAAEwB,gBACHiB,EAAGhF,KAAKuC,MAETyC,QAIFlD,oCACG,UACA,6BACZiB,MAAA,kBACW3C,KAAKZ,KAEhBqF,SAAA,SAAStD,OACDmD,GAAS,cACRO,eAAc,SAAA1C,GACVmC,GAAUnC,EAAEhB,IAAMA,IACnBmD,GAAS,MAGVA,KAEXvE,IAAA,SAAIyC,EAAkBL,IACCK,KAAYxC,KAAK8E,KAAO9E,KAAK8E,KAAKtC,GAAYxC,KAAK8E,KAAKtC,GAAY,IAAI3C,GACzFE,IAAIoC,KACJnC,KAAKZ,KAEXsD,OAAA,SAAOF,EAAkBL,OACjBI,EAAgBvC,KAAK8E,KAAKtC,GAC9BD,EAAGG,OAAOP,GACS,IAAfI,EAAGI,gBACI3C,KAAK8E,KAAKtC,KAEnBxC,KAAKZ,KAEXkD,OAAA,SAAOoC,OACE,IAAIlC,KAAYxC,KAAK8E,KACtBJ,EAAa1E,KAAK8E,KAAKtC,GAAWuC,OAAOvC,OAGjDqC,cAAA,SAAcH,QACLpC,QAAO,SAACC,EAAIyC,UAAOzC,EAAGD,OAAOoC,SAEtC1C,aAAA,SAAaqC,OACLC,EAAmB,IAAI5C,cACtBY,QAAO,SAACC,EAAIyC,MACTA,KAAMX,EAAMS,KAAM,KACdhF,EAAIyC,EAAGP,aAAaqC,EAAMS,KAAKE,IAC/B5F,EAAIU,EAAE6C,QACNvD,EAAI,IACJkF,EAAOQ,KAAKE,GAAMlF,EAClBwE,EAAOlF,GAAKA,OAIjBkF,iBAQCW,EAAgBC,EAAcC,EAAeC,EAA4B7F,WAEjF8F,EAAI,IAAIlG,EADJ+F,EAAM/E,OACegF,EAAOC,EAAI7F,GACjC8F,EAAEnC,oBACLoC,EAA0B,GAC1B9B,EAAI6B,EAAEjC,kBAAkBkC,UAC5BA,EAAWlF,SAAQ,SAAUC,OACrBqE,EAAI,SAACa,OACD/B,EAAInD,EAAEkF,GACM,iBAAL/B,IAAenD,EAAEkF,GAAOL,EAAM1B,KAE7CkB,EAAE,UACFA,EAAE,aAEC,CAAEtD,OAAQoC,EAAG8B,WAAYA,GCrUpC,SAASE,EAAW5D,EAAQC,OACpB4D,EAAI,OACH,IAAI3F,KAAK8B,EAAG6D,EAAE3F,GAAK,OACnB,IAAIA,KAAK+B,EAAG4D,EAAE3F,GAAK,UACjBoE,OAAOC,KAAKsB,GAAGtF,OAI1B,SAASqE,EAAkB5C,EAAaC,OAChCzC,EAAI,MACH,IAAIU,KAAK8B,OAAuB,IAATC,EAAE/B,MAAsBV,SAC7CA,EAmBX,SAASsG,EAAyBP,EAAeQ,EAAWjB,EAA+BU,OACnFQ,EAjBR,SAA6BT,EAAeC,OACpCQ,EAAa,GACbC,EAAgB,SAACJ,EAAGlB,QACS,IAAlBqB,EAAWH,KAClBG,EAAWH,GAAK,IACpBG,EAAWH,GAAGlB,GAAK,WAEvBY,EAAM/E,SAAQ,SAAAC,OACNoF,EAAIL,EAAG5E,eAAeH,GAAIkE,EAAIa,EAAG1E,eAAeL,GACpDwF,EAAcJ,EAAGlB,GACjBsB,EAActB,EAAGkB,MAEdG,EAKUE,CAAcX,EAAOC,GACtCD,EAAM/E,SAAQ,SAAA2F,OACNnE,EAAIgE,EAAWR,EAAG5E,eAAeuF,IACjClE,EAAI+D,EAAWR,EAAG1E,eAAeqF,IACrCX,EAAGY,UAAUD,EAAG,EAAIJ,EAAIjB,EAAE9C,EAAGC,gBAOrBoE,EAA+Bd,EAAeC,EAA8BO,YAAAA,IAAAA,EAAY,GACpGD,EAAmBP,EAAOQ,GAAG,SAAC/D,EAAGC,UAAMqE,KAAKC,KAAKX,EAAW5D,EAAGC,GAAK2C,EAAkB5C,EAAGC,MAAKuD,YAMlFgB,EAAyBjB,EAAeC,EAA8BO,YAAAA,IAAAA,EAAY,GAC9FD,EAAmBP,EAAOQ,GAAG,SAAC/D,EAAGC,UAC7BqE,KAAKG,IAAInC,OAAOC,KAAKvC,GAAGzB,OAAQ+D,OAAOC,KAAKtC,GAAG1B,QAAU,IAAM,EAAIqE,EAAkB5C,EAAGC,GAAK2D,EAAW5D,EAAGC,KACzGuD,YAqBMkB,EAAsClH,EAAW+F,EAAeoB,EAC5EnB,OAEIoB,EAAaC,EAA4BrH,EAAG+F,EAAOC,GACnDF,EAAQ,GACZsB,EAAWpG,SAAQ,SAACiF,EAAEvF,UAClBuF,EAAEjF,SAAQ,SAAAmE,UAAKW,EAAMX,GAAKzE,YAE1B4G,EAAqB,UACzBvB,EAAM/E,SAAQ,SAAA2F,OACNY,EAAKvB,EAAG5E,eAAeuF,GAAIa,EAAKxB,EAAG1E,eAAeqF,GAC9Cb,EAAMyB,KAASzB,EAAM0B,IAEzBF,EAAY9G,KAAK,CACb2G,KAAMA,EACNM,KAAMF,EACNG,MAAOF,EACPG,IAAK3B,EAAG4B,iBAAiBjB,QAI9BW,WASKD,EAAkCQ,EAAqB5H,EAAe+F,OAC9EF,EAAQ,GACRgC,EAAQ,EACRC,EAAQ,GACRX,EAAa,YACRY,EAAc7C,GAEnBA,EAAE2C,MAAQ3C,EAAE8C,QAAUH,IACtBC,EAAMvH,KAAK2E,GACXA,EAAE+C,SAAU,gBAGE/C,EAAEgD,oBAAK,KAAZ5B,eACkB,IAAZA,EAAEuB,OAETE,EAAczB,GACdpB,EAAE8C,QAAUnB,KAAKG,IAAI9B,EAAE8C,QAAS1B,EAAE0B,UAC3B1B,EAAE2B,UAET/C,EAAE8C,QAAUnB,KAAKG,IAAI9B,EAAE8C,QAAS1B,EAAEuB,WAKtC3C,EAAE8C,UAAY9C,EAAE2C,MAAO,SAEnBM,EAAY,GACTL,EAAMhH,UACTwF,EAAIwB,EAAMM,OACRH,SAAU,EAEZE,EAAU5H,KAAK+F,GACXA,IAAMpB,KAGdiC,EAAW5G,KAAK4H,EAAUE,KAAI,SAAAnD,UAAKA,EAAEpD,YAGxC,IAAIrB,EAAI,EAAGA,EAAImH,EAAanH,IAC7BoF,EAAMtF,KAAK,CAACuB,GAAIrB,EAAGyH,IAAK,mBAEdlI,kBAAO,KAAZgB,UACDkE,EAAIW,EAAME,EAAG5E,eAAeH,IAC5BsF,EAAIT,EAAME,EAAG1E,eAAeL,IAChCkE,EAAEgD,IAAI3H,KAAK+F,iBAEDT,sBAALX,YAAmC,IAAZA,EAAE2C,OAAuBE,EAAc7C,UAChEiC,MC1JEmB,qCACyB,8BAOlC5H,IAAA,SAAIoB,EAAYyG,QAIPC,MAAM1G,GAAMyG,KAKrBE,MAAA,gBACSD,MAAQ,MAMjBE,QAAA,eACS,IAAIhC,KAAK/F,KAAK6H,aAAc,SAC1B,KAMXG,MAAA,SAAMtD,OACG,IAAIqB,KAAK/F,KAAK6H,MACfnD,EAAEK,OAAOgB,GAAI/F,KAAK6H,MAAM9B,UAiBvBkC,wBAmMGL,EAAeM,EAAeC,EAAsBC,YAAtBD,IAAAA,EAAgB,qBAxL/B,2BAiIO,oBACJ,sBACA,0BACI,cAEjB,IAAIE,eAE+D,UAiD3ED,KAAOA,OACPR,EAAIA,EAAEF,KAAI,SAAAY,UAAM,IAAIC,aAAaD,WACjCxG,EAAI8F,EAAEzH,WACPf,EAAIY,KAAKZ,EAAIwI,EAAE,GAAGzH,YAGjBqI,UAAUN,EAAGC,QAEbvG,EAAI,IAAInC,MAAMO,KAAK8B,QACnBD,EAAI,IAAIpC,MAAMO,KAAK8B,QACnBuD,EAAI,IAAI5F,MAAMO,KAAK8B,QACnB2G,EAAI,IAAIhJ,MAAMO,KAAK8B,QACnBzB,EAAI,IAAIZ,MAAMO,KAAK8B,QACnB4G,GAAK,IAAIjJ,MAAMO,KAAK8B,QACpB6G,GAAK,IAAIlJ,MAAMO,KAAK8B,QACpB8G,KAAO,IAAInJ,MAAMO,KAAK8B,QACtB+F,MAAQ,IAAIF,OACZkB,KAAO9D,OAAO+D,kBACRzH,EAAPvB,EAAIV,EACDU,SACHuB,EAAIjC,IACKiC,EAAIvB,GAAG,KACR2I,EAAIP,EAAEpI,GAAGuB,GACToH,EAAI,GAAKA,EAAIzI,KAAK6I,YACbA,KAAOJ,OAIpBzI,KAAK6I,OAAS9D,OAAO+D,YAAW9I,KAAK6I,KAAO,GAChD/I,EAAIE,KAAK8B,EACFhC,KACHuB,EAAIjC,OACCwC,EAAE9B,GAAK,IAAIyI,aAAanJ,QACxByC,EAAE/B,GAAK,IAAIyI,aAAanJ,QACxBiG,EAAEvF,GAAK,IAAIyI,aAAanJ,QACxBqJ,EAAE3I,GAAK,IAAIyI,aAAanJ,QACxBiB,EAAEP,GAAK,IAAIyI,aAAanJ,QACxBsJ,GAAG5I,GAAK,IAAIyI,aAAanJ,QACzBuJ,GAAG7I,GAAK,IAAIyI,aAAanJ,QACzBwJ,KAAK9I,GAAK,IAAIL,MAAML,gCAhK1B2J,mBAAA,SAAmBnB,OAGRoB,YAFC,IAAXhJ,KAAK8B,EAAS,KACRmH,GACID,EAAS,IAAIT,aAAaX,EAAE,GAAGzH,OAASI,EAAKuB,GACnD8F,EAAExH,SAAQ,SAACkI,EAAIxI,UAAMkJ,EAAOE,IAAIZ,EAAIxI,EAAIS,EAAKnB,MACtC4J,GAELG,EAAOnJ,KAAKoI,KAAKgB,WAAWpJ,KAAKqJ,OAAQJ,GAE3CrB,GACAA,EAAExH,SAAQ,SAACkI,EAAIxI,OACLwJ,EAAQH,EAAKI,SAASzJ,EAAIS,EAAKnB,EAAGU,EAAIS,EAAKnB,EAAImB,EAAKnB,GAC1DkJ,EAAGY,IAAII,UAGZ,CAAA,GAAe,IAAXtJ,KAAK8B,QAeN,IAAI0H,MAAM,8BAdVP,EAAW,eACPD,EAAS,IAAIT,aAAaX,EAAE,GAAGzH,OAASI,EAAKuB,UACnD8F,EAAExH,SAAQ,SAACkI,EAAIxI,UAAMkJ,EAAOE,IAAIZ,EAAIxI,EAAIS,EAAKnB,MACtC4J,EAHM,GAKXG,EAAOnJ,KAAKoI,KAAKqB,WAAWzJ,KAAKqJ,OAAQJ,GAE3CrB,GACAA,EAAExH,SAAQ,SAACkI,EAAIxI,OACLwJ,EAAQH,EAAKI,SAASzJ,EAAIS,EAAKnB,EAAGU,EAAIS,EAAKnB,EAAImB,EAAKnB,GAC1DkJ,EAAGY,IAAII,MAOdtJ,KAAK6H,MAAME,gBACPF,MAAMG,OAAM,SAACvC,EAAGiE,MACF,IAAXnJ,EAAKuB,EACLvB,EAAK6H,KAAKuB,cAAcpJ,EAAK8I,OAAQ5D,EAAGiE,EAAE,GAAIA,EAAE,GAAI9B,EAAE,GAAGnC,GAAImC,EAAE,GAAGnC,QAC/D,CAAA,GAAe,IAAXlF,EAAKuB,QAGN,IAAI0H,MAAM,0BAFhBjJ,EAAK6H,KAAKwB,cAAcrJ,EAAK8I,OAAQ5D,EAAGiE,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAI9B,EAAE,GAAGnC,GAAImC,EAAE,GAAGnC,GAAImC,EAAE,GAAGnC,WAoC1FoE,gBAAA,gBAEEzB,KAAK0B,UAAUC,gBAAgB/J,KAAKgK,KAAMhK,KAAKiK,YAE/C7B,KAAK0B,UAAUC,gBAAgB/J,KAAKkK,KAAMlK,KAAKmK,YAE/C/B,KAAK0B,UAAUC,gBAAgB/J,KAAKoK,KAAMpK,KAAKqK,UAGhD7B,UAAA,SAAUN,EAAeC,uBAAAA,IAAAA,EAAuB,UAC9CmC,EAAO,IAAI/B,aAAavI,KAAKZ,EAAIY,KAAKZ,GACtCmL,EAAOpC,EAAI,IAAII,aAAavI,KAAKZ,EAAIY,KAAK8B,GAAK,IAAIyG,aAAa,GACtEL,EAAE9H,SAAQ,SAACoK,EAAI1K,GACXwK,EAAKpB,IAAIsB,EAAI1K,EAAI+D,EAAKzE,MAEtB+I,GACAA,EAAE/H,SAAQ,SAACqK,EAAI3K,GACXyK,EAAKrB,IAAIuB,EAAI3K,EAAI+D,EAAKzE,MAI9BkL,EAAKlK,SAAQ,SAACqI,EAAG3I,GACH4K,WAANjC,IACA6B,EAAKxK,IAAM,IACXyK,EAAKzK,GAAK,YAKZ6K,GADuB,IAAX3K,KAAK8B,EAAU9B,KAAKoI,KAAKwC,kCAAoC5K,KAAKoI,KAAKyC,mCACnE7K,KAAKZ,EAAGkL,EAAMC,GACrBP,EAAcW,KAART,EAAQS,UACxBtB,OADwBsB,UAExBX,KAAOA,OACPE,KAAOA,OACPD,MAAsB,EAAdK,EAAKnK,YACbgK,MAAsB,EAAdI,EAAKpK,UAuDR2K,mBAAP,SAA0B1L,EAAWsF,WACpCqG,EAAI,IAAItL,MAAML,GACTU,EAAI,EAAGA,EAAIV,IAAKU,EAAG,CACxBiL,EAAEjL,GAAK,IAAIL,MAAML,OACZ,IAAIiC,EAAI,EAAGA,EAAIjC,IAAKiC,EACrB0J,EAAEjL,GAAGuB,GAAKqD,EAAE5E,EAAGuB,UAGhB0J,KAGHC,UAAA,0BACAvF,EAAI,IAAIhG,MAAMO,KAAK8B,GACnBiE,EAAI,EACCjG,EAAI,EAAGA,EAAIE,KAAK8B,IAAKhC,EAAG,KACzB8H,EAAInC,EAAE3F,GAAKE,KAAKiL,OAAOC,eAAe,IAAM,GAAK,GACrDnF,GAAK6B,EAAIA,SAEb7B,EAAIG,KAAKC,KAAKJ,GACPN,EAAEiC,KAAI,SAAAE,UAAIA,GAAK3D,EAAK4E,KAAO9C,SAGvBoF,QAAP,SAAevJ,EAAiBC,WAChC+F,EAAI,EAAG9H,EAAI8B,EAAEzB,OACVL,KAAK8H,GAAKhG,EAAE9B,GAAK+B,EAAE/B,UACnB8H,KAIIwD,cAAP,SAAqBjJ,EAAmBoC,EAAiB8G,WACzDvL,EAAIqC,EAAEhC,OACHL,KAAKuL,EAAEvL,GAAKmI,EAAQkD,QAAQhJ,EAAErC,GAAIyE,MAMtC+G,gBAAA,cACY,IAAXtL,KAAK8B,SACE9B,KAAKoI,KAAKmD,qBAAqBvL,KAAKqJ,QACxC,GAAe,IAAXrJ,KAAK8B,SACL9B,KAAKoI,KAAKoD,qBAAqBxL,KAAKqJ,cAErC,IAAIG,MAAM,6BAIjBiC,aAAA,gBACE1C,mBAAmB/I,KAAK4H,WACzB8D,EAAQ1L,KAAKsL,kBACXK,EAAQ3L,KAAKwD,EACV1D,EAAI,EAAGA,EAAIE,KAAK8B,IAAKhC,OACrB8L,gBAAgB5L,KAAK4H,EAAE9H,GAAI6L,EAAM7L,GAAI4L,UAEvC1L,KAAK6L,mBAGDC,KAAP,SAAYlK,EAAmBC,WAC/BM,EAAIP,EAAEzB,OAAQf,EAAIyC,EAAE,GAAG1B,OAClBL,EAAI,EAAGA,EAAIqC,IAAKrC,MAChB,IAAIuB,EAAI,EAAGA,EAAIjC,IAAKiC,EACrBQ,EAAE/B,GAAGuB,GAAKO,EAAE9B,GAAGuB,MAWnB0K,eAAA,SAAeC,EAAoBX,EAAmB5C,EAAmBwD,GAC7EhE,EAAQ6D,KAAKE,EAAIX,QACZO,gBAAgBP,EAAE,GAAI5C,EAAE,GAAIwD,GAC7BjM,KAAKkM,SAASlM,KAAKkM,QAAQ,GAAGF,EAAG,GAAIA,EAAG,GAAIX,EAAE,SAC7CO,gBAAgBP,EAAE,GAAI5C,EAAE,GAAIwD,GAC7BjM,KAAKkM,SAASlM,KAAKkM,QAAQ,GAAGb,EAAE,GAAIW,EAAG,GAAIX,EAAE,QAG5C,IAAIvL,EAAI,EAAGA,EAAIE,KAAK8B,EAAGhC,SACnB8L,gBAAgBP,EAAEvL,GAAI2I,EAAE3I,GAAImM,MAY1BE,OAAP,SAAchK,EAAW/C,EAAWsF,WACpC5E,EAAIqC,EAAUrC,KAAM,WAChBuB,EAAIjC,EAAUiC,KAAM,GAAGqD,EAAE5E,EAAGuB,MAGhC+K,YAAA,SAAY1H,GAChBuD,EAAQkE,OAAOnM,KAAK8B,EAAG9B,KAAKZ,EAAGsF,MAG3B2H,oBAAA,SAAoBL,EAAoBX,QACvCtC,mBAAmBiD,OAClBN,EAAQ1L,KAAKsL,0BACdS,eAAeC,EAAIX,EAAGrL,KAAKwD,EAAGkI,GAM/B1L,KAAKkM,cAEC,IAAI1C,MAAM,sFAQjB8C,IAAA,SAAIC,WACHC,EAASzH,OAAO+D,UAAW2D,GAAY,GACnCA,GAAaF,KAAe,GAAG,KAC/BjM,EAAIN,KAAK0M,aACbD,EAAYvG,KAAKyG,IAAIH,EAASlM,EAAI,GAAKN,KAAK4M,UAC5CJ,EAASlM,SAENkM,KAGJE,WAAA,2BACEL,oBAAoBrM,KAAK4H,EAAG5H,KAAK4B,GACtCqG,EAAQtD,IAAI3E,KAAK4H,EAAG5H,KAAK4B,EAAG5B,KAAK0I,SAC5B2D,oBAAoBrM,KAAK0I,GAAI1I,KAAK6B,GACvCoG,EAAQtD,IAAI3E,KAAK4H,EAAG5H,KAAK6B,EAAG7B,KAAK2I,SAC5B0D,oBAAoBrM,KAAK2I,GAAI3I,KAAKqF,QAClCgH,oBAAoBrM,KAAKqF,EAAGrF,KAAKyI,OAClCoE,EAAO,cACNT,aAAY,SAACtM,EAAGuB,OACbuG,GAAKkF,EAAKlL,EAAE9B,GAAGuB,GAAK,EAAMyL,EAAKjL,EAAE/B,GAAGuB,GAAK,EAAMyL,EAAKzH,EAAEvF,GAAGuB,GAAKyL,EAAKrE,EAAE3I,GAAGuB,IAAM,EAC9EoH,EAAIqE,EAAKlF,EAAE9H,GAAGuB,GAAKuG,EACvBiF,GAAQpE,EAAIA,EACZqE,EAAKlF,EAAE9H,GAAGuB,GAAKuG,KAEZiF,KAGIlI,IAAP,SAAW/C,EAAmBC,EAAmBM,GACrD8F,EAAQkE,OAAOvK,EAAEzB,OAAQyB,EAAE,GAAGzB,QAAQ,SAACL,EAAGuB,UACtCc,EAAErC,GAAGuB,GAAKO,EAAE9B,GAAGuB,IAAMQ,EAAE/B,GAAGuB,GAAKO,EAAE9B,GAAGuB,IAAM,QAG3CuK,gBAAA,SAAgBhE,EAAiBa,EAAiBwD,OAChD,IAAInM,EAAI,EAAGA,EAAIE,KAAKZ,IAAKU,EAC1B8H,EAAE9H,GAAK8H,EAAE9H,GAAKmM,EAAWxD,EAAE3I,MAI5B+L,cAAA,mBACCW,EAAS,EACJ/G,EAAI,EAAGsH,EAAU/M,KAAKZ,EAAI,EAAGqG,EAAIsH,IAAWtH,MAC5C,IAAIlB,EAAIkB,EAAI,EAAGrG,EAAIY,KAAKZ,EAAGmF,EAAInF,IAAKmF,EAAG,SACpCwB,EAAI,EACCjG,EAAI,EAAGA,EAAIE,KAAK8B,IAAKhC,EAAG,KACzBkN,EAAKhN,KAAK4H,EAAE9H,GAAG2F,GAAKzF,KAAK4H,EAAE9H,GAAGyE,GAClCwB,GAAKiH,EAAKA,EAEdjH,EAAIG,KAAKC,KAAKJ,OACV0C,EAAIzI,KAAKkI,EAAEzC,GAAGlB,MACb0I,SAASxE,QACVyE,EAAKzE,EAAI1C,EAEbyG,GAAUU,EAAKA,GADNzE,EAAIA,WAId+D,0CA/YDW,EAA6BnN,KAAKoI,KAAKgF,aACvCC,EAAa,IAAI9E,aAAa4E,EAAOG,QAGrCC,GADkB,IAAXvN,KAAK8B,EAAU9B,KAAKoI,KAAKoF,SAASxN,KAAKqJ,QAAUrJ,KAAKoI,KAAKqF,SAASzN,KAAKqJ,SA/BxE,SAiCP,IAAI5J,MAAMO,KAAK8B,GACjB4L,KAAK,MACLhG,KAAI,SAACiG,EAAG7N,UAAMuN,EAAW9D,SAASgE,EAAUzN,EAAI8N,EAAKxO,EAAGmO,EAAUzN,EAAI8N,EAAKxO,EAAIwO,EAAKxO,8BAEhFyO,cACHtD,EAAQ,cACNsD,EAAM,KACAtD,EAAO,IAAIhC,aAAauF,EAAK1O,EAAI0O,EAAK1O,UAC5CyO,EAAKzN,SAAQ,SAAC2N,EAAIjO,UAAMyK,EAAKrB,IAAI6E,EAAIjO,EAAIgO,EAAK1O,MACvCmL,SAEA,IAAIhC,aANL,MAUC,IAAXvI,KAAK8B,OAEAsI,KAAOpK,KAAKoI,KAAK4F,SAAShO,KAAKqJ,OAAQkB,QACvCF,MAAsB,EAAdE,EAAKpK,WACf,CAAA,GAAe,IAAXH,KAAK8B,QAKN,IAAI0H,MAAM,+BAHXY,KAAOpK,KAAKoI,KAAK6F,SAASjO,KAAKqJ,OAAQkB,QACvCF,MAAsB,EAAdE,EAAKpK,6CAsBhBgN,EAA6BnN,KAAKoI,KAAKgF,aACvCC,EAAa,IAAI9E,aAAa4E,EAAOG,QAGrCY,GADkB,IAAXlO,KAAK8B,EAAU9B,KAAKoI,KAAK+F,SAASnO,KAAKqJ,QAAUrJ,KAAKoI,KAAKgG,SAASpO,KAAKqJ,SAhFxE,SAkFP,IAAI5J,MAAMO,KAAKZ,GACjBsO,KAAK,MACLhG,KAAI,SAACiG,EAAG7N,UAAMuN,EAAW9D,SAAS2E,EAAUpO,EAAIuO,EAAKjP,EAAG8O,EAAUpO,EAAIuO,EAAKjP,EAAIiP,EAAKjP,oMAmD9E6I,eAAuB,UAyS7BI,wBAMUiG,YAAAA,IAAAA,EAAe,aAAfA,SALC,cACA,eACA,sBACI,iCAKxBC,QAAA,uBACSD,MAAQtO,KAAKsO,KAAOtO,KAAK4B,EAAI5B,KAAKqF,GAAKrF,KAAKmC,GACzCnC,KAAKsO,MAAQ,IAAMtO,KAAKwO,SAIpCtD,eAAA,SAAe7E,EAAaoI,UACjBpI,EAAMrG,KAAKuO,WAAaE,EAAMpI,SC7ehCqI,wBAKUC,cAAAA,UAJN,UACA,UACA,6BAIbC,YAAA,SAAYrK,OACJsK,EAAK7O,KAAK2O,MAAQpK,EAAEoK,MAEpBG,EAAKvK,EAAEwK,YACNC,IAAMF,EAAKD,GAFPtK,EAAE0K,OAAS1K,EAAEoK,YAGjBO,IAAMJ,EAAKD,EAAKtK,EAAE4K,qBAClBC,IAAMN,EAAKD,EAAKA,KAGzBQ,QAAA,kBACYrP,KAAKkP,GAAKlP,KAAKgP,IAAMhP,KAAKoP,SAI7BE,wBAKUzI,EAAuBC,EAAwBC,EAAoBwI,YAAAA,IAAAA,GAAoB,aAAvF1I,aAAuBC,WAAwBC,gBAAoBwI,eAHpE,sBACO,OAGhB1I,KAAOA,OACPC,MAAQA,OACRC,IAAMA,OACNwI,SAAWA,qBAGpBC,MAAA,kBACWxP,KAAKyP,cAAgB1K,OAAO+D,UAC7B9I,KAAK8G,MAAM6H,MAAQ3O,KAAK8G,MAAM4I,WAAa1P,KAAK+G,IAChD/G,KAAK6G,KAAK8H,MAAQ3O,KAAK6G,KAAK6I,iBAI7BC,wBAMUR,EAAgCJ,EAA2BJ,YAA3BI,IAAAA,EAAiB,YAAUJ,IAAAA,EAAgB,wBAA3EQ,cAAgCJ,aAA2BJ,cAL7D,6BAOjBiB,KAAA,kBACW,EAAM5P,KAAK+O,QAAU/O,KAAK0P,WAAa1P,KAAKmP,oBAGvDO,SAAA,kBACY1P,KAAK6P,MAAMC,GAAGnB,MAAQ3O,KAAK6P,MAAME,KAAO/P,KAAKiP,QAAUjP,KAAK2O,SAIxEqB,gBAAA,SAAgBC,EAAgBvL,OACxBwL,EAAK,SAAC7K,EAAG8K,UAAS9K,EAAE+K,QAAUH,IAASE,GAAQzL,EAAEW,EAAG8K,SACnDE,KAAKjQ,SAAQ,SAAAiF,UAAI6K,EAAG7K,EAAGA,EAAEyB,eACzBwJ,IAAIlQ,SAAQ,SAAAiF,UAAI6K,EAAG7K,EAAGA,EAAEwB,eAIxB0J,wBAMGhM,aALO,GAMfA,EAAE0K,OAAS,OACNa,GAAK,IAAIpB,EAAcnK,EAAEoK,YACzBC,YAAYrK,8BAGbqK,YAAA,SAAYrK,GAChBA,EAAEsL,MAAQ7P,UACLwQ,KAAK5Q,KAAK2E,QACVuL,GAAGlB,YAAYrK,QACfwL,KAAO/P,KAAK8P,GAAGT,aAIxBoB,uBAAA,gBACSX,GAAGd,GAAKhP,KAAK8P,GAAGZ,GAAKlP,KAAK8P,GAAGV,GAAK,MAClC,IAAItP,EAAI,EAAGV,EAAIY,KAAKwQ,KAAKrQ,OAAQL,EAAIV,IAAKU,OACtCgQ,GAAGlB,YAAY5O,KAAKwQ,KAAK1Q,SAC7BiQ,KAAO/P,KAAK8P,GAAGT,aAGhBqB,WAAA,SAAWnM,EAAakB,EAAakL,cACrCf,EAAOrL,EAAEqL,cACbrL,EAAEyL,gBAAgBvK,GAAG,SAACJ,EAAG8K,OACjBS,EAAQrQ,EAAKmQ,WAAWP,EAAM5L,EAAGoM,GACjCR,IAAS9K,EAAEyB,OACX8I,GAAQgB,EAAQvL,EAAEwB,KAAK8H,MACvBtJ,EAAEwL,GAAKD,IAEPhB,GAAQgB,EAAQvL,EAAEyB,MAAM6H,MACxBtJ,EAAEwL,IAAMD,GAEZD,EAAWtL,MAERuK,EAAOrL,EAAEoK,SAGZmC,mBAAA,SAAmBvM,EAAa0L,cACpC1L,EAAEyL,gBAAgBC,GAAM,SAAC5K,EAAG8K,GACxBA,EAAKlB,OAAS1K,EAAE0K,QAAUkB,IAAS9K,EAAEyB,MAAQzB,EAAE0B,KAAO1B,EAAE0B,KACxDlD,EAAK+K,YAAYuB,GACjBtM,EAAKiN,mBAAmBX,EAAM5L,SAKtCwM,SAAA,SAASC,EAA+BC,EAAY1M,EAA4B0L,uBAA5B1L,IAAAA,EAAcvE,KAAKwQ,KAAK,aAAIP,IAAAA,EAAe,MAC3F1L,EAAEyL,gBAAgBC,GAAM,SAAC5K,EAAG8K,GACxBc,EAAIrR,KAAKoR,EAAM3L,IACfpB,EAAK8M,SAASC,EAAOC,EAAKd,EAAM5L,SAOxC2M,UAAA,eACQ/O,EAAgB,iBACfuO,WAAW1Q,KAAKwQ,KAAK,GAAI,MAAM,SAAAnL,IAC3BA,EAAEkK,WAAmB,OAANpN,GAAckD,EAAEwL,GAAK1O,EAAE0O,MAAK1O,EAAIkD,MAEjDlD,KAGHgP,iBAAA,SAAiBC,EAAcC,QAC9BX,WAAWU,EAAI,MAAM,mBACtBjP,EAAI,iBACHmP,SAASF,EAAI,KAAMC,GAAI,SAAChM,EAAG8K,IACvB9K,EAAEkK,UAAYlK,EAAEyB,QAAUqJ,IAAe,OAANhO,GAAckD,EAAEwL,GAAK1O,EAAE0O,MAAK1O,EAAIkD,MAErElD,KAGHmP,SAAA,SAAS/M,EAAa0L,EAAgBsB,EAAcP,cACpDQ,GAAW,SACfjN,EAAEyL,gBAAgBC,GAAM,SAAC5K,EAAG8K,GACnBqB,GAAarB,IAASoB,IAAMzE,EAAKwE,SAASnB,EAAM5L,EAAGgN,EAAIP,KAExDQ,GAAW,EACXR,EAAM3L,EAAG8K,OAGVqB,KAKXC,4BAAA,SAA4BhM,EAAalB,MACjCkB,IAAMlB,EAAG,OAAO,UAChBzE,EAAI2F,EAAE4K,KAAKlQ,OACTL,KAAK,KACHuF,EAAII,EAAE4K,KAAKvQ,MACXuF,EAAE+K,QAAUpQ,KAAKyR,4BAA4BpM,EAAEyB,MAAOvC,GACtD,OAAO,SAER,KAIJmN,MAAP,SAAarM,UAKTA,EAAE+K,QAAS,EACJ,CAACG,EAAMoB,iBAAiBtM,EAAEwB,MAAO0J,EAAMoB,iBAAiBtM,EAAEyB,WAGtD6K,iBAAP,SAAwBC,OACxB/P,EAAI,IAAI0O,EAAMqB,UAClB/P,EAAEiP,mBAAmBc,EAAU,MACxB/P,KAIXgQ,aAAA,SAAaC,EAAcC,OAKnB1M,EAAIrF,KAAKmR,iBAAiBW,EAAIC,MACxB,OAAN1M,EAAY,KACR2M,EAAKzB,EAAMmB,MAAMrM,SACd,CAAE4M,WAAY5M,EAAG6M,GAAIF,EAAG,GAAIG,GAAIH,EAAG,WAGvC,QAGXI,YAAA,SAAYvQ,EAAUwD,EAAegN,GACjChN,EAAE+K,QAAS,MACN,IAAItQ,EAAI,EAAGV,EAAIyC,EAAE2O,KAAKrQ,OAAQL,EAAIV,IAAKU,EAAG,KACvCyE,EAAI1C,EAAE2O,KAAK1Q,GACfyE,EAAE0K,QAAUoD,OACPzD,YAAYrK,QAEhBwL,KAAO/P,KAAK8P,GAAGT,aAGxBiD,KAAA,mBACQC,EAAM,EAAGzS,EAAIE,KAAKwQ,KAAKrQ,OACpBL,KAAK,KACJyE,EAAIvE,KAAKwQ,KAAK1Q,GACd2I,EAAIlE,EAAEmL,WAAanL,EAAE4K,gBACzBoD,GAAO9J,EAAIA,EAAIlE,EAAEwK,cAEdwD,QAYFC,wBAGU5N,WAAAA,MACXxF,EAAIwF,EAAGzE,gBACNsS,KAAO,IAAIhT,MAAML,GACfA,KAAK,KACJyC,EAAI,IAAI0O,EAAM3L,EAAGxF,SAChBqT,KAAKrT,GAAKyC,EACfA,EAAE6Q,SAAWtT,8BAIrBkT,KAAA,mBACQC,EAAM,EAAGzS,EAAIE,KAAKyS,KAAKtS,OACpBL,KAAKyS,GAAOvS,KAAKyS,KAAK3S,GAAGwS,cACzBC,KAGXI,OAAA,SAAO9Q,GAIHA,EAAE6Q,SAAW1S,KAAKyS,KAAKtS,YAClBsS,KAAK7S,KAAKiC,MAOnBa,OAAA,SAAOb,OAKC+Q,EAAO5S,KAAKyS,KAAKtS,OAAS,EAC1B0S,EAAY7S,KAAKyS,KAAKG,QACrBH,KAAKtS,OAASyS,EACf/Q,IAAMgR,SACDJ,KAAK5Q,EAAE6Q,UAAYG,EACxBA,EAAUH,SAAW7Q,EAAE6Q,aAS/B/Q,MAAA,SAAM0D,OACEU,EAAIV,EAAEwB,KAAKgJ,MAAOxE,EAAIhG,EAAEyB,MAAM+I,MAI9BwC,EAAOhN,EAAEyB,MAAMmI,OAAS5J,EAAEwB,KAAKoI,OAAS5J,EAAE0B,IAC1ChB,EAAEyK,KAAKrQ,OAASkL,EAAEmF,KAAKrQ,QACvBkL,EAAE+G,YAAYrM,EAAGV,EAAGgN,QACf3P,OAAOqD,KAEZA,EAAEqM,YAAY/G,EAAGhG,GAAIgN,QAChB3P,OAAO2I,OAQpBjL,QAAA,SAAQsE,QACC+N,KAAKrS,QAAQsE,MAItBoO,qBAAA,gBACSL,KAAKrS,SAAQ,SAAAyB,UAAIA,EAAE4O,+BAI5BiB,MAAA,SAAMqB,mBACGD,4BACAL,KAAKrS,SAAQ,SAAAyB,OACV0C,EAAI1C,EAAEqP,YACA,OAAN3M,GAAcA,EAAEsM,GAAKmC,EAAOC,uBAC5BpR,EAAI0C,EAAEsC,KAAKgJ,MACXU,EAAMmB,MAAMnN,GAAGnE,SAAQ,SAAA8S,UAAItF,EAAK+E,OAAOO,MACvCtF,EAAKlL,OAAOb,GACZkR,EAASnT,KAAK2E,aA6BjByO,wBAOUpO,EAAuBuO,WAAvBvO,UAAuBuO,OACjCvO,GAAKA,EACVA,EAAGxE,SAAQ,SAAAmE,GACPA,EAAE+L,IAAM,GAAI/L,EAAE8L,KAAO,WAKpB8C,GAAKA,EACVA,EAAG/S,SAAQ,SAAAiF,GACPA,EAAEwB,KAAKwJ,KAAKzQ,KAAKyF,GACjBA,EAAEyB,MAAMwJ,IAAI1Q,KAAKyF,WAKhB0N,SAAWI,EAAGzL,KAAI,SAAArC,UAAMA,EAAE+K,QAAS,EAAc/K,UACjD2M,GAAK,gCAGdM,KAAA,kBACWtS,KAAKgS,GAAGM,UAKnBc,qBAAA,SAAqBtD,QACZiD,SAAW/S,KAAKmT,GAAGzL,KAAI,SAAArC,UAAMA,EAAE+K,QAAS,EAAc/K,UACtD2M,GAAK,IAAIQ,EAAOxS,KAAK4E,SACrBoN,GAAG5R,SAAQ,SAACyB,EAAG/B,UAAM+B,EAAEkO,KAAOD,EAAGhQ,SAG1CuT,oBAAA,SAAoBvD,QACXlL,GAAGxE,SAAQ,SAACmE,EAAGzE,UAAMyE,EAAE4K,gBAAkBW,EAAGhQ,SA4B7CwT,aAAA,mBACAC,EAAWxO,OAAO+D,UAClBvE,EAAgB,KAChBwB,EAAI/F,KAAK+S,SACT3T,EAAI2G,EAAE5F,OACNqT,EAAcpU,EACTU,EAAI,EAAGA,EAAIV,IAAKU,EAAG,KACpBuF,EAAIU,EAAEjG,OACNuF,EAAEoK,mBACFD,EAAQnK,EAAEmK,YACVnK,EAAEkK,UAAYC,EAAQ+D,KACtBA,EAAW/D,EACXjL,EAAIc,EACJmO,EAAc1T,EACVuF,EAAEkK,UAAU,cAGpBiE,IAAgBpU,IACfmU,EAAWP,EAAOS,kBAAoBlP,EAAE6L,QAAU7L,EAAEgL,YAErDxJ,EAAEyN,GAAezN,EAAE3G,EAAI,GACvB2G,EAAE5F,OAASf,EAAI,GAEZmF,KAKXmP,QAAA,WACmB,MAAX1T,KAAKgS,UACAA,GAAK,IAAIQ,EAAOxS,KAAK4E,UAKzBoN,GAAGN,MAAM1R,KAAK+S,kBACfxO,EAAgB,MACZA,EAAIvE,KAAKsT,kBAAoB/O,EAAEgL,UAAYhL,EAAEiL,QAAUwD,EAAOS,kBAAoBlP,EAAE6L,SAAS,KAC7F8B,EAAK3N,EAAEsC,KAAKgJ,SAMZqC,IANwB3N,EAAEuC,MAAM+I,WAO3BmC,GAAGrQ,MAAM4C,OACX,IACC2N,EAAGT,4BAA4BlN,EAAEuC,MAAOvC,EAAEsC,MAAO,CAEjDtC,EAAEkL,eAAgB,eAIlBiC,EAAQQ,EAAGL,aAAatN,EAAEsC,KAAMtC,EAAEuC,UACxB,OAAV4K,EAKG,CAIHnN,EAAEkL,eAAgB,gBARbuC,GAAGW,OAAOjB,EAAMQ,SAChBF,GAAGW,OAAOjB,EAAMS,SAChBH,GAAGtP,OAAOwP,QACVa,SAASnT,KAAK8R,EAAMO,YAQzB1N,EAAEiL,SAAW,OAKRuD,SAASnT,KAAK2E,QAKdyN,GAAGrQ,MAAM4C,QAe9BoP,MAAA,gBACSD,kBACDE,EAAW7O,OAAO+D,UAAWwJ,EAAOtS,KAAKgS,GAAGM,OACzCpM,KAAKyG,IAAIiH,EAAWtB,GAAQ,WAC1BoB,UACLE,EAAWtB,EACXA,EAAOtS,KAAKgS,GAAGM,cAEZA,QAnKJU,wBAAwB,KACxBA,mBAAmB,UCtUjBa,wCA4BE,SAAUC,WACbC,EAAM/T,KAAKgU,MACXC,EAAOjU,KAAKkU,WAED,OAARH,GAAc,KACb1O,EAAIrF,KAAKmU,YAAYL,EAAMC,EAAID,SACzB,IAANzO,SACA4O,EAAKG,QAAUL,EACRE,EAGPA,EAAKI,WAAWzU,KAAKmU,GACrBA,EAAMA,EAAIO,UAAUjP,EAAI,UAIzB,iCAvCXyC,MAAA,gBACSkM,MAAQ,UACRO,KAAO,KAIhBC,KAAA,SAAKV,WACGC,EAAM/T,KAAKgU,MAEA,OAARD,GAAc,KACb1O,EAAIrF,KAAKmU,YAAYL,EAAMC,EAAID,SACzB,IAANzO,SACO0O,EAAID,KAGXC,EAAMA,EAAIO,UAAUjP,EAAI,UAIzB,QAwBXoP,WAAA,SAAWX,UACA9T,KAAK0U,OAAOZ,EAAM9T,KAAKmU,gBAIlCQ,WAAA,SAAWb,OACHc,EAAM5U,KAAKmU,mBAMRnU,KAAK0U,OAAOZ,YAJElS,EAAGC,UACb+S,EAAI/S,EAAGD,SAOtByE,IAAA,eACQ0N,EAAM/T,KAAKgU,SACH,OAARD,SACO,UAGS,OAAbA,EAAIlN,MACPkN,EAAMA,EAAIlN,YAGPkN,EAAID,QAIfrF,IAAA,eACQsF,EAAM/T,KAAKgU,SACH,OAARD,SACO,UAGU,OAAdA,EAAIjN,OACPiN,EAAMA,EAAIjN,aAGPiN,EAAID,QAKfI,SAAA,kBACW,IAAIW,EAAS7U,SAIxB8U,KAAA,SAAKC,WACyBjB,EAAtBkB,EAAKhV,KAAKkU,WACgB,QAAtBJ,EAAOkB,EAAG7E,SACd4E,EAAGjB,MAKXmB,MAAA,SAAMF,WACwBjB,EAAtBkB,EAAKhV,KAAKkU,WACgB,QAAtBJ,EAAOkB,EAAG/E,SACd8E,EAAGjB,MAKXY,OAAA,SAAOZ,EAAMc,WACLM,EAAMlV,KAAKgU,MACXC,EAAOjU,KAAKkU,WAED,OAARgB,GAAc,KACb7P,EAAIrF,KAAKmU,YAAYL,EAAMoB,EAAIpB,SACzB,IAANzO,SACA4O,EAAKG,QAAUc,EACRjB,EAEXA,EAAKI,WAAWzU,KAAKsV,GACrBA,EAAMA,EAAIZ,UAAUjP,EAAI,OAGvB,IAAIvF,EAAImU,EAAKI,WAAWlU,OAAS,EAAGL,GAAK,IAAKA,KAE3C8U,EAAId,GADRoB,EAAMjB,EAAKI,WAAWvU,IACJgU,MAAQ,SACtBG,EAAKG,QAAUc,EACfjB,EAAKI,WAAWlU,OAASL,EAClBmU,SAIfA,EAAKI,WAAWlU,OAAS,EAClB8T,QAGFY,wBAIGM,QACHC,MAAQD,OACRd,WAAa,QACbD,QAAU,gCAGnBN,KAAA,kBAC4B,OAAjB9T,KAAKoU,QAAmBpU,KAAKoU,QAAQN,KAAO,QAKvD3D,KAAA,cACyB,OAAjBnQ,KAAKoU,QAAkB,KACnBiB,EAAOrV,KAAKoV,MAAMpB,MACT,OAATqB,QACKC,SAASD,OAGjB,KAIOE,KAHmB,OAAvBvV,KAAKoU,QAAQtN,QAIV,IACCyO,EAAOvV,KAAKoU,SACRpU,KAAKqU,WAAWlU,OAGf,MACIiU,QAAU,gBAHVA,QAAUpU,KAAKqU,WAAW5M,YAM9BzH,KAAKoU,QAAQtN,QAAUyO,aAI3BlB,WAAWzU,KAAKI,KAAKoU,cACrBkB,SAAStV,KAAKoU,QAAQtN,cAGX,OAAjB9G,KAAKoU,QAAmBpU,KAAKoU,QAAQN,KAAO,QAKvD7D,KAAA,cACyB,OAAjBjQ,KAAKoU,QAAkB,KACnBiB,EAAOrV,KAAKoV,MAAMpB,MACT,OAATqB,QACKG,SAASH,OAGjB,KAEOE,KADkB,OAAtBvV,KAAKoU,QAAQvN,OAEV,IACC0O,EAAOvV,KAAKoU,SACRpU,KAAKqU,WAAWlU,OAGf,MACIiU,QAAU,gBAHVA,QAAUpU,KAAKqU,WAAW5M,YAM9BzH,KAAKoU,QAAQvN,OAAS0O,aAG1BlB,WAAWzU,KAAKI,KAAKoU,cACrBoB,SAASxV,KAAKoU,QAAQvN,aAGX,OAAjB7G,KAAKoU,QAAmBpU,KAAKoU,QAAQN,KAAO,QAGvDwB,SAAA,SAASG,QACiB,OAAfA,EAAM5O,WACJwN,WAAWzU,KAAK6V,GACrBA,EAAQA,EAAM5O,UAEbuN,QAAUqB,KAGnBD,SAAA,SAASC,QACkB,OAAhBA,EAAM3O,YACJuN,WAAWzU,KAAK6V,GACrBA,EAAQA,EAAM3O,WAEbsN,QAAUqB,QAIjBC,wBAKU5B,QACHA,KAAOA,OACPjN,KAAO,UACPC,MAAQ,UACR6O,KAAM,6BAGfrB,UAAA,SAAUsB,UACCA,EAAM5V,KAAK8G,MAAQ9G,KAAK6G,QAGnCgP,UAAA,SAAUD,EAAKE,GACPF,OACK9O,MAAQgP,OAGRjP,KAAOiP,QAKXC,yBAKGC,sCAEHhC,MAAQ,OACRG,YAAc6B,IACdzB,KAAO,sCAIhB5B,OAAA,SAAOmB,OACCmC,GAAM,KAES,OAAfjW,KAAKgU,WAEAA,MAAQ,IAAI0B,EAAK5B,GACtBmC,GAAM,OACD1B,WAEJ,KACG2B,EAAO,IAAIR,OAAKS,GAEhBP,GAAM,EACNhD,GAAO,EAGPwD,EAAK,KACLC,EAAMH,EACNxM,EAAI,KACJzI,EAAOjB,KAAKgU,UAChBqC,EAAIvP,MAAQ9G,KAAKgU,QAGJ,IACI,OAAT/S,GAEAA,EAAO,IAAIyU,EAAK5B,GAChBpK,EAAEmM,UAAUD,EAAK3U,GACjBgV,GAAM,OACD1B,QAEAwB,EAAOO,OAAOrV,EAAK4F,OAASkP,EAAOO,OAAOrV,EAAK6F,SAEpD7F,EAAK0U,KAAM,EACX1U,EAAK4F,KAAK8O,KAAM,EAChB1U,EAAK6F,MAAM6O,KAAM,GAIjBI,EAAOO,OAAOrV,IAAS8U,EAAOO,OAAO5M,GAAI,KACrC6M,EAAOF,EAAIvP,QAAUsP,EAErBnV,IAASyI,EAAE4K,UAAU1B,GACrByD,EAAIR,UAAUU,EAAMR,EAAOS,cAAcJ,GAAKxD,IAG9CyD,EAAIR,UAAUU,EAAMR,EAAOU,cAAcL,GAAKxD,QAIlDgC,EAAM5U,KAAKmU,YAAYlT,EAAK6S,KAAMA,MAG1B,IAARc,QAIJhC,EAAOgD,EAII,OAAPQ,IACAC,EAAMD,GAEVA,EAAK1M,EACLA,EAAIzI,EACJA,EAAOA,EAAKqT,UARZsB,EAAMhB,EAAM,QAYXZ,MAAQkC,EAAKpP,kBAIjBkN,MAAM2B,KAAM,EAEVM,KAIXvT,OAAA,SAAOoR,MACgB,OAAf9T,KAAKgU,aACE,MAGPkC,EAAO,IAAIR,OAAKS,GAChBlV,EAAOiV,EACXjV,EAAK6F,MAAQ9G,KAAKgU,cACdtK,EAAI,KACJ0M,EAAK,KACLM,EAAQ,KACRd,GAAM,EAEqB,OAAxB3U,EAAKqT,UAAUsB,IAAe,KAC7BhD,EAAOgD,EAGXQ,EAAK1M,EACLA,EAAIzI,EACJA,EAAOA,EAAKqT,UAAUsB,OAElBhB,EAAM5U,KAAKmU,YAAYL,EAAM7S,EAAK6S,SAEtC8B,EAAMhB,EAAM,EAGA,IAARA,IACA8B,EAAQzV,IAIP8U,EAAOO,OAAOrV,KAAU8U,EAAOO,OAAOrV,EAAKqT,UAAUsB,OAClDG,EAAOO,OAAOrV,EAAKqT,WAAWsB,IAAO,KACjCe,EAAKZ,EAAOS,cAAcvV,EAAM2U,GACpClM,EAAEmM,UAAUjD,EAAM+D,GAClBjN,EAAIiN,OAEH,IAAKZ,EAAOO,OAAOrV,EAAKqT,WAAWsB,IAAO,KACvCgB,EAAUlN,EAAE4K,WAAW1B,MACX,OAAZgE,KACKb,EAAOO,OAAOM,EAAQtC,WAAW1B,KAAWmD,EAAOO,OAAOM,EAAQtC,UAAU1B,IAM5E,KACG2D,EAAOH,EAAGtP,QAAU4C,EAEpBqM,EAAOO,OAAOM,EAAQtC,UAAU1B,IAChCwD,EAAGP,UAAUU,EAAMR,EAAOU,cAAc/M,EAAGkJ,IAEtCmD,EAAOO,OAAOM,EAAQtC,WAAW1B,KACtCwD,EAAGP,UAAUU,EAAMR,EAAOS,cAAc9M,EAAGkJ,QAI3CiE,EAAMT,EAAG9B,UAAUiC,GACvBM,EAAIlB,KAAM,EACV1U,EAAK0U,KAAM,EACXkB,EAAIhQ,KAAK8O,KAAM,EACfkB,EAAI/P,MAAM6O,KAAM,OAnBhBjM,EAAEiM,KAAM,EACRiB,EAAQjB,KAAM,EACd1U,EAAK0U,KAAM,UAyBjB,OAAVe,IACAA,EAAM5C,KAAO7S,EAAK6S,KAClBpK,EAAEmM,UAAUnM,EAAE5C,QAAU7F,EAAMA,EAAKqT,UAAwB,OAAdrT,EAAK4F,YAC7C0N,aAIJP,MAAQkC,EAAKpP,MACC,OAAf9G,KAAKgU,aACAA,MAAM2B,KAAM,GAGJ,OAAVe,KAGJJ,OAAP,SAAcrV,UACM,OAATA,GAAiBA,EAAK0U,OAG1Ba,cAAP,SAAqBnB,EAAMO,OACnBL,EAAOF,EAAKf,WAAWsB,UAE3BP,EAAKQ,WAAWD,EAAKL,EAAKjB,UAAUsB,IACpCL,EAAKM,UAAUD,EAAKP,GAEpBA,EAAKM,KAAM,EACXJ,EAAKI,KAAM,EAEJJ,KAGJkB,cAAP,SAAqBpB,EAAMO,UACvBP,EAAKQ,WAAWD,EAAKG,EAAOS,cAAcnB,EAAKf,WAAWsB,IAAOA,IAC1DG,EAAOS,cAAcnB,EAAMO,OAnMX/B,YC3QfiD,EAAmBtT,UAC/BA,EAAEuT,YAA6B,IAAbvT,EAAExC,OAChBwC,EAAExC,OAAOgW,QAAO,SAAC3L,EAAchG,UAAMA,EAAE0R,OAAOE,MAAM5L,KAAI6L,EAAUC,SAClED,EAAUC,aACU,IAAb3T,EAAEpC,SACToC,EAAEuT,OAAoBvT,EAAEpC,OAAO4V,QAAO,SAAC3L,EAAchG,UAAMyR,EAAmBzR,GAAG4R,MAAM5L,KAAI7H,EAAEuT,SACjGvT,EAAEuT,OAASvT,EAAEuT,OAAOK,QAAQ5T,EAAE6T,SACvB7T,EAAEuT,WAGAG,wBAEEtP,EACA0P,EACAC,EACAC,UAHA5P,SACA0P,SACAC,SACAC,IAEJL,MAAP,kBAAmC,IAAID,EAAUnS,OAAO0S,kBAAmB1S,OAAO2S,kBAAmB3S,OAAO0S,kBAAmB1S,OAAO2S,+CAEtIC,GAAA,kBAAuB3X,KAAK4H,EAAI5H,KAAKsX,GAAK,KAE1CM,GAAA,kBAAuB5X,KAAKuX,EAAIvX,KAAKwX,GAAK,KAE1CK,SAAA,SAASxM,OACDyM,EAAK9X,KAAK2X,KAAMI,EAAK1M,EAAEsM,YACvBG,GAAMC,GAAM1M,EAAEzD,EAAI5H,KAAKsX,EAAUtX,KAAKsX,EAAIjM,EAAEzD,EAC5CmQ,GAAMD,GAAM9X,KAAK4H,EAAIyD,EAAEiM,EAAUjM,EAAEiM,EAAItX,KAAK4H,EACzC,KAGXoQ,SAAA,SAAS3M,OACD4M,EAAKjY,KAAK4X,KAAMM,EAAK7M,EAAEuM,YACvBK,GAAMC,GAAM7M,EAAEkM,EAAIvX,KAAKwX,EAAUxX,KAAKwX,EAAInM,EAAEkM,EAC5CW,GAAMD,GAAMjY,KAAKuX,EAAIlM,EAAEmM,EAAUnM,EAAEmM,EAAIxX,KAAKuX,EACzC,KAGXY,WAAA,SAAWR,OACH3K,EAAK2K,EAAK3X,KAAK2X,UACd/P,GAAKoF,OACLsK,GAAKtK,KAGdoL,WAAA,SAAWR,OACHS,EAAKT,EAAK5X,KAAK4X,UACdL,GAAKc,OACLb,GAAKa,KAGdC,MAAA,kBACWtY,KAAKsX,EAAItX,KAAK4H,KAGzB2Q,OAAA,kBACWvY,KAAKwX,EAAIxX,KAAKuX,KAGzBN,MAAA,SAAM5L,UACK,IAAI6L,EAAUhR,KAAKG,IAAIrG,KAAK4H,EAAGyD,EAAEzD,GAAI1B,KAAKuI,IAAIzO,KAAKsX,EAAGjM,EAAEiM,GAAIpR,KAAKG,IAAIrG,KAAKuX,EAAGlM,EAAEkM,GAAIrR,KAAKuI,IAAIzO,KAAKwX,EAAGnM,EAAEmM,OAYjHgB,kBAAA,SAAkBC,EAAYC,EAAYC,EAAYC,WAC9CC,EAAQ,CAAC,CAAC7Y,KAAK4H,EAAG5H,KAAKuX,EAAGvX,KAAKsX,EAAGtX,KAAKuX,GACnC,CAACvX,KAAKsX,EAAGtX,KAAKuX,EAAGvX,KAAKsX,EAAGtX,KAAKwX,GAC9B,CAACxX,KAAKsX,EAAGtX,KAAKwX,EAAGxX,KAAK4H,EAAG5H,KAAKwX,GAClC,CAACxX,KAAK4H,EAAG5H,KAAKwX,EAAGxX,KAAK4H,EAAG5H,KAAKuX,IAC9BuB,EAAgB,GACXhZ,EAAI,EAAGA,EAAI,IAAKA,EAAG,KACpBuL,EAAI6L,EAAU6B,iBAAiBN,EAAIC,EAAIC,EAAIC,EAAIC,EAAM/Y,GAAG,GAAI+Y,EAAM/Y,GAAG,GAAI+Y,EAAM/Y,GAAG,GAAI+Y,EAAM/Y,GAAG,IACzF,OAANuL,GAAYyN,EAAclZ,KAAK,CAAEgI,EAAGyD,EAAEzD,EAAG2P,EAAGlM,EAAEkM,WAE/CuB,KAWXE,gBAAA,SAAgBL,EAAYC,OACpBK,EAAOjZ,KAAKwY,kBAAkBxY,KAAK2X,KAAM3X,KAAK4X,KAAMe,EAAIC,UACrDK,EAAK9Y,OAAS,EAAI8Y,EAAK,GAAK,QAGvCC,SAAA,iBACW,CACH,CAAEtR,EAAG5H,KAAK4H,EAAG2P,EAAGvX,KAAKuX,GACrB,CAAE3P,EAAG5H,KAAKsX,EAAGC,EAAGvX,KAAKuX,GACrB,CAAE3P,EAAG5H,KAAKsX,EAAGC,EAAGvX,KAAKwX,GACrB,CAAE5P,EAAG5H,KAAK4H,EAAG2P,EAAGvX,KAAKwX,OAGtBuB,iBAAP,SACIN,EAAYC,EACZC,EAAYC,EACZO,EAAYC,EACZC,EAAYC,OACRC,EAAOZ,EAAKF,EAAIe,EAAOH,EAAKF,EAC5BM,EAAOb,EAAKF,EAAIgB,EAAOJ,EAAKF,EAC5BO,EAAcD,EAAOH,EAAOC,EAAOC,KACpB,GAAfE,EAAkB,OAAO,SACzBC,EAAOnB,EAAKU,EAAIU,EAAOnB,EAAKU,EAE5BxX,GADO4X,EAAOK,EAAOH,EAAOE,GACjBD,EAEX9X,GADO0X,EAAOM,EAAOJ,EAAOG,GACjBD,SACX/X,GAAK,GAAKA,GAAK,GAAKC,GAAK,GAAKA,GAAK,EAC5B,CACH+F,EAAG6Q,EAAK7W,EAAI2X,EACZhC,EAAGmB,EAAK9W,EAAI6X,GAGb,QAGXrC,QAAA,SAAQ0C,UACG,IAAI5C,EAAUlX,KAAK4H,EAAIkS,EAAK9Z,KAAKsX,EAAIwC,EAAK9Z,KAAKuX,EAAIuC,EAAK9Z,KAAKwX,EAAIsC,kBAehEC,EAAgB/a,EAAmBC,EAAmB+a,OAE5DC,EAAKjb,EAAOga,gBAAgB/Z,EAAO0Y,KAAM1Y,EAAO2Y,OAAS,CAAEhQ,EAAG5I,EAAO2Y,KAAMJ,EAAGvY,EAAO4Y,MACvFsC,EAAKjb,EAAO+Z,gBAAgBha,EAAO2Y,KAAM3Y,EAAO4Y,OAAS,CAAEhQ,EAAG3I,EAAO0Y,KAAMJ,EAAGtY,EAAO2Y,MACrF5K,EAAKkN,EAAGtS,EAAIqS,EAAGrS,EACfyQ,EAAK6B,EAAG3C,EAAI0C,EAAG1C,EACfxR,EAAIG,KAAKC,KAAK6G,EAAKA,EAAKqL,EAAKA,GAAK8B,EAAKpU,EAAIiU,QACxC,CACHI,mBAAoBH,EACpBI,mBAAoBH,EACpBI,WAAY,CAAE1S,EAAGqS,EAAGrS,EAAIuS,EAAKnN,EAAKjH,EAAGwR,EAAG0C,EAAG1C,EAAI4C,EAAK9B,EAAKtS,aAajDwU,EAAWja,EAA6BrB,EAAmB+a,OACnEE,EAAKjb,EAAO+Z,gBAAgB1Y,EAAEsH,EAAGtH,EAAEiX,GAClC2C,IAAIA,EAAK,CAAEtS,EAAG3I,EAAO0Y,KAAMJ,EAAGtY,EAAO2Y,WACtC5K,EAAKkN,EAAGtS,EAAItH,EAAEsH,EACdyQ,EAAK6B,EAAG3C,EAAIjX,EAAEiX,EACdxR,EAAIG,KAAKC,KAAK6G,EAAKA,EAAKqL,EAAKA,SAC1B,CAAEzQ,EAAGsS,EAAGtS,EAAIoS,EAAKhN,EAAKjH,EAAGwR,EAAG2C,EAAG3C,EAAIyC,EAAK3B,EAAKtS,OAGlD2P,EAIF,SAAmBnR,EAAoB8G,EAAqBmP,UAAzCjW,SAAoB8G,WAAqBmP,OACnDvK,KAAOwK,SACPtK,KAAOsK,KAIdC,EACF,SAAmBC,EAAwBpW,EAAgBiW,eAAxCG,SAAwBpW,WAAgBiW,GAG/D,SAASI,EAAchZ,EAAUC,UACzBD,EAAE4Y,IAAM3Y,EAAE2Y,IACH,EAEP5Y,EAAE4Y,IAAM3Y,EAAE2Y,KAGV5Y,EAAE+Y,QAFM,EAMR9Y,EAAE8Y,OAEK,EAEJ,EAGX,SAASF,WACE,IAAI1E,GAAa,SAACnU,EAAGC,UAAMD,EAAE4Y,IAAM3Y,EAAE2Y,OAYhD,IAAIK,EAAuB,CACvBC,UAAW,SAAAzP,UAAIA,EAAEsM,MACjBoD,QAAS,SAAA1P,UAAIA,EAAEkM,GACfyD,SAAU,SAAA3P,UAAIA,EAAEmM,GAChByD,QAAS,SAAA5P,UAAIA,EAAEiN,SACf4C,SAAU,SAACC,EAAMC,EAAOC,EAAQ9G,UAAS,IAAI2C,EAAUmE,EAAS9G,EAAO,EAAG8G,EAAS9G,EAAO,EAAG4G,EAAMC,IACnGE,eAiGJ,SAAyB/W,EAASgX,OAC1B7W,EAAI,SAAC8W,EAASC,WAEVhW,EADAuP,EAAKuG,EAASG,SAASnX,GAEI,QAAvBkB,EAAIuP,EAAGwG,OAAsB,KAC7BG,EAAUlW,EAAE4F,EAAEwM,SAAStT,EAAE8G,OACzBsQ,GAAW,GAAKA,GAAWlW,EAAE4F,EAAE2M,SAASzT,EAAE8G,MAC1C9G,EAAEiX,GAAS7I,OAAOlN,GAClBA,EAAEgW,GAAS9I,OAAOpO,IAElBoX,GAAW,UAKvBjX,EAAE,OAAQ,QACVA,EAAE,OAAQ,UA9GVkX,EAAuB,CACvBd,UAAW,SAAAzP,UAAIA,EAAEuM,MACjBmD,QAAS,SAAA1P,UAAIA,EAAEzD,GACfoT,SAAU,SAAA3P,UAAIA,EAAEiM,GAChB2D,QAAS,SAAA5P,UAAIA,EAAEkN,UACf2C,SAAU,SAACC,EAAMC,EAAOC,EAAQ9G,UAAS,IAAI2C,EAAUiE,EAAMC,EAAOC,EAAS9G,EAAO,EAAG8G,EAAS9G,EAAO,IACvG+G,eA2GJ,SAAyB/W,EAASgX,OAC1B7W,EAAI,SAAC8W,EAASC,OACVhW,EAAI8V,EAASG,SAASnX,GAAGiX,KACnB,OAAN/V,GAAcA,EAAE4F,EAAEwM,SAAStT,EAAE8G,GAAK,IAClC9G,EAAEiX,GAAS7I,OAAOlN,GAClBA,EAAEgW,GAAS9I,OAAOpO,KAG1BG,EAAE,OAAQ,QACVA,EAAE,OAAQ,UAjHd,SAASmX,EAAyBxG,EAAuB3Q,EAAkBoX,EAAgBC,YAAAA,IAAAA,GAAuB,OAE1G1E,EAAUhC,EAAKgC,QACf5M,OAA4B,IAAhB4K,EAAKjU,OAAyBiU,EAAKjU,OAAOjB,OAAS,EAC/D6b,OAA4B,IAAhB3G,EAAKrU,OAAyBqU,EAAKrU,OAAOb,OAAS,EAC/D8b,EAAkCxR,EAChC4K,EAAKjU,OAAO4V,QAAO,SAACkF,EAAmB1Y,UAAM0Y,EAAIC,OAAON,EAAyBrY,EAAGkB,EAAGoX,GAAQ,MAAQ,IADlE,GAEvC1c,GAAK2c,EAAc,EAAI,GAAKC,EAAKvR,EACjC7F,EAAiB,IAAInF,MAAML,GAC3ByD,EAAkB,IAAIpD,MAAML,GAC5BU,EAAI,EACJC,EAAM,SAACsL,EAAG9G,GAAQ1B,EAAG/C,GAAKuL,EAAGzG,EAAG9E,KAAOyE,MACvCwX,EAAa,KAETla,EAAewT,EAAK0B,OACpB1R,EAAIX,EAAEoW,UAAUjZ,GAAIvB,EAAIoE,EAAEuW,QAAQpZ,GAAK,EACvCsZ,EAAOzW,EAAEqW,QAAQlZ,GAAIuZ,EAAQ1W,EAAEsW,SAASnZ,GACxCwE,EAAMhB,EAAI/E,EAAI+W,EAAU,EAAG5I,EAAMpJ,EAAI/E,EAAI+W,EAAU,EACvDhC,EAAK+G,OAAOjN,gBAAkB9I,EAC9BtG,EAAI2E,EAAEwW,SAASC,EAAMC,EAAO/U,EAAKgR,GAAUhC,EAAK+G,QAChD/G,EAAKgH,OAAOlN,gBAAkBV,EAC9B1O,EAAI2E,EAAEwW,SAASC,EAAMC,EAAO3M,EAAK4I,GAAUhC,EAAKgH,QAEhDL,GAAI3G,EAAKrU,OAAOZ,SAAQ,SAAA2F,UAAKhG,EAAIgG,EAAEgR,OAAQhR,EAAEuW,aAC7C7R,GAAI4K,EAAKjU,OAAOhB,SAAQ,SAAAoD,OACpB3B,EAAe2B,EAAEuT,OACrBhX,EAAI2E,EAAEwW,SAASxW,EAAEqW,QAAQlZ,GAAI6C,EAAEsW,SAASnZ,GAAI6C,EAAEoW,UAAUjZ,GAAI6C,EAAEuW,QAAQpZ,IAAK2B,EAAE4Y,eAE7EjJ,EAAKoJ,EAAoB1Z,EAAI+B,EAAIF,EAAGoX,UACpCrR,IACA7F,EAAGxE,SAAQ,SAAAmE,GAAOA,EAAE8L,KAAO,GAAI9L,EAAE+L,IAAM,MACvC6C,EAAG/S,SAAQ,SAAAiF,GAAOA,EAAEwB,KAAKwJ,KAAKzQ,KAAKyF,GAAIA,EAAEyB,MAAMwJ,IAAI1Q,KAAKyF,MACxDgQ,EAAKjU,OAAOhB,SAAQ,SAAAoD,OACZgZ,GAAiBhZ,EAAE6T,QAAU3S,EAAEuW,QAAQzX,EAAEuT,SAAW,EACxDvT,EAAE4Y,OAAO9L,IAAIlQ,SAAQ,SAAAiF,UAAKA,EAAE0B,KAAOyV,KACnChZ,EAAE4Y,OAAO/L,KAAKjQ,SAAQ,SAAAiF,GAAOA,EAAEwB,KAAOrD,EAAE6Y,OAAQhX,EAAE0B,KAAOyV,SAG1DP,EAAiBE,OAAOhJ,GAGnC,SAASoJ,EAAoB1Z,EAAiB2N,EAC1CiM,EAAqBX,OAEjBhc,EAAGV,EAAIyD,EAAG1C,OACVuc,EAAI,EAAItd,EACZud,QAAQC,OAAOpM,EAAKrQ,QAAUf,OAC1Byd,EAAS,IAAIpd,MAAaid,OACzB5c,EAAI,EAAGA,EAAIV,IAAKU,EAAG,KAChBuL,EAAIxI,EAAG/C,GACPyE,EAAI,IAAImR,EAAKlF,EAAK1Q,GAAIuL,EAAGoR,EAAK3B,UAAUzP,IAC5CwR,EAAO/c,GAAK,IAAI4a,GAAM,EAAMnW,EAAGkY,EAAK1B,QAAQ1P,IAC5CwR,EAAO/c,EAAIV,GAAK,IAAIsb,GAAM,EAAOnW,EAAGkY,EAAKzB,SAAS3P,IAEtDwR,EAAO1Z,KAAKyX,OACRzH,EAAK,IAAI1T,MACT8b,EAAWd,QACV3a,EAAI,EAAGA,EAAI4c,IAAK5c,EAAG,KAChBO,EAAIwc,EAAO/c,MACXyE,EAAIlE,EAAEkE,EACNlE,EAAEsa,OACFY,EAAS5I,OAAOpO,GAChBkY,EAAKnB,eAAe/W,EAAGgX,OACpB,CAEHA,EAAS7Y,OAAO6B,OACZuY,EAAiB,SAAC/W,EAAGsF,OACjB0R,GAAON,EAAKxB,QAAQlV,EAAEsF,GAAKoR,EAAKxB,QAAQ5P,EAAEA,IAAM,EAAIyQ,EACxD3I,EAAGvT,KAAK,IAAI0P,EAAWvJ,EAAExB,EAAG8G,EAAE9G,EAAGwY,KAEjC/M,EAAkB,SAACwL,EAASC,EAASuB,WACjCvX,EAAGuP,EAAKzQ,EAAEiX,GAAStH,WACQ,QAAvBzO,EAAIuP,EAAGwG,OACXwB,EAAMvX,EAAGlB,GACTkB,EAAEgW,GAAS/Y,OAAO6B,IAG1ByL,EAAgB,OAAQ,QAAQ,SAACvK,EAAGlB,UAAMuY,EAAerX,EAAGlB,MAC5DyL,EAAgB,OAAQ,QAAQ,SAACvK,EAAGlB,UAAMuY,EAAevY,EAAGkB,cAGpEkX,QAAQC,OAAyB,IAAlBrB,EAAShH,MACjBpB,WAkCK8J,EAAqBpa,EAAiB2N,UAC3C+L,EAAoB1Z,EAAI2N,EAAMqK,EAAO,eAGhCqC,EAAqBra,EAAiB2N,UAC3C+L,EAAoB1Z,EAAI2N,EAAMoL,EAAO,eAGhCuB,EAA0B9H,UAC/BwG,EAAyBxG,EAAMwF,EAAO,eAGjCuC,EAA0B/H,UAC/BwG,EAAyBxG,EAAMuG,EAAO,UA2BpCyB,yBACUnW,EAAevB,8BACxB,EAAGA,gBADMuB,qBADcyI,GAMxB2N,wBAKWpY,EACR9D,EACA7B,EACRmH,EACQ6W,0BAFAhe,IAAAA,EAA6B,eACrCmH,IAAAA,EAAoB,eACZ6W,IAAAA,GAAyB,cAJjBrY,cACR9D,iBACA7B,qBAEAge,OAEHC,UAAYtY,EAAMwC,KAAI,SAACnD,EAAGzE,UACpByE,EAAE+X,SAAW,IAAIe,EAAgBvd,EAAG,MAG3C4G,GAAa1G,KAAKyd,kBAAkB/W,GAEpC6W,GAAiBhe,QAAyC,IAArBA,EAAU6B,OAAwB,CACvE8D,EAAM9E,SAAQ,SAAAmE,MACpBA,EAAE+T,OAAU/T,EAAEgU,YAMAmF,EAAKnZ,EAAE+T,MAAQ,EAAGqF,EAAKpZ,EAAEgU,OAAS,EACtChU,EAAEwS,OAAS,IAAIG,EAAU3S,EAAEqD,EAAI8V,EAAInZ,EAAEqD,EAAI8V,EAAInZ,EAAEgT,EAAIoG,EAAIpZ,EAAEgT,EAAIoG,QAJ3EpZ,EAAEwS,OAAS,IAAIG,EAAU3S,EAAEqD,EAAGrD,EAAEqD,EAAGrD,EAAEgT,EAAGhT,EAAEgT,MAMhCT,EAAmBvX,OACfO,EAAIoF,EAAM/E,OACdiB,EAAOhB,SAAQ,SAAAoD,GACXK,EAAK2Z,UAAU1d,GAAK0D,EAAE4Y,OAAS,IAAIiB,EAAgBvd,SAA4B,IAAhB0D,EAAEoa,UAA4Bpa,EAAEoa,UAAY,KAC3G/Z,EAAK2Z,UAAU1d,GAAK0D,EAAE6Y,OAAS,IAAIgB,EAAgBvd,SAA4B,IAAhB0D,EAAEoa,UAA4Bpa,EAAEoa,UAAY,oCAM/GC,iBAAA,SAAiBxY,UACd,IAAIiK,EACPtP,KAAKkF,MAAMG,EAAEwB,MAAMyV,SACnBtc,KAAKkF,MAAMG,EAAEyB,OAAOwV,SACpBjX,EAAE0B,SACoB,IAAf1B,EAAEkK,UAA2BlK,EAAEkK,aAItCuO,aAAA,SAAazY,iBACZrF,KAAKud,mBAENhX,EAAO,IAAKwX,EAAM,QACP,MAAX1Y,EAAEkB,OAAcA,EAAO,IAAKwX,EAAM,cAClCnZ,EAAkBS,EAAE2Y,QAAQtW,KAAI,SAAArF,UAAK4B,EAAKiB,MAAM7C,EAAEpB,SAAOkC,MAAK,SAACvB,EAAGC,UAAMD,EAAE2E,GAAQ1E,EAAE0E,MACpFmD,EAAe,KACnB9E,EAAGxE,SAAQ,SAAAmE,MAEHmF,EAAG,KACCuU,EAAUvU,EAAEnD,GAAQmD,EAAEqU,GACtBE,EAAU1Z,EAAEgC,KACZhC,EAAEgC,GAAQ0X,GAGlBvU,EAAInF,SAIJ2Z,gBAAA,SAAgB7Y,cAChBI,EAAIzF,KAAKkF,MAAMG,EAAE2Y,QAAQ,GAAG/c,MAAMqb,cACjCwB,aAAazY,OACd8N,EAAgB,MAAX9N,EAAEkB,KAAevG,KAAKme,aAAene,KAAKoe,aACnD/Y,EAAE2Y,QAAQ1U,MAAM,GAAGlJ,SAAQ,SAAAiC,GAEvB8Q,EAAGvT,KAAK,IAAI0P,EAAW7J,EADfqH,EAAK5H,MAAM7C,EAAEpB,MAAMqb,SACEja,EAAE4M,QAAQ,UAIvCwO,kBAAA,SAAkB/W,cAClB2X,EAAQ,SAAAhZ,eAAuB,IAAXA,EAAEnG,MAAmC,eAAXmG,EAAEnG,WAC/Cif,aAAezX,EACf4X,QAAO,SAAAjZ,SAAgB,MAAXA,EAAEkB,MAAgB8X,EAAMhZ,MACpCqC,KAAI,SAAArC,UAAKuI,EAAKiQ,iBAAiBxY,WAC/B+Y,aAAe1X,EACf4X,QAAO,SAAAjZ,SAAgB,MAAXA,EAAEkB,MAAgB8X,EAAMhZ,MACpCqC,KAAI,SAAArC,UAAKuI,EAAKiQ,iBAAiBxY,MACpCqB,EACK4X,QAAO,SAAAjZ,SAAgB,cAAXA,EAAEnG,QACdkB,SAAQ,SAAAiF,UAAKuI,EAAKsQ,gBAAgB7Y,SAGnCkZ,wBAAA,SAAwBvS,EAAkBwS,EAAkBC,EAAuBC,QAClFxZ,MAAM9E,SAAQ,SAACmE,EAAGzE,GACfyE,EAAEoa,OACFpa,EAAE+X,SAASvN,OAASxK,EAAEqa,YAAcra,EAAEqa,YAAc,IACpDH,EAAQ3e,GAAK4e,EAAWna,IAExBA,EAAE+X,SAASvN,OAAS,MAEpBpJ,GAAKpB,EAAE+T,OAAS,GAAK,EAAGuG,GAAKta,EAAEgU,QAAU,GAAK,EAC9CuG,EAAK9S,EAAGlM,GAAIif,EAAKP,EAAG1e,GACxByE,EAAEwS,OAAS,IAAIG,EAAU4H,EAAKnZ,EAAGmZ,EAAKnZ,EAAGoZ,EAAKF,EAAGE,EAAKF,SAI9DG,SAAA,SAAShT,EAAkBwS,EAAkB5W,IACpC5H,KAAKT,WAAeS,KAAKud,eAAiBvd,KAAKme,oBAC/CjS,QAAQF,EAAIwS,EAAIxS,EAAIpE,GAAG,SAAArD,UAAIA,EAAE0a,KAAIjf,KAAKme,aAAchB,GACrD,SAAA5Y,UAAKA,EAAEwS,OAAOoB,WAAWvQ,EAAoBrD,EAAE+X,SAAUpV,OAAS3C,EAAE+X,SAAS5M,eAC7E,SAAAlM,OACQ0b,EAAOtX,EAAoBpE,EAAE4Y,OAAQlV,OAAS1D,EAAE4Y,OAAO1M,WACvDyP,EAAOvX,EAAoBpE,EAAE6Y,OAAQnV,OAAS1D,EAAE6Y,OAAO3M,WACvD0P,EAAK5b,EAAE6T,QAAU,EACrB7T,EAAEuT,OAAOnP,EAAIsX,EAAOE,EACpB5b,EAAEuT,OAAOO,EAAI6H,EAAOC,QAIhCC,SAAA,SAASrT,EAAkBwS,EAAkBjH,IACpCvX,KAAKT,WAAcS,KAAKoe,oBACxBlS,QAAQF,EAAIwS,EAAIA,EAAIjH,GAAG,SAAAhT,UAAIA,EAAE+a,KAAItf,KAAKoe,aAAchB,GACrD,SAAA7Y,UAAKA,EAAEwS,OAAOqB,WAAWb,EAAoBhT,EAAE+X,SAAUpV,OAAS3C,EAAE+X,SAAS5M,eAC7E,SAAAlM,OACQ+b,EAAOhI,EAAoB/T,EAAE4Y,OAAQlV,OAAS1D,EAAE4Y,OAAO1M,WACvD8P,EAAOjI,EAAoB/T,EAAE6Y,OAAQnV,OAAS1D,EAAE6Y,OAAO3M,WACvD0P,EAAK5b,EAAE6T,QAAU,EACrB7T,EAAEuT,OAAOQ,EAAIgI,EAAOH,EACpB5b,EAAEuT,OAAOS,EAAIgI,EAAOJ,QAIhCK,iBAAA,4BACW,CACH,SAACzT,EAAIwS,EAAI5W,UAAMkG,EAAKkR,SAAShT,EAAIwS,EAAI5W,IACrC,SAACoE,EAAIwS,EAAIjH,UAAMzJ,EAAKuR,SAASrT,EAAIwS,EAAIjH,QAIrCrL,QAAA,SAAQF,EAAkBwS,EAAkB/I,EAAqBgJ,EACrEC,EACAvL,EACAoJ,EACAmD,EACAC,QAEKpB,wBAAwBvS,EAAIwS,EAAIC,EAASC,GAC1C1e,KAAKT,WAAaS,KAAKud,gBACvBzG,EAAmB9W,KAAKT,WACxB4T,EAAKA,EAAGgJ,OAAOI,EAAoBvc,KAAKT,kBAEvCoU,MAAM3T,KAAKwd,UAAWrK,EAAIsC,EAAOgJ,QACjCvZ,MAAM9E,QAAQsf,GACf1f,KAAKT,WAAaS,KAAKud,qBAClBnc,OAAOhB,QAAQuf,GACpB7I,EAAmB9W,KAAKT,eAIxBoU,MAAA,SAAM/O,EAAgBuO,EAAkByM,EAAwBnB,OAChEoB,EAAS,IAAI7M,EAAOpO,EAAIuO,GAC5B0M,EAAOzM,qBAAqBwM,GAC5BC,EAAOxM,oBAAoBoL,GAC3BoB,EAAOlM,cClkBNmM,wBAIUC,aAAAA,OACVC,SAAW,8BAGbC,SAAA,SAASC,WACRC,EAAM,GAAIC,GAAY,EACjBtgB,EAAI,EAAGA,EAAIE,KAAKggB,SAAS7f,SAAUL,EAAG,KACvCugB,EAA0BrgB,KAAKggB,SAASlgB,GACvCugB,EAAQN,MAITK,IACAD,GAAY,KAEhBA,GAAYE,EAAQJ,SAASC,GAC7BE,GAAY,GAPRA,GAAY,QASR,KAARD,IACAA,EAAM,IAAMA,EAAM,MAEdngB,KAAK+f,KAAOG,EAASlgB,KAAK+f,MAAQ,IAAMI,KAG7C/f,QAAA,SAAQsE,GACN1E,KAAKmX,UACNzS,EAAE1E,KAAK+f,KAAM/f,WACRggB,SAAS5f,SAAQ,SAAAE,UAAKA,EAAEF,QAAQsE,UAItC/B,MAAA,kBACI3C,KAAKmX,QAAU,EAAI,EAAInX,KAAKggB,SAAShJ,QAAO,SAAC5X,EAAWyf,UACpDzf,EAAIyf,EAAElc,UACd,MAGA0D,IAAA,kBACIrG,KAAK+f,QAGT5I,MAAA,kBACiB,MAAbnX,KAAK+f,QAGTtb,SAAA,SAASoa,MACR7e,OAAS6e,EAAG,OAAO,MAClB,IAAI/e,EAAI,EAAGA,EAAIE,KAAKggB,SAAS7f,OAAQL,OAClCE,KAAKggB,SAASlgB,GAAG2E,SAASoa,GAAI,OAAO,SAEtC,KAGJyB,OAAA,SAAOC,qBACHvgB,KAAKggB,SAASQ,OAAM,SAAA3B,UAAI0B,EAAShgB,EAAKwf,KAAMlB,EAAEkB,OAASlB,EAAEyB,OAAOC,SAGpE5N,OAAA,SAAO8N,EAASF,UACZvgB,KAAK2B,MAAM,IAAIme,EAAeW,GAAMF,MAGxC5e,MAAA,SAAM+e,EAAuBH,UAC5BvgB,KAAKmX,QAAgBuJ,EAChBA,EAAMvJ,QAAgBnX,KACtBugB,EAASvgB,KAAK+f,KAAMW,EAAMX,YAC1BC,SAASpgB,KAAK8gB,GACZ1gB,OAEP0gB,EAAMV,SAASpgB,KAAKI,MACb0gB,MAIRC,UAAA,SAAUJ,UACTvgB,KAAKmX,QAAgB,KACbnX,KAAK4gB,WAAWL,MAGzBK,WAAA,SAAWL,MACc,GAAxBvgB,KAAKggB,SAAS7f,OAAa,OAAO,IAAI2f,EAAe,MACpD,GAA4B,GAAxB9f,KAAKggB,SAAS7f,cAAsBH,KAAKggB,SAAS,OAEnDa,EAAY7gB,KAAKggB,SAASvY,MAAM9F,MAAM3B,KAAKggB,SAASvY,MAAO8Y,GAC3DO,EAAY9gB,KAAK4gB,WAAWL,UACzBM,EAAUlf,MAAMmf,EAAWP,MAGnCQ,YAAA,SAAYV,EAAyBW,EAAaC,EAA8CV,OAC/FW,EAAUb,EAAQM,UAAUJ,GAEhCF,EAAQN,KAAOmB,EAAQnB,KACvBM,EAAQL,SAAWkB,EAAQlB,SACP,OAAhBiB,GAAyC,OAAjBC,EAAQnB,MAChCkB,EAAYZ,EAAQN,KAAMM,OAE1Bc,EAAc,IAAIrB,EAAYkB,UACd,OAAhBC,GACAA,EAAYD,EAAUG,GAEnBnhB,KAAK2B,MAAMwf,EAAaZ,SAO1Ba,wBAEWb,iBAAAA,6BAKbc,IAAA,kBACCrhB,KAAKmX,QAAkB,KACpBnX,KAAKqV,KAAK0K,QAMdngB,KAAA,mBACCuhB,EACYG,EAAPxhB,EAAI,EAAQwhB,EAASxhB,uBAAAA,mBAAAA,KAAMA,EAChCqhB,EAAc,IAAIrB,EAAYwB,QACzBjM,KAAOrV,KAAKmX,QACbgK,EAAcnhB,KAAKqV,KAAK1T,MAAMwf,EAAanhB,KAAKugB,iBAEjDY,KAMJhK,MAAA,kBACKnX,KAAKqV,OAASrV,KAAKqV,KAAK0K,QAM7BO,OAAA,kBACItgB,KAAKqV,KAAKiL,OAAOtgB,KAAKugB,aAM1BngB,QAAA,SAAQsE,QACN2Q,KAAKjV,QAAQsE,MAKf+C,IAAA,cACCzH,KAAKmX,eACE,SAEPsJ,EAAMzgB,KAAKqV,KAAKhP,kBACfgP,KAAOrV,KAAKqV,KAAKsL,UAAU3gB,KAAKugB,UAC9BE,KAKJc,UAAA,SAAUC,EAA0BC,EAAWR,YAAAA,IAAAA,EAA+C,WAC5F5L,KAAOrV,KAAKqV,KAAK0L,YAAYS,EAAUC,EAAQR,EAAajhB,KAAKugB,aAEnEN,SAAA,SAASC,UACLlgB,KAAKqV,KAAK4K,SAASC,MAMvBvd,MAAA,kBACI3C,KAAKqV,KAAK1S,cCnLnB+e,EACF,SAAmBvgB,EAAmBwgB,WAAnBxgB,gBAAmBwgB,GAGpCjM,EACF,SAAmBvU,WAAAA,OACVyE,WAAa,IAQpBgc,EACF,SAAmB3gB,EAAmBgP,EAAyBxH,aAA5CxH,YAAmBgP,SAAyBxH,GAUtDoZ,yBAGUziB,EAAkB0E,EAAYtD,EAAqCE,EAAqCohB,UAAxG1iB,UAAkB0E,OAC5B8B,WAAa,IAAInG,MAAMO,KAAKZ,WAC7BU,EAAIE,KAAKZ,EAAUU,UAAU8F,WAAW9F,GAAK,IAAI4V,EAAK5V,OAE1DA,EAAIE,KAAK8D,GAAG3D,OAAeL,KAAK,KACxBO,EAAIL,KAAK8D,GAAGhE,GACZ2F,EAAYjF,EAAeH,GAAIkE,EAAY7D,EAAeL,GAC1DoI,EAAIqZ,EAAUzhB,QACbuF,WAAWH,GAAGG,WAAWhG,KAAK,IAAI8hB,EAAUnd,EAAGkE,SAC/C7C,WAAWrB,GAAGqB,WAAWhG,KAAK,IAAI8hB,EAAUjc,EAAGgD,gCAY5DsZ,eAAA,mBACQ7Z,EAAI,IAAIzI,MAAMO,KAAKZ,GACdU,EAAI,EAAGA,EAAIE,KAAKZ,IAAKU,EAC1BoI,EAAEpI,GAAKE,KAAKgiB,mBAAmBliB,UAE5BoI,KASX+Z,kBAAA,SAAkBxM,UACPzV,KAAKgiB,mBAAmBvM,MAGnCyM,mBAAA,SAAmBzM,EAAelQ,UACvBvF,KAAKgiB,mBAAmBvM,EAAOlQ,MAM1C4c,+BAAA,SACI1M,EACAlQ,EACA6c,OAEIC,EAAI,IAAIjB,GAA0B,SAACxf,EAAGC,UAAMD,EAAE6G,GAAK5G,EAAE4G,KACrDhD,EAAUzF,KAAK4F,WAAW6P,GAC1B6M,EAAiB,IAAIV,EAAWnc,EAAE,KAAK,GACvC8c,EAAc,OAClBF,EAAEziB,KAAK0iB,IACAD,EAAElL,UAEL1R,GADA6c,EAAKD,EAAE5a,OACAxG,MACDE,KAAOoE,WAGTzF,EAAI2F,EAAEG,WAAWzF,OAAeL,KAAK,KACjC0iB,EAAY/c,EAAEG,WAAW9F,GACzByE,EAAIvE,KAAK4F,WAAW4c,EAAUrhB,QAG9BmhB,EAAGrS,MAAQ1L,EAAEpD,KAAOmhB,EAAGrS,KAAKhP,KAAKE,QAIjCshB,EAASle,EAAEpD,GAAK,IAAMsE,EAAEtE,QACzBshB,KAAUF,GAAeA,EAAYE,IAAWH,EAAG7Z,QAGlDia,EAAKJ,EAAGrS,KAAOmS,EAASE,EAAGrS,KAAKhP,KAAKE,GAAIsE,EAAEtE,GAAIoD,EAAEpD,IAAM,EACvDV,EAAI6hB,EAAG7Z,EAAI+Z,EAAUb,SAAWe,EAGpCH,EAAYE,GAAUhiB,EACtB4hB,EAAEziB,KAAK,IAAIgiB,EAAWrd,EAAG+d,EAAI7hB,cAGjCkiB,EAAgB,GACbL,EAAGrS,MAEN0S,EAAK/iB,MADL0iB,EAAKA,EAAGrS,MACKhP,KAAKE,WAEfwhB,KAGHX,mBAAA,SAAmBvM,EAAemN,YAAAA,IAAAA,GAAgB,WAClDP,EAAI,IAAIjB,GAAoB,SAACxf,EAAGC,UAAMD,EAAE6G,GAAK5G,EAAE4G,KAC/C3I,EAAIE,KAAK4F,WAAWzF,OACpBsI,EAAc,IAAIhJ,MAAMK,GACrBA,KAAK,KACJmB,EAAajB,KAAK4F,WAAW9F,GACjCmB,EAAKwH,EAAI3I,IAAM2V,EAAQ,EAAI1Q,OAAO0S,kBAClCxW,EAAKohB,EAAIA,EAAEziB,KAAKqB,SAEZohB,EAAElL,SAAS,KAEX1R,EAAI4c,EAAE5a,SACVgB,EAAEhD,EAAEtE,IAAMsE,EAAEgD,EACRhD,EAAEtE,KAAOyhB,EAAM,SACXD,EAAiB,GACjBpe,EAAIkB,OACiB,IAAXlB,EAAE0L,MACZ0S,EAAK/iB,KAAK2E,EAAE0L,KAAK9O,IACjBoD,EAAIA,EAAE0L,YAEH0S,MAEX7iB,EAAI2F,EAAEG,WAAWzF,OAAeL,KAAK,KAC7B0iB,EAAY/c,EAAEG,WAAW9F,GAEzBW,GADA8D,EAAIvE,KAAK4F,WAAW4c,EAAUrhB,IAC1BsE,EAAEgD,EAAI+Z,EAAUb,UACpBlc,EAAEgD,IAAM1D,OAAO+D,WAAavE,EAAEkE,EAAIhI,IAClC8D,EAAEkE,EAAIhI,EACN8D,EAAE0L,KAAOxK,EACT4c,EAAEd,UAAUhd,EAAE8d,EAAG9d,GAAG,SAAClE,EAAEgiB,UAAIhiB,EAAEgiB,EAAIA,cAItC5Z,QCzJEoa,gBAKAC,GACT,SAAmBrK,EAAmBC,EAAmBC,EAAmBC,WAAzDH,UAAmBC,UAAmBC,UAAmBC,GAGnEmK,kFAAkBF,aAUfG,GAAOC,EAAWC,EAAWC,UACjCD,EAAGtb,EAAIqb,EAAGrb,IAAMub,EAAG5L,EAAI0L,EAAG1L,IAAM4L,EAAGvb,EAAIqb,EAAGrb,IAAMsb,EAAG3L,EAAI0L,EAAG1L,GAGtE,SAAS6L,GAAM1Z,EAAU9C,EAAWyc,UACzBL,GAAOtZ,EAAG9C,EAAIyc,GAAM,EAG/B,SAASC,GAAM5Z,EAAU9C,EAAWyc,UACzBL,GAAOtZ,EAAG9C,EAAIyc,GAAM,EAiH/B,SAASE,GAAoBC,EAAUC,OAI/B7hB,EAAWC,EAAWwD,EACRqe,EAJdtkB,EAAIqkB,EAAEtjB,OAAS,KAQfmjB,GAAME,EAAGC,EAAE,GAAIA,EAAE,MAAQL,GAAMI,EAAGC,EAAErkB,EAAI,GAAIqkB,EAAE,IAC9C,OAAO,MAEN7hB,EAAI,EAAGC,EAAIzC,IAAM,IACdyC,EAAID,GAAM,EACV,OAAIwhB,GAAMI,EAAGC,EAAE7hB,GAAI6hB,EAAE5hB,IACVD,EAEAC,MAGf6hB,EAAMJ,GAAME,EAAGC,GADfpe,EAAIa,KAAKyd,OAAO/hB,EAAIC,GAAK,IACJ,GAAI4hB,EAAEpe,OACf+d,GAAMI,EAAGC,EAAEpe,EAAI,GAAIoe,EAAEpe,IAC7B,OAAOA,EAIL+d,GAAMI,EAAGC,EAAE7hB,EAAI,GAAI6hB,EAAE7hB,IAEnB8hB,GAGIN,GAAMI,EAAGC,EAAE7hB,GAAI6hB,EAAEpe,IAFrBxD,EAAIwD,EAKAzD,EAAIyD,EAIPqe,GAGGJ,GAAME,EAAGC,EAAE7hB,GAAI6hB,EAAEpe,IACjBxD,EAAIwD,EAHRzD,EAAIyD,GAiBpB,SAASue,GAAoBJ,EAAUC,OAG/B7hB,EAAWC,EAAWwD,EACRqe,EAHdtkB,EAAIqkB,EAAEtjB,OAAS,KAOfijB,GAAMI,EAAGC,EAAErkB,EAAI,GAAIqkB,EAAE,MAAQH,GAAME,EAAGC,EAAE,GAAIA,EAAE,IAC9C,OAAO,MAEN7hB,EAAI,EAAGC,EAAIzC,IAAM,IACdyC,EAAID,GAAM,EACV,OAAI0hB,GAAME,EAAGC,EAAE7hB,GAAI6hB,EAAE5hB,IACVD,EAEAC,KAGf6hB,EAAMJ,GAAME,EAAGC,GADfpe,EAAIa,KAAKyd,OAAO/hB,EAAIC,GAAK,IACJ,GAAI4hB,EAAEpe,IACvB+d,GAAMI,EAAGC,EAAEpe,EAAI,GAAIoe,EAAEpe,MAAQqe,EAC7B,OAAOre,EAILie,GAAME,EAAGC,EAAE7hB,EAAI,GAAI6hB,EAAE7hB,IAElB8hB,EAGGJ,GAAME,EAAGC,EAAE7hB,GAAI6hB,EAAEpe,IACjBxD,EAAIwD,EAEJzD,EAAIyD,EALRxD,EAAIwD,EASJqe,EACA9hB,EAAIyD,EAEA+d,GAAMI,EAAGC,EAAE7hB,GAAI6hB,EAAEpe,IACjBxD,EAAIwD,EAEJzD,EAAIyD,YAaRwe,GAAkBJ,EAAYK,EAAYC,EAAsCC,EAAsCC,EAAiDC,OAC/KC,EAAaC,EAIjBA,EAAMJ,EAAGP,EADTU,EAAMJ,EAAGD,EAAE,GAAIL,IACEK,WAGbO,GAAO,GACHA,GAAM,KACVA,GAAO,EAECF,IAAQV,EAAEtjB,OAAS,IAAGgkB,EAAM,IAC5BF,EAAKH,EAAEM,GAAMX,EAAEU,GAAMV,EAAEU,EAAM,OAC/BA,OAGU,IAARC,IAAWA,EAAMN,EAAE3jB,OAAS,IAC5B+jB,EAAKT,EAAEU,GAAML,EAAEM,GAAMN,EAAEM,EAAM,OAC/BA,EACFC,GAAO,QAGR,CAAEN,GAAII,EAAKH,GAAII,YAQVE,GAAoBb,EAAYK,UACrCD,GAAkBJ,EAAGK,EAAGP,GAAqBK,GAAqBR,GAAOE,QAWvEiB,GACT,SAAmBR,EAAmBC,WAAnBD,UAAmBC,GAG7BQ,gBAOAC,kFAAiB5B,IAIjB6B,GACT,SACWvjB,EACAwjB,EACAC,EACAlb,WAHAvI,cACAwjB,kBACAC,SACAlb,EAEPA,EAAEmb,GAAK7kB,MAIF8kB,yBAEE9lB,EACAC,eADAD,cACAC,qBACXkB,OAAA,eACQ6M,EAAKhN,KAAKhB,OAAO0K,EAAE9B,EAAI5H,KAAKf,OAAOyK,EAAE9B,EACrCyQ,EAAKrY,KAAKhB,OAAO0K,EAAE6N,EAAIvX,KAAKf,OAAOyK,EAAE6N,SAClCrR,KAAKC,KAAK6G,EAAKA,EAAKqL,EAAKA,SAI3B0M,yBAGUvB,EAAiBwB,aAAjBxB,SAFK,UACF,GAEbwB,OA+BIvB,EAAIuB,EAAGvB,EAAEna,MAAM,QACf2b,EAAID,EAAGC,EAAE3b,MAAM,OAhCf,SACDlK,EAAIokB,EAAErjB,OAEDL,EAAI,EAAGA,EAAIV,EAAGU,IAAK,SACpB4J,EAAI8Z,EAAE1jB,GAEDuB,EAAI,EAAGA,EAAIqI,EAAEvJ,SAAUkB,EAAG,KAE3BwjB,EAAK,IAAIH,GAAiB1kB,KAAKyjB,EAAEtjB,OAAQL,EAAGuB,EADvCqI,EAAErI,SAENoiB,EAAE7jB,KAAKilB,GAIRxjB,EAAI,GAAGrB,KAAKilB,EAAErlB,KAAK,IAAIklB,GAAepb,EAAErI,EAAI,GAAGwjB,GAAIA,IAGvDnb,EAAEvJ,OAAS,GAAGH,KAAKilB,EAAErlB,KAAK,IAAIklB,GAAepb,EAAE,GAAGmb,GAAInb,EAAEA,EAAEvJ,OAAS,GAAG0kB,SAErE/kB,EAAI,EAAGA,EAAIV,EAAI,EAAGU,SACnBolB,EAAK1B,EAAE1jB,OACFuB,EAAIvB,EAAI,EAAGuB,EAAIjC,EAAGiC,IAAK,KACxB8jB,EAAK3B,EAAEniB,GACPZ,EAAI2kB,GAASF,EAAIC,OAChB,IAAI9C,KAAK5hB,EAAG,KACT4E,EAAI5E,EAAE4hB,QAELgD,iBADQH,EAAG7f,EAAE0e,IAAcoB,EAAG9f,EAAE2e,IACClkB,EAAGuB,kCAS7DgkB,iBAAA,SAAiB5f,EAAalB,EAAa+gB,EAAYC,GAC9CvlB,KAAKwlB,gBAAgB,IAAI1C,GAAYrd,EAAEmC,EAAGnC,EAAE8R,EAAGhT,EAAEqD,EAAGrD,EAAEgT,GAAI+N,EAAIC,SAC1DN,EAAErlB,KAAK,IAAIklB,GAAerf,EAAEof,GAAItgB,EAAEsgB,QAG/CY,SAAA,SAAS/b,EAAa4b,OA5PE9B,EAAUC,EAG9BiC,EA0PItmB,EAAIY,KAAKwjB,EAAErjB,YACVsjB,EAAE7jB,KAAK,IAAI8kB,GAAiB1kB,KAAKyjB,EAAEtjB,OAAQf,EAAG,EAAGsK,QACjD,IAAI5J,EAAI,EAAGA,EAAIV,IAAKU,KACjBA,IAAMwlB,OACNK,EAAO3lB,KAAKwjB,EAAE1jB,GACdW,GAlQY+iB,EAkQW9Z,EA/P/Bgc,OAAAA,GAAAA,GAH8BjC,EAkQIkC,GA/PtBrc,MAAM,IACd1J,KAAK6jB,EAAE,IAER,CAAEmC,KAAMrC,GAAoBC,EAAGkC,GAAUG,KAAMjC,GAAoBJ,EAAGkC,UA6PhEL,iBAAiB3b,EAAGic,EAAKllB,EAAEolB,MAAOP,EAAIxlB,QACtCulB,iBAAiB3b,EAAGic,EAAKllB,EAAEmlB,MAAON,EAAIxlB,UAExC4J,EAAEmb,MAELW,gBAAA,SAAgBzf,EAAgBuf,EAAYC,OAC3C,IAAIzlB,EAAI,EAAGV,EAAIY,KAAKwjB,EAAErjB,OAAQL,EAAIV,IAAKU,KACpCA,GAAKwlB,GAAMxlB,GAAKylB,GAAMO,GAAW/f,EAAG/F,KAAKwjB,EAAE1jB,IAAIK,OAAS,SACjD,SAGR,QAIf,SAAS2lB,GAAW/f,EAAgByd,WAC5BvK,EAAO,GACFnZ,EAAI,EAAGV,EAAIokB,EAAErjB,OAAQL,EAAIV,IAAKU,EAAG,KAClCimB,EAAM7O,EAAU6B,iBAChBhT,EAAE0S,GAAI1S,EAAE2S,GACR3S,EAAE4S,GAAI5S,EAAE6S,GACR4K,EAAE1jB,EAAI,GAAG8H,EAAG4b,EAAE1jB,EAAI,GAAGyX,EACrBiM,EAAE1jB,GAAG8H,EAAG4b,EAAE1jB,GAAGyX,GAEbwO,GAAK9M,EAAKrZ,KAAKmmB,UAEhB9M,WAGKmM,GAAS3B,EAAYK,WAE7B3hB,EAAIshB,EAAEtjB,OAAS,EAAGf,EAAI0kB,EAAE3jB,OAAS,EACjC6lB,EAAK,IAAIxB,GACJ1kB,EAAI,EAAGA,GAAKqC,IAAKrC,MACjB,IAAIuB,EAAI,EAAGA,GAAKjC,IAAKiC,EAAG,KACrB4kB,EAAKxC,EAAO,GAAL3jB,EAASqC,EAAIrC,EAAI,GACxBomB,EAAKzC,EAAE3jB,GACPqmB,EAAK1C,EAAE3jB,GAAKqC,EAAI,EAAIrC,EAAI,GACxBsmB,EAAKtC,EAAO,GAALziB,EAASjC,EAAIiC,EAAI,GACxBqc,EAAKoG,EAAEziB,GACPglB,EAAKvC,EAAEziB,GAAKjC,EAAI,EAAIiC,EAAI,GACxBilB,EAAStD,GAAOiD,EAAIC,EAAIxI,GACxB6I,EAASvD,GAAOkD,EAAIE,EAAI1I,GACxB8I,EAASxD,GAAOkD,EAAIxI,EAAI2I,GACxBI,EAASzD,GAAOoD,EAAI1I,EAAIwI,GACxBQ,EAAS1D,GAAOtF,EAAIuI,EAAIC,GACxBS,EAAS3D,GAAOtF,EAAIwI,EAAIC,GACxBG,GAAU,GAAKC,GAAU,GAAKC,EAAS,GACpCC,GAAU,GAAKC,GAAU,GAAKC,EAAS,EACtCX,EAAGY,GAAK,IAAIrC,GAAUzkB,EAAGuB,GACtBilB,GAAU,GAAKC,GAAU,GAAKC,EAAS,GAC3CC,GAAU,GAAKC,GAAU,GAAKC,EAAS,EACtCX,EAAGa,GAAK,IAAItC,GAAUzkB,EAAGuB,GACtBilB,GAAU,GAAKC,EAAS,GAAKC,GAAU,GAC3CC,GAAU,GAAKC,EAAS,GAAKC,GAAU,EACtCX,EAAG9Y,GAAK,IAAIqX,GAAUzkB,EAAGuB,GACtBilB,GAAU,GAAKC,EAAS,GAAKC,GAAU,GAC3CC,GAAU,GAAKC,EAAS,GAAKC,GAAU,IACtCX,EAAGc,GAAK,IAAIvC,GAAUzkB,EAAGuB,WAIlC2kB,EASX,SAASe,GAAUrd,EAAY2Y,UACnB3Y,EAAE8W,OAAM,SAAAjc,UAPpB,SAA2BmF,EAAUic,OAC5B,IAAI7lB,EAAI,EAAGV,EAAIumB,EAAKxlB,OAAQL,EAAIV,IAAKU,KAClCwjB,GAAMqC,EAAK7lB,EAAI,GAAI6lB,EAAK7lB,GAAI4J,GAAI,OAAO,SACxC,EAIesd,CAAkBziB,EAAG8d,MCzc/C,IAAI4E,IAEiB,EAAI/gB,KAAKC,KAAK,IAAM,WAMzB+gB,GAAaC,EAAmBxhB,EAAGkZ,EAAGuI,EAAWC,EAAmBC,mBAAnBD,IAAAA,EAAgB,YAAGC,IAAAA,GAAc,qBAK1FC,EAAY5hB,EACZ6hB,EAAa3I,EAKb4I,GAHAJ,OAAyC,IAAlBA,EAAgCA,EAAgB,EACvED,OAAiC,IAAdA,EAA4BA,EAAY,EAE9C,GACbM,EAAc,EACdC,EAAY,EAEZC,EAAgB,EAChBC,EAAO,YAiLFC,EAAKhU,EAAMiU,GAChBF,EAAO,GACPJ,EAAa,EACbC,EAAc,EACdE,EAlMS,MAoMJ,IAAI9nB,EAAI,EAAGA,EAAIgU,EAAK3T,OAAQL,IAE7BkoB,EADQlU,EAAKhU,GACDioB,UAGT7hB,KAAKyG,IA4CJ8a,EAAaC,EA5CcL,YAI9BW,EAASvL,EAAMsL,WAGhBE,OAAS9R,EAEJrW,EAAI,EAAGA,EAAI+nB,EAAK1nB,OAAQL,OACxB+nB,EAAK/nB,GAAGooB,YAAczL,EAAKlE,QAAYsP,EAAK/nB,GAAG8H,EAAIigB,EAAK/nB,GAAGwY,MAAQmE,EAAKnE,MA7N5E,GA6N6GyP,GA3NvG,KA2NmJ,CACtJE,EAASJ,EAAK/nB,SAKtB+nB,EAAKjoB,KAAK6c,QAEKtG,IAAX8R,GACAxL,EAAK7U,EAAIqgB,EAAOrgB,EAAIqgB,EAAO3P,MAtO1B,GAuODmE,EAAKlF,EAAI0Q,EAAOE,OAChB1L,EAAKyL,WAAazL,EAAKlE,OACvBkE,EAAK0L,OAAS1L,EAAKlF,EACnB0Q,EAAOC,YAAczL,EAAKlE,OA1OzB,GA2OD0P,EAAOE,QAAU1L,EAAKlE,OA3OrB,KA6ODkE,EAAKlF,EAAIqQ,EACTA,GAAiBnL,EAAKlE,OA9OrB,GA+ODkE,EAAK7U,EAtOA,EAuOL6U,EAAK0L,OAAS1L,EAAKlF,EACnBkF,EAAKyL,WAAazL,EAAKlE,QAGvBkE,EAAKlF,EAAIkF,EAAKlE,OAASmP,GAlPhB,OAkP6DA,EAAcjL,EAAKlF,EAAIkF,EAAKlE,OA1O3F,GA2OLkE,EAAK7U,EAAI6U,EAAKnE,MAAQmP,GAnPf,OAmP2DA,EAAahL,EAAK7U,EAAI6U,EAAKnE,MA5OxF,GAgBQ,GAAjB6O,EAAOhnB,kBAkBWgnB,GAElBA,EAAO/mB,SAAQ,SAAUoD,OAII4kB,EACrBC,EAA0BC,EAC1BC,EAAWC,EAFUJ,EAHL5kB,EAIhB6kB,EAAQtjB,OAAO+D,UAAWwf,EAAQvjB,OAAO+D,UACzCyf,EAAQ,EAAGC,EAAQ,EAEvBJ,EAAMK,MAAMroB,SAAQ,SAAUmE,OACtBoB,OAAuB,IAAZpB,EAAE+T,MAAwB/T,EAAE+T,MAAQ8O,EAC/CvI,OAAwB,IAAbta,EAAEgU,OAAyBhU,EAAEgU,OAAS6O,EACrDzhB,GAAK,EACLkZ,GAAK,EACL0J,EAAQriB,KAAKuI,IAAIlK,EAAEqD,EAAIjC,EAAG4iB,GAC1BF,EAAQniB,KAAKG,IAAI9B,EAAEqD,EAAIjC,EAAG0iB,GAC1BG,EAAQtiB,KAAKuI,IAAIlK,EAAEgT,EAAIsH,EAAG2J,GAC1BF,EAAQpiB,KAAKG,IAAI9B,EAAEgT,EAAIsH,EAAGyJ,MAG9BF,EAAM9P,MAAQiQ,EAAQF,EACtBD,EAAM7P,OAASiQ,EAAQF,KA7B/BI,CAAavB,YAiGErT,EAAMuT,OACbsB,EAAc5jB,OAAO0S,kBACrBmR,EAAY,EAChB9U,EAAK3Q,MAAK,SAAUvB,EAAGC,UAAYA,EAAE0W,OAAS3W,EAAE2W,kBAM5C1R,EAAO4R,EAJXkP,EAAY7T,EAAKkD,QAAO,SAAUpV,EAAGC,UAC1BD,EAAE0W,MAAQzW,EAAEyW,MAAQ1W,EAAE0W,MAAQzW,EAAEyW,SAIvCxR,EAAQ6R,WAyGU7E,OAClBwE,EAAQ,SACZxE,EAAK1T,SAAQ,SAAUqI,UAAY6P,GAAS7P,EAAE6P,MA1PzC,MA2PEA,EA5GUuQ,CAAiB/U,GAC9BgV,EAAmB,EAEnBC,EAAOhkB,OAAO+D,UACdkgB,EAAOjkB,OAAO+D,UACdmgB,GAAQ,EAGRjc,EAAKjI,OAAO+D,UACZogB,EAAKnkB,OAAO+D,UAERkE,EAAK2a,GAAcuB,EAxJhB,MAwJmD,IAE9C,GAARD,OACIxQ,EAAK3R,GAASA,EAAQD,GAAQogB,GAC9B8B,EAAOjB,EAAKhU,EAAM2E,MAEd,GAARwQ,OACItQ,EAAK9R,GAAQC,EAAQD,GAAQogB,GAC7B+B,EAAOlB,EAAKhU,EAAM6E,MAG1B3L,EAAK9G,KAAKyG,IAAI8L,EAAKE,GACnBuQ,EAAKhjB,KAAKyG,IAAIoc,EAAOC,GAEjBD,EAAOJ,IACPA,EAAcI,EACdH,EAAYnQ,GAGZuQ,EAAOL,IACPA,EAAcK,EACdJ,EAAYjQ,GAGZoQ,EAAOC,GACPniB,EAAO4R,EACPA,EAAKE,EACLoQ,EAAOC,EACPC,EAAO,IAEPniB,EAAQ6R,EACRA,EAAKF,EACLuQ,EAAOD,EACPE,EAAO,GAGPH,IAAqB,UAK7BhB,EAAKhU,EAAM8U,GA9Jf5gB,CAAMmf,GACHG,YAoEmCH,GAClCA,EAAO/mB,SAAQ,SAAUoD,OAEjB6X,EAAS,CAAEzT,EAAG,EAAG2P,EAAG,GAExB/T,EAAEilB,MAAMroB,SAAQ,SAAUa,GACtBoa,EAAOzT,GAAK3G,EAAK2G,EACjByT,EAAO9D,GAAKtW,EAAKsW,KAGrB8D,EAAOzT,GAAKpE,EAAEilB,MAAMtoB,OACpBkb,EAAO9D,GAAK/T,EAAEilB,MAAMtoB,WAIhB8O,EAAczL,EAAEoE,GADFyT,EAAOzT,EAAIpE,EAAE8U,MAAQ,GACJiP,EAAY,EAAIE,EAAa,EAA5DxY,EAAkEzL,EAAE+T,GAD3B8D,EAAO9D,EAAI/T,EAAE+U,OAAS,GACoBiP,EAAa,EAAIE,EAAc,EAGtHlkB,EAAEilB,MAAMroB,SAAQ,SAAUa,GACtBA,EAAK2G,GAAKqH,EACVhO,EAAKsW,GAAKtI,QAvFlBka,CAA6BhC,mBAgOrBiC,GAAelkB,EAAOC,WAC9BkkB,EAAQ,GACRC,EAAO,GACPnC,EAAS,GACToC,EAAW,EAENzpB,EAAI,EAAGA,EAAIqF,EAAMhF,OAAQL,IAAK,KAC/B0pB,EAAOrkB,EAAMrF,GACb2pB,EAAKD,EAAKxqB,OACV0qB,EAAKF,EAAKvqB,OACVqqB,EAAKG,EAAGviB,OACRoiB,EAAKG,EAAGviB,OAAOtH,KAAK8pB,GAEpBJ,EAAKG,EAAGviB,OAAS,CAACwiB,GAElBJ,EAAKI,EAAGxiB,OACRoiB,EAAKI,EAAGxiB,OAAOtH,KAAK6pB,GAEpBH,EAAKI,EAAGxiB,OAAS,CAACuiB,OAGjB3pB,EAAI,EAAGA,EAAIoF,EAAM/E,OAAQL,IAAK,KAC/BmB,EAAOiE,EAAMpF,GACbupB,EAAMpoB,EAAKiG,QACfyiB,EAAa1oB,GAAM,YAGd0oB,EAAavqB,EAAGwqB,WACEzT,IAAnBkT,EAAMjqB,EAAE8H,QACR0iB,IACAL,IACApC,EAAOvnB,KAAK,CAAE6oB,MAAO,MAEzBY,EAAMjqB,EAAE8H,OAASqiB,EACjBpC,EAAOoC,EAAW,GAAGd,MAAM7oB,KAAKR,OAC5ByqB,EAAWP,EAAKlqB,EAAE8H,UACjB2iB,MAEA,IAAIxoB,EAAI,EAAGA,EAAIwoB,EAAS1pB,OAAQkB,IACjCsoB,EAAaE,EAASxoB,IAAI,WAI3B8lB,kbCnTX/e,GAA4B0hB,YAAQC,8BAAiCC,YAAYC,YAAYF,EAAY,+BAAiC,CAAEG,kBAAAA,sBAApFC,GAA4G/hB,GAAO+hB,EAAKC,+CAE9KC,GAAO,IAAI5qB,MAAM,IAAIiO,UAAKyI,GAEhCkU,GAAKzqB,UAAKuW,EAAW,MAAM,GAAM,GAEjC,IAAImU,GAAYD,GAAKlqB,OAWjBoqB,GAAyB,KAC7B,SAASC,YAC0B,OAA3BD,IAAmCA,GAAuBjd,SAAWlF,GAAK+E,OAAOG,SACjFid,GAAyB,IAAIhiB,aAAaH,GAAK+E,OAAOG,SAEnDid,GAGX,IAAIE,GAAkB,EAEtB,SAASC,GAAoBpJ,EAAKqJ,OACxBC,EAAMD,EAAoB,EAAbrJ,EAAInhB,eACvBqqB,KAAoBthB,IAAIoY,EAAKsJ,EAAM,GACnCH,GAAkBnJ,EAAInhB,OACfyqB,EAgCX,IAAIC,GAAuB,KAC3B,SAASC,YACwB,OAAzBD,IAAiCA,GAAqBvd,SAAWlF,GAAK+E,OAAOG,SAC7Eud,GAAuB,IAAIE,WAAW3iB,GAAK+E,OAAOG,SAE/Cud,GAGX,SAASG,GAAqBJ,EAAKK,UACxBT,KAAoBjhB,SAASqhB,EAAM,EAAGA,EAAM,EAAIK,GAuKpD,IC/OH7iB,GD+OS8hB,GAAoB,kBAvOjC,SAAuBzJ,GACf6J,KAAcD,GAAKlqB,QAAQkqB,GAAKzqB,KAAKyqB,GAAKlqB,OAAS,OACjD+qB,EAAMZ,UACZA,GAAYD,GAAKa,GAEjBb,GAAKa,GAAOzK,EACLyK,EAmOAC,CADG/iB,GAAK+E,+CAhPmL,kBAA4B/E,sCAuC3N,SAA2CgjB,EAAYljB,EAAGC,OACzD6B,EAAO0gB,GAAoBxiB,EAAGE,GAAKijB,mBACnCC,EAAOb,GACPvgB,EAAOwgB,GAAoBviB,EAAGC,GAAKijB,yBAGhC,CADGjjB,GAAKwC,kCAAkCwgB,EAAYphB,EAAMshB,EAAMphB,EAD9DugB,IAEEzgB,EAAME,sCAShB,SAA2CkhB,EAAYljB,EAAGC,OACzD6B,EAAO0gB,GAAoBxiB,EAAGE,GAAKijB,mBACnCC,EAAOb,GACPvgB,EAAOwgB,GAAoBviB,EAAGC,GAAKijB,yBAGhC,CADGjjB,GAAKyC,kCAAkCugB,EAAYphB,EAAMshB,EAAMphB,EAD9DugB,IAEEzgB,EAAME,eAmBhB,SAAoBqhB,EAAS3jB,WAEtB4jB,EAASpjB,GAAKqjB,iCAAiC,IACjDzhB,EAAO0gB,GAAoB9iB,EAAGQ,GAAKijB,mBAEvCjjB,GAAKgB,WAAWoiB,EAAQD,EAASvhB,EADtBygB,QAEPiB,EAAKZ,KAAkBU,EAAS,EAAI,GACpCG,EAAKb,KAAkBU,EAAS,EAAI,GACpCvF,EAAK+E,GAAqBU,EAAIC,GAAIriB,eACtClB,GAAK2B,gBAAgB2hB,EAAS,EAALC,GAClB1F,UAEP7d,GAAKqjB,gCAAgC,iBAStC,SAAoBF,EAAS3jB,WAEtB4jB,EAASpjB,GAAKqjB,iCAAiC,IACjDzhB,EAAO0gB,GAAoB9iB,EAAGQ,GAAKijB,mBAEvCjjB,GAAKqB,WAAW+hB,EAAQD,EAASvhB,EADtBygB,QAEPiB,EAAKZ,KAAkBU,EAAS,EAAI,GACpCG,EAAKb,KAAkBU,EAAS,EAAI,GACpCvF,EAAK+E,GAAqBU,EAAIC,GAAIriB,eACtClB,GAAK2B,gBAAgB2hB,EAAS,EAALC,GAClB1F,UAEP7d,GAAKqjB,gCAAgC,oBAYtC,SAAuBF,EAAS9lB,EAAGmmB,EAAKC,EAAKC,EAAOC,GACvD3jB,GAAKuB,cAAc4hB,EAAS9lB,EAAGmmB,EAAKC,EAAKC,EAAOC,kBAa7C,SAAuBR,EAAS9lB,EAAGmmB,EAAKC,EAAKG,EAAKF,EAAOC,EAAOE,GACnE7jB,GAAKwB,cAAc2hB,EAAS9lB,EAAGmmB,EAAKC,EAAKG,EAAKF,EAAOC,EAAOE,yBAOzD,SAA8BV,UACvBnjB,GAAKmD,qBAAqBggB,yBAQjC,SAA8BA,UACvBnjB,GAAKoD,qBAAqB+f,eAoBjC,kBAPGtV,EATV,SAAmBiV,UAAcb,GAAKa,GAStBgB,CADIhB,EASN9iB,GAAKgF,cAfnB,SAAoB8d,GACZA,EAAM,KACVb,GAAKa,GAAOZ,GACZA,GAAYY,GAKZiB,CAAWjB,GACJjV,EAHX,IAAoBiV,EACVjV,YAgBH,SAAkBmW,UACXhkB,GAAK+F,SAASie,aAQrB,SAAkBA,UACXhkB,GAAKgG,SAASge,aAQrB,SAAkBA,UACXhkB,GAAKoF,SAAS4e,aAQrB,SAAkBA,UACXhkB,GAAK+F,SAASie,aAQrB,SAAkBA,EAAKC,OACtBriB,EAAO0gB,GAAoB2B,EAAOjkB,GAAKijB,0BAE3CjjB,GAAK4F,SAASoe,EAAKpiB,EADRygB,IAEJzgB,YAOJ,SAAkBoiB,EAAKC,OACtBriB,EAAO0gB,GAAoB2B,EAAOjkB,GAAKijB,0BAE3CjjB,GAAK6F,SAASme,EAAKpiB,EADRygB,IAEJzgB,yBC5OqB8f,YAAQC,8BAAiCC,YAAYC,YAAYF,EAAY,+BAAiC,CAAEG,kBAAAA,sBAApFC,GAA4G/hB,GAAO+hB,EAAKC,+CAE9KC,GAAO,IAAI5qB,MAAM,IAAIiO,UAAKyI,MAE3BvW,UAAKuW,EAAW,MAAM,GAAM,GAEjC,IAAImU,GAAYD,GAAKlqB,OAWjBoqB,GAAyB,KAC7B,SAASC,YAC0B,OAA3BD,IAAmCA,GAAuBjd,SAAWlF,GAAK+E,OAAOG,SACjFid,GAAyB,IAAIhiB,aAAaH,GAAK+E,OAAOG,SAEnDid,GAGX,IAAIE,GAAkB,EAEtB,SAASC,GAAoBpJ,EAAKqJ,OACxBC,EAAMD,EAAoB,EAAbrJ,EAAInhB,eACvBqqB,KAAoBthB,IAAIoY,EAAKsJ,EAAM,GACnCH,GAAkBnJ,EAAInhB,OACfyqB,EAgCX,IAAIC,GAAuB,KAC3B,SAASC,YACwB,OAAzBD,IAAiCA,GAAqBvd,SAAWlF,GAAK+E,OAAOG,SAC7Eud,GAAuB,IAAIE,WAAW3iB,GAAK+E,OAAOG,SAE/Cud,GAGX,SAASG,GAAqBJ,EAAKK,UACxBT,KAAoBjhB,SAASqhB,EAAM,EAAGA,EAAM,EAAIK,GAuKpD,IC7NSqB,GD6NHpC,GAAoB,kBAvOjC,SAAuBzJ,GACf6J,KAAcD,GAAKlqB,QAAQkqB,GAAKzqB,KAAKyqB,GAAKlqB,OAAS,OACjD+qB,EAAMZ,UACZA,GAAYD,GAAKa,GAEjBb,GAAKa,GAAOzK,EACLyK,EAmOAC,CADG/iB,GAAK+E,+CAhPmL,kBAA4B/E,sCAuC3N,SAA2CgjB,EAAYljB,EAAGC,OACzD6B,EAAO0gB,GAAoBxiB,EAAGE,GAAKijB,mBACnCC,EAAOb,GACPvgB,EAAOwgB,GAAoBviB,EAAGC,GAAKijB,yBAGhC,CADGjjB,GAAKwC,kCAAkCwgB,EAAYphB,EAAMshB,EAAMphB,EAD9DugB,IAEEzgB,EAAME,sCAShB,SAA2CkhB,EAAYljB,EAAGC,OACzD6B,EAAO0gB,GAAoBxiB,EAAGE,GAAKijB,mBACnCC,EAAOb,GACPvgB,EAAOwgB,GAAoBviB,EAAGC,GAAKijB,yBAGhC,CADGjjB,GAAKyC,kCAAkCugB,EAAYphB,EAAMshB,EAAMphB,EAD9DugB,IAEEzgB,EAAME,eAmBhB,SAAoBqhB,EAAS3jB,WAEtB4jB,EAASpjB,GAAKqjB,iCAAiC,IACjDzhB,EAAO0gB,GAAoB9iB,EAAGQ,GAAKijB,mBAEvCjjB,GAAKgB,WAAWoiB,EAAQD,EAASvhB,EADtBygB,QAEPiB,EAAKZ,KAAkBU,EAAS,EAAI,GACpCG,EAAKb,KAAkBU,EAAS,EAAI,GACpCvF,EAAK+E,GAAqBU,EAAIC,GAAIriB,eACtClB,GAAK2B,gBAAgB2hB,EAAS,EAALC,GAClB1F,UAEP7d,GAAKqjB,gCAAgC,iBAStC,SAAoBF,EAAS3jB,WAEtB4jB,EAASpjB,GAAKqjB,iCAAiC,IACjDzhB,EAAO0gB,GAAoB9iB,EAAGQ,GAAKijB,mBAEvCjjB,GAAKqB,WAAW+hB,EAAQD,EAASvhB,EADtBygB,QAEPiB,EAAKZ,KAAkBU,EAAS,EAAI,GACpCG,EAAKb,KAAkBU,EAAS,EAAI,GACpCvF,EAAK+E,GAAqBU,EAAIC,GAAIriB,eACtClB,GAAK2B,gBAAgB2hB,EAAS,EAALC,GAClB1F,UAEP7d,GAAKqjB,gCAAgC,oBAYtC,SAAuBF,EAAS9lB,EAAGmmB,EAAKC,EAAKC,EAAOC,GACvD3jB,GAAKuB,cAAc4hB,EAAS9lB,EAAGmmB,EAAKC,EAAKC,EAAOC,kBAa7C,SAAuBR,EAAS9lB,EAAGmmB,EAAKC,EAAKG,EAAKF,EAAOC,EAAOE,GACnE7jB,GAAKwB,cAAc2hB,EAAS9lB,EAAGmmB,EAAKC,EAAKG,EAAKF,EAAOC,EAAOE,yBAOzD,SAA8BV,UACvBnjB,GAAKmD,qBAAqBggB,yBAQjC,SAA8BA,UACvBnjB,GAAKoD,qBAAqB+f,eAoBjC,kBAPGtV,EATV,SAAmBiV,UAAcb,GAAKa,GAStBgB,CADIhB,EASN9iB,GAAKgF,cAfnB,SAAoB8d,GACZA,EAAM,KACVb,GAAKa,GAAOZ,GACZA,GAAYY,GAKZiB,CAAWjB,GACJjV,EAHX,IAAoBiV,EACVjV,YAgBH,SAAkBmW,UACXhkB,GAAK+F,SAASie,aAQrB,SAAkBA,UACXhkB,GAAKgG,SAASge,aAQrB,SAAkBA,UACXhkB,GAAKoF,SAAS4e,aAQrB,SAAkBA,UACXhkB,GAAK+F,SAASie,aAQrB,SAAkBA,EAAKC,OACtBriB,EAAO0gB,GAAoB2B,EAAOjkB,GAAKijB,0BAE3CjjB,GAAK4F,SAASoe,EAAKpiB,EADRygB,IAEJzgB,YAOJ,SAAkBoiB,EAAKC,OACtBriB,EAAO0gB,GAAoB2B,EAAOjkB,GAAKijB,0BAE3CjjB,GAAK6F,SAASme,EAAKpiB,EADRygB,IAEJzgB,yBEpMEuiB,GAAW,0BAvBHC,gBAHkB,UAI9BA,OAASA,qBAGHC,yBACPzsB,YAAA6D,EAAKkQ,oBACAlQ,EAAKkQ,IAAI2Y,QAEd7oB,EAAK8oB,YAIJA,QAAU,IAAIC,SAAQ,SAACC,UAC1BhpB,EAAK2oB,SAASM,MAAK,SAAC/Y,KACbA,IAAM,CAAE2Y,MAAO3Y,KACf4Y,QAAU,KACfE,EAAQ9Y,0BAPHlQ,EAAK8oB,mDAcM,8EA9Bc3C,YAAY+C,SAAS,IAAIC,WAAW,CAAC,EAAE,GAAG,IAAI,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,IAAI,GAAG,GAAG,0CA+B5GC,mBAA3BC,UACDC,OAAOC,SAASC,KAAKC,SAAS,cACjC3Q,QAAQ4Q,IACNL,EACI,8BACA,uDAIJA,2n4BACInD,UACLyD,GAAyBzD,GACnByD,o24BAEmBC,mBAApB1D,UACL2D,GAA2B3D,GACrB2D,+CAQEC,GAA4B,kBAA2CpB,GAASE,ODvDvFmB,GAAkBD,KAuDpB,SAASE,GAAQrqB,eACc,IAAbA,EAAExC,aAA8C,IAAbwC,EAAEpC,QAhD3CkrB,GAAAA,cAAAA,qCAAmBA,qBAAMA,uBAyExBwB,uDACa,CAAC,EAAG,sBACoC,yBAC3B,8BACH,oBACZ,0BACK,4BACK,iBAGX,cACF,gBACC,mBACG,iBACmB,qBACjB,wBACG,mBACE,mCACO,qBACd,0BACM,4BACC,gBAGV,uBAkVqB,CACnCttB,eAAgBstB,EAAOttB,eACvBE,eAAgBotB,EAAOptB,eACvBsF,UAAW8nB,EAAOC,cAClBptB,QAAS,SAAAoF,SAA+B,mBAAnBxF,EAAKytB,UAA2BztB,EAAKytB,UAAUjoB,GAAK,+BAlVtEkoB,GAAA,SAAG5tB,EAAuB6tB,UAExBluB,KAAKmuB,QAAOnuB,KAAKmuB,MAAQ,IACb,iBAAN9tB,OACF8tB,MAAM7B,YAAUjsB,IAAM6tB,OAEtBC,MAAM9tB,GAAK6tB,EAEbluB,QAKDouB,QAAA,SAAQ/tB,GACVL,KAAKmuB,YAAuC,IAAvBnuB,KAAKmuB,MAAM9tB,EAAEnB,YAC7BivB,MAAM9tB,EAAEnB,MAAMmB,MAOjBguB,KAAA,iBACEruB,KAAKsuB,aAMPA,KAAA,cACFtuB,KAAKuuB,OAASvuB,KAAKwuB,uBACdC,UAAW,OACXL,QAAQ,CAAElvB,KAAMotB,YAAU/mB,IAAKmG,MAAO1L,KAAKuuB,OAAS,EAAG/hB,OAAQxM,KAAK0uB,eAClE,MAIPrsB,EAAGvC,EAFDV,EAAIY,KAAK2uB,OAAOxuB,gBAIjByuB,SAAS/mB,MAAMC,QACfhI,EAAI,EAAGA,EAAIV,IAAKU,GACjBuC,EAAIrC,KAAK2uB,OAAO7uB,IACV6e,aACkB,IAATtc,EAAE4c,SAAsC,IAAT5c,EAAEid,KACxCjd,EAAE4c,GAAK5c,EAAEuF,EACTvF,EAAEid,GAAKjd,EAAEkV,QAGRqX,SAAS/mB,MAAM9H,IAAID,EADhB,CAACuC,EAAE4c,GAAI5c,EAAEid,UAKrBuP,EAAK7uB,KAAK4uB,SAASliB,oBAEZ,IAAPmiB,OACKN,OAAS,OACqB,IAArBvuB,KAAK0uB,mBACdH,OAASM,QAEbH,YAAcG,OAEdC,2BAEAV,QAAQ,CAAElvB,KAAMotB,YAAUgC,KAAM5iB,MAAO1L,KAAKuuB,OAAQ/hB,OAAQxM,KAAK0uB,eAC/D,KAIHI,oBAAA,mBAEAzsB,EADEuF,EAAI5H,KAAK4uB,SAAShnB,EAAE,GAAI2P,EAAIvX,KAAK4uB,SAAShnB,EAAE,GAC3C9H,EAAIE,KAAK2uB,OAAOxuB,OAChBL,MACHuC,EAAIrC,KAAK2uB,OAAO7uB,IACd8H,EAAIA,EAAE9H,GACRuC,EAAEkV,EAAIA,EAAEzX,MAahBoF,MAAA,SAAMX,OACGA,EAAG,IACuB,IAAvBvE,KAAK2uB,OAAOxuB,QAAgBH,KAAK+uB,OAAO5uB,OAAS,EAAG,KAGhDf,EAAI,OACH2vB,OAAO3uB,SAAQ,SAAU2F,GAC1B3G,EAAI8G,KAAKuI,IAAIrP,EAAW2G,EAAE/G,OAAgB+G,EAAE9G,gBAE3C0vB,OAAS,IAAIlvB,QAAQL,OACrB,IAAIU,EAAI,EAAGA,EAAIV,IAAKU,OAChB6uB,OAAO7uB,GAAK,UAGlBE,KAAK2uB,mBAEXA,OAASpqB,EACPvE,QAUXoB,OAAA,SAAOwG,qBACEA,QACAonB,QAAUpnB,OACVqnB,WAAa,QACbD,QAAQ5uB,SAAQ,SAAAoD,QACQ,IAAdA,EAAE6T,UACT7T,EAAE6T,QAAU,QACQ,IAAb7T,EAAExC,QACTwC,EAAExC,OAAOZ,SAAQ,SAACmE,EAAGzE,GACA,iBAANyE,KACNf,EAAExC,OAAOlB,GAAK+D,EAAK8qB,OAAOpqB,IAAI0jB,OAASzkB,WAG5B,IAAbA,EAAEpC,QACToC,EAAEpC,OAAOhB,SAAQ,SAAC8uB,EAAIpvB,GACA,iBAAPovB,KACN1rB,EAAEpC,OAAOtB,GAAK+D,EAAKmrB,QAAQE,IAAKjH,OAASzkB,cAIrDyrB,WAAWjuB,OAAShB,KAAK2uB,OAAOrQ,QAAO,SAAA/Z,eAAyB,IAAbA,EAAE0jB,eACrDgH,WAAW7tB,OAASpB,KAAKgvB,QAAQ1Q,QAAO,SAAA9a,eAAyB,IAAbA,EAAEykB,UACpDjoB,MArBQA,KAAKgvB,WAwBxBG,iBAAA,SAAiBzqB,OACTlB,EAAI4rB,EAAqBpvB,KAAK2uB,OAAQ3uB,KAAK+uB,OAAQ/uB,KAAKV,aAAcU,KAAKivB,wBAC1E7tB,OAAOoC,EAAEpC,QACdsD,EAAElB,GACKxD,QAWXud,cAAA,SAAchZ,UACL8qB,UAAUlvB,aACVmvB,eAAiB/qB,EACfvE,MAFuBA,KAAKsvB,kBAevCC,mBAAA,SAAmBhrB,UACV8qB,UAAUlvB,aACVqvB,oBAAsBjrB,EACpBvE,MAFuBA,KAAKwvB,uBAWvCC,WAAA,SAAWlpB,EAAcmpB,UAChBL,UAAUlvB,SAAQoG,EAAO,UACzBopB,yBAA2B,CAC5BppB,KAAMA,EACNS,iBAA2C,iBAAlB0oB,EAA6B,kBAAqBA,GAAkBA,GAE1F1vB,QAUXmF,MAAA,SAAMyC,UACGynB,UAAUlvB,aACV4uB,OAASnnB,EACP5H,MAFuBA,KAAK+uB,UAavCroB,YAAA,SAAYrB,UACHgqB,UAAUlvB,aACVyvB,aAAevqB,EACbrF,MAFuBA,KAAK4vB,gBAcvCC,eAAA,SAAepnB,UACN4mB,UAAUlvB,aACV2vB,gBAAkBrnB,EAChBzI,MAFuBA,KAAK8vB,mBAavCvb,KAAA,SAAK3M,UACIA,QACAmoB,YAAcnoB,EACZ5H,MAFQA,KAAK+vB,eAYxBC,gBAAA,SAAgBpoB,UACPA,QACAqoB,iBAAmBroB,EACjB5H,MAFQA,KAAKiwB,oBAYxBC,iBAAA,SAAiBtoB,UACRA,QACAuoB,kBAAoBvoB,EAClB5H,MAFQA,KAAKmwB,qBAYxBC,aAAA,SAAaxoB,UACJA,QAGAyoB,cAA6B,mBAANzoB,EAAmBA,GAAKA,OAC/C0oB,sBAAwB,KACtBtwB,MAJIA,KAAKqwB,iBAOpBE,SAAA,SAAS7rB,eACAspB,UAAYtpB,EACV1E,QAKXwwB,qBAAA,SAAqB5oB,UACZA,QACA4mB,WAA0B,mBAAN5mB,EAAmBA,GAAKA,EAC1C5H,MAFQA,KAAKwuB,cAOxB9iB,MAAA,SAAM9D,UACGynB,UAAUlvB,QAEXyH,GAAKA,EACD5H,KAAKuuB,OACMvuB,KAAKuuB,OAAZ3mB,EAAI,EAAiBA,EACN,EACZA,EAAI,IACN5H,KAAKyuB,gBACDA,UAAW,OACXL,QAAQ,CAAElvB,KAAMotB,YAAU7W,MAAO/J,MAAO1L,KAAKuuB,OAAS3mB,SACtDymB,SAGNruB,MAbmBA,KAAKuuB,UAiBvCkC,cAAA,SAAcjH,SAC2B,mBAAvBxpB,KAAKqwB,eAA+DrwB,KAAKqwB,cAAe7G,GAAiBxpB,KAAKqwB,iBAGzHtC,cAAP,SAAqBvE,EAAyBrpB,GAC1CqpB,EAAKrpB,OAASA,KAGlBuwB,YAAA,SAAYlH,SACyB,mBAAnBxpB,KAAKguB,UAA2BhuB,KAAKguB,UAAUxE,GAAQ,KAoBzEvjB,yBAAA,SAAyB0qB,EAAqBhrB,8BAAAA,IAAAA,EAAY,QACjDyqB,cAAa,SAAArqB,UAAK4qB,EAAc5qB,EAAE5F,eAClCmwB,sBAAwB,kBAAMrqB,EAAyBhC,EAAK8qB,OAAQ9qB,EAAK3E,aAAcqG,IACrF3F,QAaXoG,mBAAA,SAAmBuqB,EAAqBhrB,8BAAAA,IAAAA,EAAY,QAC3CyqB,cAAa,SAAArqB,UAAK4qB,EAAc5qB,EAAE5F,eAClCmwB,sBAAwB,kBAAMlqB,EAAmB0G,EAAKiiB,OAAQjiB,EAAKxN,aAAcqG,IAC/E3F,QAaLyV,eACFmb,EACAC,EACAC,EACAC,EACAC,EACA1J,YALAsJ,IAAAA,EAAyC,YACzCC,IAAAA,EAA0C,YAC1CC,IAAAA,EAA0C,YAE1CE,IAAAA,GAAc,YACd1J,IAAAA,GAAc,WAIVloB,EACAsd,EAEA/W,EACAkZ,EA6FK/e,IAvFAE,KATL0c,GADAtd,EAAiB0O,EAAK5I,QAAS/E,QACvB,EAAI2N,EAAKkhB,QAAQ7uB,OAEzBwF,EAAImI,EAAKiiB,YAAY,GACrBlR,EAAI/Q,EAAKiiB,YAAY,OAqBrBkB,EAnBArpB,EAAI,IAAInI,MAAMid,GAAInF,EAAI,IAAI9X,MAAMid,GAEhCvU,EAAI,KAEJ+oB,EAAKpjB,EAAKwhB,iBAETX,OAAOvuB,SAAQ,SAACmE,EAAGzE,GACpByE,EAAE2C,MAAQpH,OACS,IAARyE,EAAEqD,IACTrD,EAAEqD,EAAIjC,EAAI,EAAGpB,EAAEgT,EAAIsH,EAAI,GAE3BjX,EAAE9H,GAAKyE,EAAEqD,EAAG2P,EAAEzX,GAAKyE,EAAEgT,KAGrBzJ,EAAKwiB,uBAAuBxiB,EAAKwiB,wBAMjCxiB,EAAKgiB,gBAELmB,EAAYnjB,EAAKgiB,iBAGjBmB,EAAa,IAAIpP,GAAWnF,EAAG5O,EAAKihB,OAAQjB,EAAOttB,eAAgBstB,EAAOptB,gBAAgB,SAAAqF,UAAI+H,EAAK2iB,cAAc1qB,MAAKgc,iBAItH5Z,EAAIF,EAAQ6C,mBAAmB4R,GAAG,kBAAM,OACnCqS,OAAO3uB,SAAQ,SAAA2F,GACO,iBAAZA,EAAE/G,SAAoB+G,EAAE/G,OAAS8O,EAAK6gB,OAAe5oB,EAAE/G,SAC3C,iBAAZ+G,EAAE9G,SAAoB8G,EAAE9G,OAAS6O,EAAK6gB,OAAe5oB,EAAE9G,cAEjE8vB,OAAO3uB,SAAQ,SAAAC,OACVoF,EAAIqoB,EAAOttB,eAAeH,GAAIkE,EAAIupB,EAAOptB,eAAeL,GAC9D8H,EAAE1C,GAAGlB,GAAK4D,EAAE5D,GAAGkB,GAAKpF,EAAE0O,QAAU,UAIpC7G,EAAID,EAAQ6C,mBAAmB4R,GAAG,SAAU5c,EAAGuB,UACxC4vB,EAAUnxB,GAAGuB,MAGpByM,EAAKmhB,iBAAgD,IAA3BnhB,EAAKmhB,WAAW7tB,QACtCtB,EAAIV,IAKH4vB,QAAQ5uB,SAAQ,SAAAoD,IAJD,SAAC1D,EAAGuB,EAAG8vB,EAAUC,GACjCjpB,EAAErI,GAAGuB,GAAK8G,EAAE9G,GAAGvB,GAAKqxB,EACpBjpB,EAAEpI,GAAGuB,GAAK6G,EAAE7G,GAAGvB,GAGiC,GAAhDuxB,CAAcvxB,EAAGA,EAAI,EAAGgO,EAAKqiB,wBAiBL,IAAb3sB,EAAEuT,QACTnP,EAAE9H,GAAK6F,EAAI,EAAG4R,EAAEzX,KAAO+e,EAAI,EAC3BjX,EAAE9H,GAAK6F,EAAI,EAAG4R,EAAEzX,KAAO+e,EAAI,IAE3BjX,EAAE9H,GAAK0D,EAAEuT,OAAOnP,EAAG2P,EAAEzX,KAAO0D,EAAEuT,OAAOQ,EACrC3P,EAAE9H,GAAK0D,EAAEuT,OAAOO,EAAGC,EAAEzX,KAAO0D,EAAEuT,OAAOS,OAG1C1J,EAAKmhB,WAAa,CAAEjuB,OAAQ8M,EAAK6gB,OAAQvtB,OAAQ,QAEpDkwB,EAAiBxjB,EAAK8hB,cAAgB,UACtC9hB,EAAK6hB,6BACMrwB,aAAc0H,iBAAmB8G,EAAK6hB,yBAAyB3oB,iBAC1EsqB,EAAiBA,EAAenV,OAAO7V,EAAgClH,EAAG0O,EAAKihB,OAAQjhB,EAAK6hB,yBAAyBppB,KAAYuH,EAAKxO,kBAKrIie,eAAc,mBACIqQ,mBAAjB2D,SACD3C,SAAW,IAAI3mB,EAAQ,CAACL,EAAG2P,GAAIrP,OAAGiO,EAAWob,KAE7C3C,SAAS/mB,MAAMC,QACXhI,EAAI,EAAGA,EAAIV,IAAKU,EAAG,KACpBuC,EAAIyL,EAAK6gB,OAAO7uB,GAChBuC,EAAEsc,QACFtc,EAAE4c,GAAK5c,EAAEuF,EACTvF,EAAEid,GAAKjd,EAAEkV,IAEJqX,SAAS/mB,MAAM9H,IAAID,EADhB,CAACuC,EAAEuF,EAAGvF,EAAEkV,cAInBqX,SAAShiB,UAAYkB,EAAK0gB,aAK1BgD,cAAcZ,EAAgChpB,EAAG2P,GAGlD+Z,EAAenxB,OAAS,IAAG2N,EAAK8gB,SAAS1iB,QAAU,IAAIoR,EAAWxP,EAAK6gB,OAAQ7gB,EAAKkhB,QAASlhB,EAAKmhB,WAAYqC,GAAgB7R,sBAC7HmP,SAAStiB,IAAIukB,KACbY,8BAA8B9rB,EAAGkZ,EAAGyI,KAGpC/J,cAAc2T,GACfA,MACKvC,OAAOvuB,SAAQ,SAAUmE,EAAGzE,GAAKyE,EAAEqD,EAAIA,EAAE9H,GAAIyE,EAAEgT,EAAIA,EAAEzX,QACrD8uB,SAAS1iB,QAAU,IAAIoR,EAAWxP,EAAK6gB,OAAQ7gB,EAAKkhB,QAASlhB,EAAKmhB,WAAYqC,GAAgB,GAAM7R,qBACpGkP,OAAOvuB,SAAQ,SAAUmE,EAAGzE,GAAK8H,EAAE9H,GAAKyE,EAAEqD,EAAG2P,EAAEzX,GAAKyE,EAAEgT,QAI1DqX,SAASzmB,EAAIA,IACbymB,SAAStiB,IAAIwkB,KAgBbhC,wBACA2C,8BAA8B9rB,EAAGkZ,EAAGyI,GAClC0J,EAAcljB,EAAK4jB,oDAGtBF,cAAA,SAAcjlB,EAAoB3E,EAAa2P,MAC/CvX,KAAKgvB,QAAQ7uB,OAAS,GAAKoM,EAAa,EAAG,KAGvCnN,EAAIY,KAAK2uB,OAAOxuB,OAChBd,EAAQW,KAAK+uB,OAAOrnB,KAAI,SAAArH,SAAU,CAAErB,OAAeqB,EAAErB,OAAQkI,MAAOjI,OAAeoB,EAAEpB,OAAQiI,UAC7FtC,EAAK5E,KAAK2uB,OAAOjnB,KAAI,SAAAnD,SAAU,CAAE2C,MAAO3C,EAAE2C,eACzC8nB,QAAQ5uB,SAAQ,SAACoD,EAAG1D,GACrB8E,EAAGhF,KAAU,CAAEsH,MAAO1D,EAAE0D,MAAQ9H,EAAIU,YAEnCkvB,QAAQ5uB,SAAQ,SAACoD,EAAG1D,QACG,IAAb0D,EAAExC,QACTwC,EAAExC,OAAOZ,SAAQ,SAAAmE,UAAKlF,EAAMO,KAAK,CAAEZ,OAAQwE,EAAE0D,MAAOjI,OAAQsF,EAAE2C,gBAC1C,IAAb1D,EAAEpC,QACToC,EAAEpC,OAAOhB,SAAQ,SAAAuxB,UAAMtyB,EAAMO,KAAK,CAAEZ,OAAQwE,EAAE0D,MAAOjI,OAAQ0yB,EAAGzqB,mBAIpE4mB,GACCvZ,KAAKvU,KAAKuU,QACVrP,MAAMN,GACNO,MAAM9F,GACNke,eAAc,GACd6S,aAAapwB,KAAKowB,gBAClBnqB,yBAAyB,GACzBuqB,qBAAqB,MACrB/a,MAAMlJ,EAAY,EAAG,EAAG,GAAG,QAE3BoiB,OAAOvuB,SAAQ,SAAAmE,GAChBqD,EAAErD,EAAE2C,OAAStC,EAAGL,EAAE2C,OAAOU,EACzB2P,EAAEhT,EAAE2C,OAAStC,EAAGL,EAAE2C,OAAOqQ,eAGxBqX,SAAStiB,IAAIC,MAKlBklB,8BAAA,SAA8BnZ,EAAeC,EAAgB+O,0BAAAA,IAAAA,GAAuB,IAEnFtnB,KAAK8vB,iBAAmB9vB,KAAKwvB,oBAAqB,KAC/C5nB,EAAI5H,KAAK4uB,SAAShnB,EAAE,GAAI2P,EAAIvX,KAAK4uB,SAAShnB,EAAE,QAC3C+mB,OAAOvuB,SAAQ,SAAUmE,EAAGzE,GAAKyE,EAAEqD,EAAIA,EAAE9H,GAAIyE,EAAEgT,EAAIA,EAAEzX,MAE1DonB,GADakC,GAAeppB,KAAK2uB,OAAQ3uB,KAAK+uB,QACzBzW,EAAOC,EAAQvY,KAAKiwB,iBAAkB,EAAG3I,QACzDqH,OAAOvuB,SAAQ,SAACmE,EAAGzE,GACpBuO,EAAKugB,SAAShnB,EAAE,GAAG9H,GAAKyE,EAAEqD,EAAGyG,EAAKugB,SAAShnB,EAAE,GAAG9H,GAAKyE,EAAEgT,EACnDhT,EAAEwS,SACFxS,EAAEwS,OAAOoB,WAAW5T,EAAEqD,GACtBrD,EAAEwS,OAAOqB,WAAW7T,EAAEgT,WAMtCma,OAAA,kBACW1xB,KAAK0L,MAAM,OAGtBkmB,MAAA,kBACW5xB,KAAK0L,MAAM,MAGtBmmB,KAAA,kBACQ7xB,KAAK4uB,eACAA,SAAS/kB,kBAEX7J,KAAK0L,MAAM,MAKtBomB,mBAAA,SAAmBC,YAAAA,IAAAA,EAAqB,QAC/BC,iBAAmB,IAAIjN,GACxB/kB,KAAK2uB,OAAOjnB,KAAI,SAAUnD,UACfA,EAAEwS,OAAOK,SAAS2a,GAAY7Y,kBAajD+Y,UAAA,SAAUC,EAAMlY,EAAgBmY,YAAhBnY,IAAAA,EAAa,OACrBoY,EAAW,GAIXC,EAAM,IAAItN,GAAuB/kB,KAAKgyB,iBAAiBxO,EAAG,CAAEC,EAAGzjB,KAAKgyB,iBAAiBvO,EAAGwB,EAAGjlB,KAAKgyB,iBAAiB/M,IACjHqN,EAAkB,CAAE1qB,EAAGsqB,EAAKlzB,OAAO4I,EAAG2P,EAAG2a,EAAKlzB,OAAOuY,GACrDgb,EAAkB,CAAE3qB,EAAGsqB,EAAKjzB,OAAO2I,EAAG2P,EAAG2a,EAAKjzB,OAAOsY,GACrD9B,EAAQ4c,EAAI5M,SAAS6M,EAAOJ,EAAKlzB,OAAOkI,OACxC3B,EAAM8sB,EAAI5M,SAAS8M,EAAOL,EAAKjzB,OAAOiI,OAC1CmrB,EAAIhN,iBAAiBiN,EAAOC,EAAOL,EAAKlzB,OAAOkI,MAAOgrB,EAAKjzB,OAAOiI,YAC9C,IAATirB,GACPA,EAAKE,OAILG,EADS,IAAI3Q,GAAWwQ,EAAI5O,EAAEtjB,OAAQkyB,EAAIpN,GAD9B,SAAA5kB,UAAKA,EAAErB,OAAOmC,MAAgB,SAAAd,UAAKA,EAAEpB,OAAOkC,MAAa,SAAAd,UAAKA,EAAEF,YAEtD+hB,mBAAmBzM,EAAMtU,GAAIoE,EAAIpE,OAC/B,IAAxBqxB,EAAaryB,QAAgBqyB,EAAaryB,SAAWkyB,EAAI5O,EAAEtjB,OAAQ,KAC/DsyB,EAAQ1Y,EAAgBmY,EAAKlzB,OAAO0zB,YAAaR,EAAKjzB,OAAOyzB,YAAa1Y,GAC9EoY,EAAW,CAACK,EAAMrY,mBAAoBqY,EAAMnY,gBACzC,SACClb,EAAIozB,EAAaryB,OAAS,EAC1BuJ,EAAI2oB,EAAI5O,EAAE+O,EAAapzB,IAAIsK,EAC3B2Y,EAAIgQ,EAAI5O,EAAE+O,EAAa,IAAI9oB,EAEtB5J,GADLsyB,EAAW,CAACF,EAAKlzB,OAAO0zB,YAAY1Z,gBAAgBtP,EAAE9B,EAAG8B,EAAE6N,IAClDnY,GAAGU,GAAK,IAAKA,EACtBsyB,EAASxyB,KAAKyyB,EAAI5O,EAAE+O,EAAa1yB,IAAI4J,GACzC0oB,EAASxyB,KAAK2a,EAAW8H,EAAG6P,EAAKjzB,OAAOyzB,YAAa1Y,WAclDoY,KAIJ5xB,eAAP,SAAsBH,SACS,iBAAbA,EAAErB,OAA8BqB,EAAErB,OAAgBqB,EAAErB,OAAQkI,SAIvExG,eAAP,SAAsBL,SACS,iBAAbA,EAAEpB,OAA8BoB,EAAEpB,OAAgBoB,EAAEpB,OAAQiI,SAIvEyrB,OAAP,SAActyB,UACHytB,EAAOttB,eAAeH,GAAK,IAAMytB,EAAOptB,eAAeL,MAO3DuyB,UAAP,SAAiBnqB,GACTolB,GAAQplB,GACRqlB,EAAO+E,YAAYpqB,EAAGqlB,EAAOgF,WAAWrqB,KAExCqlB,EAAOiF,SAAStqB,GAChBA,EAAEkW,OAAS,MAMJoU,SAAP,SAAgBxuB,GACdA,EAAG0a,GAAK1a,EAAEqD,EACVrD,EAAG+a,GAAK/a,EAAEgT,KAKLsb,YAAP,SAAmBpqB,EAAUuqB,QACT,IAAbvqB,EAAEzH,QACTyH,EAAEzH,OAAOZ,SAAQ,SAAAmE,GACbA,EAAEoa,OAAS,EACXmP,EAAOiF,SAASxuB,GACVA,EAAG0uB,kBAAoB1uB,EAAEqD,EAAIorB,EAAOprB,EACpCrD,EAAG2uB,kBAAoB3uB,EAAEgT,EAAIyb,EAAOzb,UAG1B,IAAb9O,EAAErH,QACTqH,EAAErH,OAAOhB,SAAQ,SAAAoD,UAAKsqB,EAAO+E,YAAYrvB,EAAGwvB,SAK7CF,WAAP,SAAkBrqB,UACVolB,GAAQplB,GACD,CACHb,EAAGa,EAAEsO,OAAOY,KACZJ,EAAG9O,EAAEsO,OAAOa,MAGTnP,KAMR0qB,KAAP,SAAY1qB,EAAiBiH,GACrBme,GAAQplB,SACgB,IAAbA,EAAEzH,QACTyH,EAAEzH,OAAOZ,SAAQ,SAAAmE,GACbkE,EAAEsO,OAAOoB,WAAWzI,EAAS9H,GAC7Ba,EAAEsO,OAAOqB,WAAW1I,EAAS6H,GACvBhT,EAAG0a,GAAW1a,EAAG0uB,kBAAoBvjB,EAAS9H,EAC9CrD,EAAG+a,GAAW/a,EAAG2uB,kBAAoBxjB,EAAS6H,UAGpC,IAAb9O,EAAErH,QACTqH,EAAErH,OAAOhB,SAAQ,SAAAoD,UAAKsqB,EAAOqF,KAAK3vB,EAAGkM,QAGnCjH,EAAGwW,GAAKvP,EAAS9H,EACjBa,EAAG6W,GAAK5P,EAAS6H,MAMxB6b,QAAP,SAAe3qB,GACPolB,GAAQplB,SACgB,IAAbA,EAAEzH,QACTyH,EAAEzH,OAAOZ,SAAQ,SAAAmE,GACbupB,EAAOsF,QAAQ7uB,UACFA,EAAG0uB,yBACH1uB,EAAG2uB,0BAGA,IAAbzqB,EAAErH,QACTqH,EAAErH,OAAOhB,QAAQ0tB,EAAOsF,UAG5B3qB,EAAEkW,QAAS,KAMZ0U,UAAP,SAAiB5qB,GACbA,EAAEkW,OAAS,EACXlW,EAAEwW,GAAKxW,EAAEb,EAAGa,EAAE6W,GAAK7W,EAAE8O,KAIlB+b,SAAP,SAAgB7qB,GACZA,EAAEkW,QAAS,QEv4BN4U,0BAaIC,iCAMLnxB,EAAImxB,SAEHnxB,EAAE+rB,YACEA,QAAU/rB,EAAE+rB,SAGhB/rB,EAAEgsB,SACEA,KAAOhsB,EAAEgsB,MAGbhsB,EAAE8wB,SACEA,KAAO9wB,EAAE8wB,MAGb9wB,EAAE4rB,OACEA,GAAK5rB,EAAE4rB,MAGXwF,UAAYlzB,EAAKqyB,UAAY9E,GAAO8E,YACpCc,QAAUnzB,EAAK6yB,QAAUtF,GAAOsF,4CAnCzChF,QAAA,SAAQ/tB,OACRguB,KAAA,eACA8E,KAAA,eACAlF,GAAA,SAAG0F,EAA+BzF,UAAsCluB,SANzC8tB,ICUtB8F,0BAkBGC,kBAAAA,IAAAA,EAAiBC,KAAKC,2BAEzBF,UAAYA,IACZ1F,MAAQ0F,EAAUG,SAAS1H,YAAUA,YAAU7W,OAAQ6W,YAAUA,YAAUgC,MAAOhC,YAAUA,YAAU/mB,UAEvG0uB,gBAECd,KAAO,eACHA,MACGA,EAAOU,EAAUK,SAASf,OACzBH,OAAOlF,GAAOgF,YACd7E,GAAG,sBAAuBH,GAAO8E,WACjC3E,GAAG,kBAAkB,SAAAxlB,GAClBqlB,GAAOqF,KAAK1qB,EAAQwrB,EAASJ,UAAU1F,OACvC8F,EAASvC,YAEZzD,GAAG,oBAAqBH,GAAOsF,aAGnC/D,UAAUlvB,OAAQ,OAAOgzB,OAKzBgB,KAAKhB,wCAvClB/E,QAAA,SAAQ/tB,OACA+zB,EAAU,CAAEl1B,KAAMotB,YAAUjsB,EAAEnB,MAAOwM,MAAOrL,EAAEqL,MAAOc,OAAQnM,EAAEmM,aAC9D2hB,MAAMiG,EAAQl1B,MAAMk1B,MAI7B/F,KAAA,2BACSwF,UAAUQ,OAAM,8BAAY/F,mBAqCrCL,GAAA,SAAG0F,EAA+BzF,eAErBC,MAAMF,GADU,iBAAd0F,EACOA,EAEArH,YAAUqH,GAFCzF,GAItBluB,SArD2B8tB,ICIjCwG,0BAsBGT,gCAEHA,UAAYA,IACZ1F,MAAQ0F,EAAUG,SAAS1H,YAAUA,YAAU7W,OAAQ6W,YAAUA,YAAUgC,MAAOhC,YAAUA,YAAU/mB,UAGvG0uB,gBAECd,KAAO,eACHA,MACGA,EAAOU,EAAUV,OAChBoB,QAAQzG,GAAOgF,YACf7E,GAAG,kBAAmBH,GAAO8E,WAC7B3E,GAAG,kBAAkB,SAAAxlB,GAClBqlB,GAAOqF,KAAU1qB,EAAGorB,EAAU1F,OAC9B8F,EAASvC,YAEZzD,GAAG,gBAAiBH,GAAOsF,aAG/B/D,UAAUlvB,OAAQ,OAAOgzB,EAK9B9D,UAAU,GAAG8E,KAAKhB,wCA7C1B/E,QAAA,SAAQ/tB,OACA+zB,EAAU,CAAEl1B,KAAMotB,YAAUjsB,EAAEnB,MAAOwM,MAAOrL,EAAEqL,MAAOc,OAAQnM,EAAEmM,aAG9D2hB,MAAMgG,KAAKC,EAAQl1B,KAAWk1B,MAIvC/F,KAAA,sBACQ5tB,EAAIT,KAAK6zB,UAAUQ,OAAM,kBAAMG,YAAMlG,cAAU7tB,EAAEoxB,aAyCzD5D,GAAA,SAAG0F,EAA+BzF,eAErBC,MAAMF,GADU,iBAAd0F,EACOA,EAEArH,YAAUqH,GAFCzF,GAItBluB,SA1D6B8tB,ICR3B2G,GAIT,SAAmBtzB,EAAmBsb,EAAwBva,WAA3Cf,YAAmBsb,gBAAwBva,OACrDwyB,UAA2B,IAAbxyB,GAAgD,IAApBA,EAAS/B,QAGnDw0B,GACT,SAAmBxzB,EAAmByG,EAAiB2P,EAAkBtW,EAAiC4mB,YAAjC5mB,IAAAA,EAAoB,eAAa4mB,IAAAA,EAAO,cAA9F1mB,SAAmByG,SAAiB2P,YAAkBtW,YAAiC4mB,GAGjG+M,yBAKUt0B,EAAeG,UAAfH,SAAeG,MAC1Bo0B,EAAKD,EAAyBE,UAAUx0B,EAAGG,GAC3Cs0B,EAAKt0B,EAAE6I,MAAM,GAAGmS,UAChBuZ,EAAKJ,EAAyBE,UAAUx0B,EAAGy0B,GAC3CF,EAAG10B,QAAU60B,EAAG70B,aACXA,OAAS00B,EAAG10B,YACZ8Z,GAAK4a,EAAG5a,QACRC,GAAK2a,EAAG3a,QACR+a,UAAW,SAEX90B,OAAS60B,EAAG70B,YACZ8Z,GAAK+a,EAAG/a,QACRC,GAAKzZ,EAAEN,OAAS60B,EAAG9a,GAAK8a,EAAG70B,YAC3B80B,UAAW,YAGTH,UAAP,SAAoBx0B,EAAQG,WAC5B0B,EAAI7B,EAAEH,OACNf,EAAIqB,EAAEN,OACN+0B,EAAQ,CAAE/0B,OAAQ,EAAG8Z,IAAK,EAAGC,IAAK,GAClCnU,EAAI,IAAItG,MAAM0C,GACTrC,EAAI,EAAGA,EAAIqC,EAAGrC,IAAK,CACxBiG,EAAEjG,GAAK,IAAIL,MAAML,OACZ,IAAIiC,EAAI,EAAGA,EAAIjC,EAAGiC,OACff,EAAER,KAAOW,EAAEY,GAAI,KACXkD,EAAIwB,EAAEjG,GAAGuB,GAAY,IAANvB,GAAiB,IAANuB,EAAW,EAAI0E,EAAEjG,EAAI,GAAGuB,EAAI,GAAK,EAC3DkD,EAAI2wB,EAAM/0B,SACV+0B,EAAM/0B,OAASoE,EACf2wB,EAAMjb,GAAKna,EAAIyE,EAAI,EACnB2wB,EAAMhb,GAAK7Y,EAAIkD,EAAI,QAEpBwB,EAAEjG,GAAGuB,GAAK,SAElB6zB,eAEXC,YAAA,kBACWn1B,KAAKG,QAAU,EAAIH,KAAKM,EAAEgJ,MAAMtJ,KAAKia,GAAIja,KAAKia,GAAKja,KAAKG,QAAU,SAQpEi1B,yBA0DUC,EAAuBC,EAAqCC,uBAAAA,IAAAA,EAAuB,uBAAnFF,oBAA4DE,cAzDvD,UA0DfrwB,MAAQmwB,EAAc3tB,KAAI,SAACnD,EAAGzE,UAAM,IAAI20B,GAAY30B,EAAGw1B,EAASE,UAAUjxB,GAAI+wB,EAASG,YAAYlxB,YACnGvD,OAAShB,KAAKkF,MAAMoZ,QAAO,SAAA/Z,UAAIA,EAAEmwB,aACjCtzB,OAASpB,KAAKkF,MAAMoZ,QAAO,SAAA9a,UAAKA,EAAEkxB,aAClCgB,KAAO11B,KAAK21B,aAAa,UACzBC,KAAO51B,KAAK21B,aAAa,UAGzBv0B,OAAOhB,SAAQ,SAAAmE,UAChBA,EAAErC,SAAS9B,SAAQ,SAAAiF,UAAI9E,EAAK2E,MAAcG,GAAG4iB,OAAS1jB,aAGrD8Q,KAAO,CAAEnT,SAAU,SACnBgD,MAAM9E,SAAQ,SAAAmE,QACS,IAAbA,EAAE0jB,SACT1jB,EAAE0jB,OAAS1nB,EAAK8U,KAChB9U,EAAK8U,KAAKnT,SAAStC,KAAK2E,EAAEpD,KAQ9BoD,EAAEsxB,MAAQ,WAITC,YAAc91B,KAAKkF,MAAMoE,MAAM,QAC/BwsB,YAAY3yB,MAAK,SAACyE,EAAG2P,UAAMhX,EAAKw1B,SAASnuB,GAAKrH,EAAKw1B,SAASxe,MAKzCvX,KAAK81B,YAAYxsB,MAAM,GAAGmS,UAAU6C,QAAO,SAAA9a,UAAKA,EAAEkxB,QACxDt0B,SAAQ,SAAAmE,OAClB8G,EAAI6L,EAAUC,QAClB5S,EAAErC,SAAS9B,SAAQ,SAAAiF,UAAIgG,EAAIA,EAAE4L,MAAM1W,EAAK2E,MAAMG,GAAGoX,SACjDlY,EAAEkY,KAAOpR,EAAE+L,QAAQ7W,EAAKg1B,qBAGxBS,EAAUh2B,KAAKi2B,UAAUj2B,KAAK01B,KAAKhuB,KAAI,SAAA2D,UAAIA,EAAEmP,QAC7C0b,EAAUl2B,KAAKi2B,UAAUj2B,KAAK41B,KAAKluB,KAAI,SAAA2D,UAAIA,EAAEmP,QAG7C2b,EAAOH,EAAQ,GAAII,EAAOJ,EAAQA,EAAQ71B,OAAS,GACnDk2B,EAAOH,EAAQ,GAAII,EAAOJ,EAAQA,EAAQ/1B,OAAS,GAGnDo2B,EAASv2B,KAAK41B,KAAKluB,KAAI,SAAA2D,SAAS,CAAEoN,GAAI0d,EAAMxd,GAAIyd,EAAM1d,GAAIrN,EAAEmP,IAAK5B,GAAIvN,EAAEmP,QACtE2B,OAAO+Z,EAAQxuB,KAAI,SAAAvF,SAAS,CAAEsW,GAAI0d,EAAMxd,GAAIyd,EAAM1d,GAAIvW,EAAGyW,GAAIzW,OAG9Dq0B,EAASx2B,KAAK01B,KAAKhuB,KAAI,SAAArC,SAAS,CAAEoT,GAAIpT,EAAEmV,IAAK7B,GAAItT,EAAEmV,IAAK9B,GAAI2d,EAAMzd,GAAI0d,MACrEna,OAAO6Z,EAAQtuB,KAAI,SAAAvF,SAAS,CAAEsW,GAAItW,EAAGwW,GAAIxW,EAAGuW,GAAI2d,EAAMzd,GAAI0d,OAG3DG,EAAQF,EAAOpa,OAAOqa,GAG1BC,EAAMr2B,SAAQ,SAAA2F,UAAIA,EAAE2wB,MAAQ,WAGvBA,MAAQ,QACRr3B,MAAQ,GAGbk3B,EAAOn2B,SAAQ,SAAAye,UACX2X,EAAOp2B,SAAQ,SAAAmE,OACPmF,EAAI,IAAIirB,GAAKp0B,EAAKm2B,MAAMv2B,OAAQoE,EAAEkU,GAAIoG,EAAEnG,IAC5CmG,EAAE6X,MAAM92B,KAAK8J,GACbnF,EAAEmyB,MAAM92B,KAAK8J,GACbnJ,EAAKm2B,MAAM92B,KAAK8J,WAGZ5J,EAAIS,EAAKu1B,YAAY31B,OAClBL,KAAM,GAAG,KACRmB,EAAOV,EAAKu1B,YAAYh2B,GACxBuL,EAAIpK,EAAKwb,KACTzP,EAAK9G,KAAKyG,IAAIjD,EAAE9B,EAAIyD,EAAEsM,MACtBU,EAAKnS,KAAKyG,IAAIjD,EAAE6N,EAAIlM,EAAEuM,SACtB5K,EAAK3B,EAAEiN,QAAU,GAAKD,EAAKhN,EAAEkN,SAAW,EAAG,CACrC7O,EAAGzI,KAAOA,gBAOhCw1B,EAAMr2B,SAAQ,SAAC2F,EAAG4wB,GAEdp2B,EAAK2E,MAAM9E,SAAQ,SAACmE,EAAGzE,GACnByE,EAAEkY,KAAKjE,kBAAkBzS,EAAE0S,GAAI1S,EAAE2S,GAAI3S,EAAE4S,GAAI5S,EAAE6S,IAAIxY,SAAQ,SAACw2B,EAAWv1B,OAE7DqI,EAAI,IAAIirB,GAAKp0B,EAAKm2B,MAAMv2B,OAAQy2B,EAAUhvB,EAAGgvB,EAAUrf,EAAGhT,EAAGwB,GACjExF,EAAKm2B,MAAM92B,KAAK8J,GAChB3D,EAAE2wB,MAAM92B,KAAK8J,GACbnF,EAAEsxB,MAAMj2B,KAAK8J,aAKjBmtB,EAAU3wB,KAAKyG,IAAI5G,EAAE2S,GAAK3S,EAAE6S,IAAM,GAClCke,EAAQ,SAACl1B,EAAGC,UAAMg1B,EAAUh1B,EAAE+F,EAAIhG,EAAEgG,EAAI/F,EAAE0V,EAAI3V,EAAE2V,GACpDxR,EAAE2wB,MAAMvzB,KAAK2zB,OACR,IAAIh3B,EAAI,EAAGA,EAAIiG,EAAE2wB,MAAMv2B,OAAQL,IAAK,KACjC2F,EAAIM,EAAE2wB,MAAM52B,EAAI,GAAIyE,EAAIwB,EAAE2wB,MAAM52B,GAChC2F,EAAExE,MAAQwE,EAAExE,OAASsD,EAAEtD,MAAQwE,EAAExE,KAAKyzB,MAC1Cn0B,EAAKlB,MAAMO,KAAK,CAAEZ,OAAQyG,EAAEtE,GAAIlC,OAAQsF,EAAEpD,GAAIhB,OAAQ+F,KAAKyG,IAAImqB,EAAMrxB,EAAGlB,qCA1J5EwyB,IAAA,SAAIn1B,UAAYA,EAAEoV,QAAO,SAACpP,EAAG2P,UAAM3P,EAAI2P,KAAK3V,EAAEzB,UAI9Cw1B,aAAA,SAAapvB,WACbywB,EAAU,GACVC,EAAKj3B,KAAKgB,OAAOsI,MAAM,EAAGtJ,KAAKgB,OAAOb,QACnC82B,EAAG92B,OAAS,GAAG,KAEd+2B,EAAcD,EAAG3Y,QAAO,SAAA/Z,UAAIA,EAAEkY,KAAK,UAAYlW,EAAK4wB,eAAeF,EAAG,GAAGxa,SACzE2a,EAAM,CACNlyB,MAAOgyB,EACP1c,IAAKxa,KAAK+2B,IAAIG,EAAYxvB,KAAI,SAAAnD,UAAIA,EAAEkY,KAAK,IAAMlW,UAEnDywB,EAAQp3B,KAAKw3B,GACbA,EAAIlyB,MAAM9E,SAAQ,SAAAmE,UAAI0yB,EAAGI,OAAOJ,EAAGK,QAAQ/yB,GAAI,aAEnDyyB,EAAQ7zB,MAAK,SAACvB,EAAGC,UAAMD,EAAE4Y,IAAM3Y,EAAE2Y,OAC1Bwc,KAIHjB,SAAA,SAASxxB,WACTgzB,EAAQ,EACLhzB,EAAE0jB,SAAWjoB,KAAKqV,MACrBkiB,IACAhzB,EAAIA,EAAE0jB,cAEHsP,KAIHtB,UAAA,SAAUr0B,MACG,IAAbA,EAAEzB,aACK,CAACyB,EAAE,YAGVmF,EAAMnF,EAAE,GAAKA,EAAE,GACf41B,EAAO,CAAC51B,EAAE,GAAKmF,EAAM,GAChBjH,EAAI,EAAGA,EAAI8B,EAAEzB,OAAQL,IAC1B03B,EAAK53B,MAAMgC,EAAE9B,GAAK8B,EAAE9B,EAAI,IAAM,UAElC03B,EAAK53B,KAAKgC,EAAEA,EAAEzB,OAAS,GAAK4G,EAAM,GAC3BywB,KAwHHC,YAAA,SAAYlzB,OACZmzB,EAAU,CAACnzB,MAGXmzB,EAAQ93B,KADR2E,EAAIA,EAAE0jB,cAED1jB,IAAMvE,KAAKqV,aACbqiB,EAAQjc,aAIXkc,wBAAA,SAAwB/1B,EAAGC,WAC3B+1B,EAAK53B,KAAKy3B,YAAY71B,GAAIi2B,EAAK73B,KAAKy3B,YAAY51B,GAAI/B,EAAI,EACrD83B,EAAG93B,KAAO+3B,EAAG/3B,IAAIA,UAEjB,CAAEg4B,eAAgBF,EAAG93B,EAAI,GAAIi4B,SAAUH,EAAGtuB,MAAMxJ,GAAGqc,OAAO0b,EAAGvuB,MAAMxJ,QAK9Ek4B,iBAAA,SAAiBp2B,EAAGC,cACZ8gB,EAAO3iB,KAAK23B,wBAAwB/1B,EAAGC,GACvCo2B,EAAgB,GACpBtV,EAAKoV,SAAS33B,SAAQ,SAAAmE,UAAI0zB,EAAc1zB,EAAEpD,IAAM,UAC5C+2B,EAAYvV,EAAKmV,eAAe51B,SAASoc,QAAO,SAAA/Z,WAAMA,KAAK0zB,aAE/DtV,EAAKoV,SACAzZ,QAAO,SAAA/Z,UAAIA,EAAE0jB,SAAWtF,EAAKmV,kBAC7B13B,SAAQ,SAAAmE,UAAI2zB,EAAYA,EAAU/b,OAAO5X,EAAE0jB,OAAO/lB,SAASoc,QAAO,SAAAjZ,UAAIA,IAAMd,EAAEpD,UAE5E+2B,EAAUxwB,KAAI,SAAAnD,UAAIV,EAAKqB,MAAMX,SAKjC4zB,eAAP,SAAsBC,EAAQxwB,EAAG2P,WAEzB8gB,EAAY,GACPC,EAAK,EAAGA,EAAKF,EAAOj4B,OAAQm4B,YAC7B7F,EAAQ2F,EAAOE,GACVre,EAAK,EAAGA,EAAKwY,EAAMtyB,OAAQ8Z,KAC5B3Z,EAASmyB,EAAMxY,IACjBse,OAASD,EACXh4B,EAAER,EAAIma,EAEF/T,KAAKyG,IADCrM,EAAE,GAAGsH,GAAKtH,EAAE,GAAGsH,IACL,IAChBywB,EAAUz4B,KAAKU,GAI3B+3B,EAAUl1B,MAAK,SAACvB,EAAGC,UAAMD,EAAE,GAAGgG,GAAK/F,EAAE,GAAG+F,cAGpC4wB,EAAe,GACfC,EAAa,KACR34B,EAAI,EAAGA,EAAIu4B,EAAUl4B,OAAQL,IAAK,KACnCQ,EAAI+3B,EAAUv4B,KACb24B,GAAcvyB,KAAKyG,IAAIrM,EAAE,GAAGsH,GAAK6wB,EAAWje,KAAO,KAEpDge,EAAa54B,KADb64B,EAAa,CAAEje,IAAKla,EAAE,GAAGsH,GAAI8wB,SAAU,KAG3CD,EAAWC,SAAS94B,KAAKU,UAEtBk4B,KAUJG,UAAP,SAAiB/wB,EAAW2P,EAAW6gB,EAAQM,EAAUE,EAAQ7xB,OACzD3H,EAAIs5B,EAASv4B,YACbf,GAAK,YACLwF,EAAK8zB,EAAShxB,KAAI,SAAApH,UAAK,IAAIqP,EAASrP,EAAE,GAAGsH,OACzCuL,EAAK,GACArT,EAAI,EAAGA,EAAIV,EAAGU,QACd,IAAIuB,EAAI,EAAGA,EAAIjC,EAAGiC,OACfvB,IAAMuB,OACNwtB,EAAK6J,EAAS54B,GAEd+4B,EAAKhK,EAAG0J,OACRO,EAFKJ,EAASr3B,GAENk3B,OACRQ,GAAQ,EACRC,GAAQ,EAMH,KAALpxB,EACIgxB,EAAOC,EAAIC,KAEPjK,EAAG,GAAGtX,GAAKsX,EAAG,GAAGtX,IACjBwhB,EAAO13B,EAAG23B,EAAOl5B,IAEjBi5B,EAAOj5B,EAAGk5B,EAAO33B,IAIrBu3B,EAAOC,EAAIC,KACPjK,EAAG,GAAGtX,GAAKsX,EAAG,GAAGtX,IACjBwhB,EAAOj5B,EAAGk5B,EAAO33B,IAEjB03B,EAAO13B,EAAG23B,EAAOl5B,IAIzBi5B,GAAQ,GAER5lB,EAAGvT,KAAK,IAAI0P,EAAW1K,EAAGm0B,GAAOn0B,EAAGo0B,GAAOjyB,IAI1C,IAAIiM,EAAOpO,EAAIuO,GACrBQ,QACP/O,EAAGxE,SAAQ,SAACmE,EAAGzE,OACPQ,EAAIo4B,EAAS54B,GACb0a,EAAMjW,EAAEmL,WACZpP,EAAE,GAAGsH,GAAKtH,EAAE,GAAGsH,GAAK4S,MAChBiY,EAAQ2F,EAAO93B,EAAEi4B,QACjBj4B,EAAER,EAAI,IAAG2yB,EAAMnyB,EAAER,EAAI,GAAG,GAAG8H,GAAK4S,GAChCla,EAAER,EAAI2yB,EAAMtyB,OAAS,IAAGsyB,EAAMnyB,EAAER,EAAI,GAAG,GAAG8H,GAAK4S,UAIpDye,cAAP,SAAqBb,EAAQxwB,EAAW2P,EAAWqhB,EAA6C7xB,WACxFyxB,EAAepD,EAAW+C,eAAeC,EAAQxwB,EAAG2P,GAE/CzX,EAAI,EAAGA,EAAI04B,EAAar4B,OAAQL,IAAK,SACtCo5B,EAAKV,EAAa14B,GAClB+c,EAAS,GACJxb,EAAI,EAAGA,EAAI63B,EAAGR,SAASv4B,OAAQkB,IAAK,KACrCf,EAAI44B,EAAGR,SAASr3B,GACpBwb,EAAOjd,KAAK,CAAEV,KAAM,EAAGoB,EAAGA,EAAGka,IAAKtU,KAAKG,IAAI/F,EAAE,GAAGiX,GAAIjX,EAAE,GAAGiX,MACzDsF,EAAOjd,KAAK,CAAEV,KAAM,EAAGoB,EAAGA,EAAGka,IAAKtU,KAAKuI,IAAInO,EAAE,GAAGiX,GAAIjX,EAAE,GAAGiX,MAE7DsF,EAAO1Z,MAAK,SAACvB,EAAGC,UAAMD,EAAE4Y,IAAM3Y,EAAE2Y,IAAM5Y,EAAE1C,KAAO2C,EAAE3C,YAC7Cic,EAAO,GACPge,EAAY,EAChBtc,EAAOzc,SAAQ,SAAAC,GACI,IAAXA,EAAEnB,MACFic,EAAKvb,KAAKS,EAAEC,GACZ64B,KAEAA,IAEa,GAAbA,IACA/D,EAAWuD,UAAU/wB,EAAG2P,EAAG6gB,EAAQjd,EAAMyd,EAAQ7xB,GACjDoU,EAAO,WAavBie,WAAA,SAAiB/5B,EAAeg6B,EAAkBr6B,EAA6BC,cACvEq6B,EAAaj6B,EAAMqI,KAAI,SAAArH,UAAI4D,EAAKwuB,MAAMzzB,EAAOqB,GAAIpB,EAAOoB,OACxDk5B,EAAQnE,EAAWoE,WAAWF,GAC9BlB,EAASkB,EAAW5xB,KAAI,SAAUrH,UAAY+0B,EAAWqE,aAAap5B,aAC1E+0B,EAAW6D,cAAcb,EAAQ,IAAK,IAAKmB,EAAOF,GAClDjE,EAAW6D,cAAcb,EAAQ,IAAK,IAAKmB,EAAOF,GAClDjE,EAAWsE,eAAetB,EAAQkB,GAC3BlB,KAKJsB,eAAP,SAAsBtB,EAAQkB,GAC1BlB,EAAOh4B,SAAQ,SAACs4B,EAAU54B,GACXw5B,EAAWx5B,GACNm1B,WACZyD,EAASjd,UACTid,EAASt4B,SAAQ,SAAUu5B,GACvBA,EAAQle,oBAMjBme,mBAAP,SAA0BC,EAAgBC,OAClCC,EAAS7zB,KAAK8zB,MAAMH,EAAM,GAAGtiB,EAAIsiB,EAAM,GAAGtiB,EAC1CsiB,EAAM,GAAGjyB,EAAIiyB,EAAM,GAAGjyB,GACtBqyB,EAAS/zB,KAAK8zB,MAAMF,EAAM,GAAGviB,EAAIuiB,EAAM,GAAGviB,EAC1CuiB,EAAM,GAAGlyB,EAAIkyB,EAAM,GAAGlyB,GACtBsyB,EAAOH,EAASE,SAChBC,EAAOh0B,KAAKi0B,IAAMD,GAAQh0B,KAAKi0B,MAC/BD,EAAOD,EAASF,GAEbG,KAIIlX,OAAP,SAAcphB,EAAGC,EAAGwD,UACfxD,EAAE+F,EAAIhG,EAAEgG,IAAMvC,EAAEkS,EAAI3V,EAAE2V,IAAM1V,EAAE0V,EAAI3V,EAAE2V,IAAMlS,EAAEuC,EAAIhG,EAAEgG,IAAO,KAKvDwyB,SAAP,SAAgBC,WAChBz5B,EAAW,GACNd,EAAI,EAAGA,EAAIu6B,EAAMl6B,OAAQL,IAAK,KAC/B4J,EAAI2wB,EAAMv6B,QACe,IAAlBc,EAAS8I,EAAE3D,KAAoBnF,EAAS8I,EAAE3D,GAAK,IAC1DnF,EAAS8I,EAAE3D,GAAG2D,EAAE2B,IAAK,SAElB,SAACtF,EAAGsF,eAA6B,IAAhBzK,EAASmF,IAAsBnF,EAASmF,GAAGsF,OAKhEmuB,WAAP,SAAkBn6B,WACVi7B,EAAY,GACPx6B,EAAI,EAAGA,EAAIT,EAAMc,OAAS,EAAGL,QAC7B,IAAIuB,EAAIvB,EAAI,EAAGuB,EAAIhC,EAAMc,OAAQkB,IAAK,KAInCoE,EAAGmB,EAAIyc,EAHPhjB,EAAIhB,EAAMS,GACV4E,EAAIrF,EAAMgC,GACVk5B,EAAM,IAAI3F,GAAyBv0B,EAAGqE,GAEvB,IAAf61B,EAAIp6B,SAEJo6B,EAAItF,WAGJvwB,EAAE+W,UACF/W,EAAEuwB,UAAW,EACbsF,EAAM,IAAI3F,GAAyBv0B,EAAGqE,KAErC61B,EAAItgB,IAAM,GAAKsgB,EAAIrgB,IAAM,KACzBqgB,EAAItgB,GAAKsgB,EAAIp6B,QAAUE,EAAEF,QAAUo6B,EAAIrgB,GAAKqgB,EAAIp6B,QAAUuE,EAAEvE,QAE7Dm6B,EAAU16B,KAAK,CAAEmG,EAAGjG,EAAGuL,EAAGhK,KAG1Bk5B,EAAItgB,GAAKsgB,EAAIp6B,QAAUE,EAAEF,QAAUo6B,EAAIrgB,GAAKqgB,EAAIp6B,QAAUuE,EAAEvE,QAM5DsF,EAAIpF,EAAEk6B,EAAItgB,GAAK,GACfoJ,EAAKhjB,EAAEk6B,EAAItgB,GAAK,GAChBrT,EAAKlC,EAAE61B,EAAIrgB,GAAK,KAEhBzU,EAAIpF,EAAEk6B,EAAItgB,GAAKsgB,EAAIp6B,OAAS,GAC5ByG,EAAKvG,EAAEk6B,EAAItgB,GAAKsgB,EAAIp6B,QACpBkjB,EAAK3e,EAAE61B,EAAIrgB,GAAKqgB,EAAIp6B,SAEpBi1B,EAAWpS,OAAOvd,EAAGmB,EAAIyc,GACzBiX,EAAU16B,KAAK,CAAEmG,EAAG1E,EAAGgK,EAAGvL,IAE1Bw6B,EAAU16B,KAAK,CAAEmG,EAAGjG,EAAGuL,EAAGhK,aAK/B+zB,EAAWgF,SAASE,MAMxBb,aAAP,SAAoB9W,YACP6X,EAAU9wB,SACD,CAAE9B,EAAG8B,EAAE9B,EAAG2P,EAAG7N,EAAE6N,WAE7BkjB,EAAa,SAAC74B,EAAGC,EAAGwD,UAAMa,KAAKyG,KAAK9K,EAAE+F,EAAIhG,EAAEgG,IAAMvC,EAAEkS,EAAI3V,EAAE2V,IAAM1V,EAAE0V,EAAI3V,EAAE2V,IAAMlS,EAAEuC,EAAIhG,EAAEgG,IAAM,MAC5F8wB,EAAW,GACX92B,EAAI44B,EAAU7X,EAAK,IACd7iB,EAAI,EAAGA,EAAI6iB,EAAKxiB,OAAQL,IAAK,KAC9B+B,EAAI24B,EAAU7X,EAAK7iB,IAAKuF,EAAIvF,EAAI6iB,EAAKxiB,OAAS,EAAIwiB,EAAK7iB,EAAI,GAAK,KAC/DuF,GAAMo1B,EAAW74B,EAAGC,EAAGwD,KACxBqzB,EAAS94B,KAAK,CAACgC,EAAGC,IAClBD,EAAIC,UAGL62B,KAKXjG,MAAA,SAAMnyB,EAAWG,cACTzB,EAASgB,KAAKkF,MAAc5E,GAAIrB,EAASe,KAAKkF,MAAczE,QAC3Dy3B,UAAYl4B,KAAKg4B,iBAAiBh5B,EAAQC,OAE3Cy7B,EAAiB,QAChBxC,UAAU93B,SAAQ,SAAAiC,UAAKq4B,EAAer4B,EAAElB,IAAMkB,UAC9Cs4B,cAAgB36B,KAAKX,MAAMif,QAAO,SAAAje,OAC/BoF,EAAIqH,EAAK4pB,MAAMr2B,EAAErB,QACjBuF,EAAIuI,EAAK4pB,MAAMr2B,EAAEpB,gBACZwG,EAAExE,MAAQwE,EAAExE,KAAKE,MAAMu5B,GACzBn2B,EAAEtD,MAAQsD,EAAEtD,KAAKE,MAAMu5B,UAI7B,IAAI56B,EAAI,EAAGA,EAAId,EAAO62B,MAAM11B,OAAQL,SAGhC66B,cAAc/6B,KAAK,CACpBZ,OAHIA,EAAO62B,MAAM,GAAG10B,GAIpBlC,OAHID,EAAO62B,MAAM/1B,GAAGqB,GAIpBhB,OAAQ,QAGPL,EAAI,EAAGA,EAAIb,EAAO42B,MAAM11B,OAAQL,SAGhC66B,cAAc/6B,KAAK,CACpBZ,OAHIC,EAAO42B,MAAM,GAAG10B,GAIpBlC,OAHIA,EAAO42B,MAAM/1B,GAAGqB,GAIpBhB,OAAQ,QAwBZy6B,EAhByB,IAAI/Y,GAAW7hB,KAAK02B,MAAMv2B,OAAQH,KAAK26B,eAJpD,SAAAt6B,UAAIA,EAAErB,UACN,SAAAqB,UAAIA,EAAEpB,UACN,SAAAoB,UAAIA,EAAEF,UAaoBgiB,+BACtCnjB,EAAO62B,MAAM,GAAG10B,GAAIlC,EAAO42B,MAAM,GAAG10B,IAXtB,SAACsE,EAAGlB,EAAGoB,OACjB/D,EAAIkL,EAAK4pB,MAAMjxB,GAAI5D,EAAIiL,EAAK4pB,MAAMnyB,GAAIc,EAAIyH,EAAK4pB,MAAM/wB,GACrDqH,EAAK9G,KAAKyG,IAAItH,EAAEuC,EAAIhG,EAAEgG,GAAIyQ,EAAKnS,KAAKyG,IAAItH,EAAEkS,EAAI3V,EAAE2V,UAEhD3V,EAAEX,OAASjC,GAAU4C,EAAEX,OAASY,EAAEZ,MAAQY,EAAEZ,OAAShC,GAAU4C,EAAEZ,OAASoE,EAAEpE,KACrE,EACJ+L,EAAK,GAAKqL,EAAK,EAAI,IAAO,KASPoD,UAAU/T,KAAI,SAAAd,UAAMkG,EAAK4pB,MAAM9vB,aAC7Dg0B,EAAWh7B,KAAKI,KAAKkF,MAAMjG,EAAOkC,IAAI00B,MAAM,IAGrC+E,EAAWtc,QAAO,SAAC/Z,EAAGzE,WACvBA,EAAI86B,EAAWz6B,OAAS,GAAKy6B,EAAW96B,EAAI,GAAGmB,OAASjC,GAAUuF,EAAEtD,OAASjC,GACxEc,EAAI,GAAKyE,EAAEtD,OAAShC,GAAU27B,EAAW96B,EAAI,GAAGmB,OAAShC,SAGjE47B,aAAP,SAAoBpI,EAAkBqI,EAAsBC,EAAoBC,OAyDpErE,EACA/uB,EAAa2P,EAIb0jB,EAAcC,EA7DlB52B,EAAS,CACT62B,UAAW,KAAO1I,EAAM,GAAG,GAAG7qB,EAAI,IAAM6qB,EAAM,GAAG,GAAGlb,EAAI,IACxD6jB,UAAW,OAEX3I,EAAMtyB,OAAS,MACV,IAAIL,EAAI,EAAGA,EAAI2yB,EAAMtyB,OAAQL,IAAK,KAG/BkN,GADApF,GADA+uB,EAAKlE,EAAM3yB,IACJ,GAAG8H,GACD+uB,EAAG,GAAG/uB,EACfyQ,GAFad,EAAIof,EAAG,GAAGpf,GAEdof,EAAG,GAAGpf,KACfzX,EAAI2yB,EAAMtyB,OAAS,EAAG,CAClB+F,KAAKyG,IAAIK,GAAM,EACfpF,GAAKoF,EAAK9G,KAAKyG,IAAIK,GAAM8tB,EAEzBvjB,GAAKc,EAAKnS,KAAKyG,IAAI0L,GAAMyiB,EAE7Bx2B,EAAO62B,WAAa,KAAOvzB,EAAI,IAAM2P,EAAI,QACrCxR,EAAI0sB,EAAM3yB,EAAI,GACdkM,EAAKjG,EAAE,GAAG6B,EAAG4W,EAAKzY,EAAE,GAAGwR,EAG3BvK,EAFSjH,EAAE,GAAG6B,EAEJoE,EACVqM,EAFStS,EAAE,GAAGwR,EAEJiH,MAGN7F,EAAIC,EAFJyiB,EAAQjG,EAAWwE,mBAAmBjD,EAAI5wB,GAAK,EAAI,EAAI,EAGvDG,KAAKyG,IAAIK,GAAM,GACf2L,EAAK3M,EAAKgB,EAAK9G,KAAKyG,IAAIK,GAAM8tB,EAC9BliB,EAAK4F,IAEL7F,EAAK3M,EACL4M,EAAK4F,EAAKnG,EAAKnS,KAAKyG,IAAI0L,GAAMyiB,OAE9BnjB,EAAKzR,KAAKyG,IAAIgM,EAAK/Q,GACnBgQ,EAAK1R,KAAKyG,IAAIiM,EAAKrB,GACvBjT,EAAO62B,WAAa,KAAOxjB,EAAK,IAAMC,EAAK,QAAUyjB,EAAQ,IAAM1iB,EAAK,IAAMC,EAAK,QAChF,KACC0iB,EAAW,CAAC1zB,EAAG2P,GAEfrR,KAAKyG,IAAIK,GAAM,GAEfiuB,EAAe,CADfrzB,GAAKoF,EAAK9G,KAAKyG,IAAIK,GAAMguB,EACNzjB,EAAIwjB,GACvBG,EAAe,CAACtzB,EAAG2P,EAAIwjB,KAGvBE,EAAe,CAACrzB,EAAImzB,EADpBxjB,GAAKc,EAAKnS,KAAKyG,IAAI0L,GAAM2iB,GAEzBE,EAAe,CAACtzB,EAAImzB,EAAYxjB,IAEpCjT,EAAO62B,WAAa,KAAOvzB,EAAI,IAAM2P,EAAI,IACrCyjB,EAAc,IACd12B,EAAO82B,UAAY,KAAOE,EAAS,GAAK,IAAMA,EAAS,GAAK,MAAQL,EAAa,GAAK,IAAMA,EAAa,GACvG,MAAQC,EAAa,GAAK,IAAMA,EAAa,UAOvDluB,GADApF,GADA+uB,EAAKlE,EAAM,IACJ,GAAG7qB,GACD+uB,EAAG,GAAG/uB,EACfyQ,GAFad,EAAIof,EAAG,GAAGpf,GAEdof,EAAG,GAAGpf,EACf+jB,EAAW,CAAC1zB,EAAG2P,GAEfrR,KAAKyG,IAAIK,GAAM,GAEfiuB,EAAe,CADfrzB,GAAKoF,EAAK9G,KAAKyG,IAAIK,GAAMguB,EACNzjB,EAAIwjB,GACvBG,EAAe,CAACtzB,EAAG2P,EAAIwjB,KAGvBE,EAAe,CAACrzB,EAAImzB,EADpBxjB,GAAKc,EAAKnS,KAAKyG,IAAI0L,GAAM2iB,GAEzBE,EAAe,CAACtzB,EAAImzB,EAAYxjB,IAEpCjT,EAAO62B,WAAa,KAAOvzB,EAAI,IAAM2P,EAAI,IACrCyjB,EAAc,IACd12B,EAAO82B,UAAY,KAAOE,EAAS,GAAK,IAAMA,EAAS,GAAK,MAAQL,EAAa,GAAK,IAAMA,EAAa,GACvG,MAAQC,EAAa,GAAK,IAAMA,EAAa,WAGhD52B,QCxpBbspB,GAAkBD,KAEX4N,yBAEcv8B,EAAuBC,eAAvBD,cAAuBC,qBAC1Cu8B,aAAA,SAAa5zB,qBACF1B,KAAKC,KACRyB,EAAEoP,QAAO,SAAC3R,EAAWd,OACXyI,EAAKzI,EAAEhE,EAAKtB,QAAUsF,EAAEhE,EAAKvB,eAC5BqG,EAAI2H,EAAKA,IACjB,UAiBFyuB,yBAMUv2B,EAAwBC,EAAwBu2B,uBAAAA,IAAAA,EAA0B,cAA1Ex2B,aAAwBC,uBAAwBu2B,mBAF9C,iCAqBY,OAlBxBp3B,OAAS,IAAI7E,MAAMg8B,EAAS35B,OAC5B,IAAIhC,EAAI,EAAGA,EAAI27B,EAAS35B,IAAKhC,OACzBwE,OAAOxE,GAAK,IAAIL,MAAMyF,EAAM/E,QAErC+E,EAAM9E,SAAQ,SAACmE,EAAGzE,iBACE27B,EAASE,qBAAM,KAAtB5d,eACgB,IAAVxZ,EAAEwZ,KAAqBxZ,EAAEwZ,GAAO7X,KAAK+E,UAEpDpH,EAAKS,OAAO,GAAGxE,GAAKyE,EAAEqD,EACtB/D,EAAKS,OAAO,GAAGxE,GAAKyE,EAAEgT,EACtB1T,EAAKS,OAAO,GAAGxE,GAAKyE,EAAEq3B,gCAI9BC,WAAA,SAAW91B,UACAA,EAAEy1B,aAAax7B,KAAKsE,WAMzBmR,eAAMlJ,YAAAA,IAAAA,EAAqB,eACnBvM,KAAJZ,EAAI0N,EAAK5H,MAAM/E,OAEjBb,EAAe,IAAIw8B,GAEnBhvB,EAAKivB,uBACL31B,EAAmB0G,EAAK3H,MAAO7F,EAAc,OAE5C6F,MAAM/E,SAAQ,SAAAC,UAAKA,EAAEF,QAAU2M,EAAK4uB,uBAGnC7L,EAAkB,IAAIhO,GAAWziB,EAAG0N,EAAK3H,OAC3C,SAAA9E,UAAIA,EAAErB,UAAQ,SAAAqB,UAAIA,EAAEpB,UAAQ,SAAAoB,UAAKA,EAAEF,UAAS4hB,iBAE1C7Z,EAAID,EAAQ6C,mBAAmB1L,GAAG,SAACU,EAAGuB,UAAMwuB,EAAe/vB,GAAGuB,MAIhE8G,EAAIF,EAAQ6C,mBAAmB1L,GAAG,kBAAqB,cACtD+F,MAAM/E,SAAQ,gBAAGpB,IAAAA,OAAQC,IAAAA,cAAakJ,EAAEnJ,GAAQC,GAAUkJ,EAAElJ,GAAQD,GAAU,qBAE5D4uB,mBAAjB2D,KACDyK,QAAU,IAAI/zB,EAAQ6E,EAAKxI,OAAQ4D,OAAGiO,EAAWob,KACjDyK,QAAQpvB,UAAY,OACpBovB,QAAQ7zB,EAAIA,EAAET,KAAI,SAAAqG,UAAM,IAAIxF,aAAawF,MAI1CjB,EAAKpG,cACLoG,EAAKkvB,QAAQ9vB,QAAU,IAAIoR,EAAwBxQ,EAAK5H,MAAO,KAAM,KAAM4H,EAAKpG,aAAa+Y,wBAE5F,IAAI3f,EAAI,EAAGA,EAAIgN,EAAK5H,MAAM/E,OAAQL,IAAK,KACpCyE,EAAIuI,EAAK5H,MAAMpF,GACfyE,EAAEoa,SACGqd,QAAQn0B,MAAM9H,IAAID,EAAG,CAACyE,EAAEqD,EAAGrD,EAAEgT,EAAGhT,EAAEq3B,aAI1CI,QAAQ1vB,IAAIC,8CAIrB+hB,KAAA,gBACS0N,QAAQn0B,MAAMC,YACd,IAAIhI,EAAI,EAAGA,EAAIE,KAAKkF,MAAM/E,OAAQL,IAAK,KACpCyE,EAAIvE,KAAKkF,MAAMpF,GACfyE,EAAEoa,YACGqd,QAAQn0B,MAAM9H,IAAID,EAAG,CAACyE,EAAEqD,EAAGrD,EAAEgT,EAAGhT,EAAEq3B,WAGxC57B,KAAKg8B,QAAQtvB,mBA7EjB+uB,QAAO,CAAC,IAAK,IAAK,KAClBA,KAAIA,GAASE,KAAKx7B,WAgFvB27B,uDACFt7B,eAAA,SAAeH,UAAyBA,EAAErB,UAC1C0B,eAAA,SAAeL,UAAyBA,EAAEpB,UAC1C6iB,UAAA,SAAUzhB,UAAyBA,EAAEF,UACrC6F,UAAA,SAAU3F,EAAQ0F,GAAa1F,EAAEF,OAAS4F,mIVlFnBk2B,OAELn8B,EADd0jB,EAAIyY,EAAE3yB,MAAM,GAAGnG,MAAK,SAACvB,EAAGC,UAAMD,EAAEgG,IAAM/F,EAAE+F,EAAI/F,EAAE+F,EAAIhG,EAAEgG,EAAI/F,EAAE0V,EAAI3V,EAAE2V,KAChEnY,EAAI68B,EAAE97B,OAEN+e,EAAOsE,EAAE,GAAG5b,MACX9H,EAAI,EAAGA,EAAIV,GACRokB,EAAE1jB,GAAG8H,IAAMsX,IADEpf,OAGjBo8B,EAASp8B,EAAI,EACbq8B,EAAa,MACjBA,EAAEv8B,KAAK4jB,EAPM,IAQT0Y,IAAW98B,EAAI,EACXokB,EAAE0Y,GAAQ3kB,IAAMiM,EATX,GASqBjM,GAC1B4kB,EAAEv8B,KAAK4jB,EAAE0Y,QACV,KAECE,EAAQC,EAASj9B,EAAI,EACrB+f,EAAOqE,EAAEpkB,EAAI,GAAGwI,MACf9H,EAAIV,EAAI,EAAGU,GAAK,GACb0jB,EAAE1jB,GAAG8H,IAAMuX,EADKrf,SAExBs8B,EAASt8B,EAAI,EAGbA,EAAIo8B,IACKp8B,GAAKs8B,QAENpZ,GAAOQ,EAvBN,GAuBiBA,EAAE4Y,GAAS5Y,EAAE1jB,KAAO,GAAKA,EAAIs8B,SAG5CD,EAAEh8B,OAAS,KAGV6iB,GAAOmZ,EAAEA,EAAEh8B,OAAS,GAAIg8B,EAAEA,EAAEh8B,OAAS,GAAIqjB,EAAE1jB,IAAM,IAGjDq8B,EAAEh8B,QAAU,EAhCf,GAkCDL,GAAaq8B,EAAEv8B,KAAK4jB,EAAE1jB,IAI1Bu8B,GAAUD,GACVD,EAAEv8B,KAAK4jB,EAAE6Y,QACTC,EAAMH,EAAEh8B,WACZL,EAAIs8B,IACKt8B,GAAKo8B,QAENlZ,GAAOQ,EAAE6Y,GAAS7Y,EAAE0Y,GAAS1Y,EAAE1jB,KAAO,GAAKA,EAAIo8B,SAG5CC,EAAEh8B,OAASm8B,KAGVtZ,GAAOmZ,EAAEA,EAAEh8B,OAAS,GAAIg8B,EAAEA,EAAEh8B,OAAS,GAAIqjB,EAAE1jB,IAAM,IAGjDq8B,EAAEh8B,QAAU,EArDf,GAuDDL,GAAaq8B,EAAEv8B,KAAK4jB,EAAE1jB,YAG3Bq8B,+FA6LyB1Y,EAAYK,UACrCD,GAAkBJ,EAAGK,EAAGF,GAAqBA,GAAqBN,GAAOA,oCAVhDG,EAAYK,OACxC5W,EAAKoX,GAAoBR,EAAGL,SACzB,CAAEM,GAAI7W,EAAG8W,GAAIA,GAAI9W,EAAG6W,sKU5P3B,SACWnc,EACA2P,EACAqkB,YAFAh0B,IAAAA,EAAY,YACZ2P,IAAAA,EAAY,YACZqkB,IAAAA,EAAY,UAFZh0B,SACA2P,SACAqkB,mNVoQqBnY,EAAYK,UACrCD,GAAkBJ,EAAGK,EAAGP,GAAqBA,GAAqBH,GAAOA,uLMvP3DoQ,UACd,IAAID,GAAeC,sDNwDO9pB,EAAU8Z,EAAY9e,GACvD8e,EAAEla,MAAM,GAAGnG,MACP,SAACvB,EAAGC,UAAMqE,KAAK8zB,MAAMp4B,EAAE2V,EAAI7N,EAAE6N,EAAG3V,EAAEgG,EAAI8B,EAAE9B,GAAK1B,KAAK8zB,MAAMn4B,EAAE0V,EAAI7N,EAAE6N,EAAG1V,EAAE+F,EAAI8B,EAAE9B,MACzExH,QAAQsE,gDWzEImvB,UACjBA,GAMT,SAAgBA,UAECA,EAAW0I,SAAqD,OAApC1I,EAAW0I,QAAQrH,MAD9C,QAPIsH,CAAO3I,GACd,IAAID,GAAqBC,GAE7B,IAAIS,GAAuBT,sNC7Bd4I,EAAUpD,EAAkBqD,EAAgBC,UAChEF,EAASG,KAAKnnB,MAAM,EAAG,EAAG,EAAG,IAAI,GAKrC,SAAevQ,EAAO9D,EAAQs7B,EAAgBC,GAC1Cz3B,EAAM9E,SAAQ,SAAAqI,GACVA,EAAEo0B,WAAkB,CAChBC,KAAMr0B,EAAEq0B,KACR/lB,OAAQtO,EAAEsO,OAAOK,SAASslB,OAGlCt7B,EAAOhB,SAAQ,SAAAqI,GACXA,EAAEo0B,WAAkB,CAChB9lB,OAAQtO,EAAEsO,OAAOK,SAASulB,GAC1Bz6B,eAA+B,IAAbuG,EAAErH,OAAyBqH,EAAErH,OAAOsG,KAAI,SAAArC,UAAIH,EAAM/E,OAASkF,EAAElE,MAAM,IAChFgb,YAA2B,IAAb1T,EAAEzH,OAAyByH,EAAEzH,OAAO0G,KAAI,SAAArC,UAAIA,EAAE6B,SAAS,YAG9E61B,EAAkB73B,EAAMiX,OAAO/a,GAAQsG,KAAI,SAACe,EAAG3I,UAC/C2I,EAAEo0B,WAAW17B,GAAKrB,EACX2I,EAAEo0B,qBAEN,IAAIzH,GAAW2H,EAAiB,CACnCtH,YAAa,SAAClxB,UAAWA,EAAErC,UAC3BszB,UAAW,SAAAjxB,UAAKA,EAAEwS,SACnB2lB,EAASC,GAzBKlK,CAAMgK,EAASG,KAAK13B,QAASu3B,EAASG,KAAKx7B,SAAUs7B,EAAQC,GAC5DvD,WAAgBqD,EAASO,WAAW13B,WAAY+zB,GAAU,SAAAh5B,UAAIA,EAAErB,OAAO69B,WAAW17B,MAAI,SAAAd,UAAIA,EAAEpB,OAAO49B,WAAW17B,qGZgcnGuI,EAAY2Y,MACjC0E,GAAUrd,EAAG2Y,GAAI,OAAO,KACxB0E,GAAU1E,EAAG3Y,GAAI,OAAO,MACvB,IAAI5J,EAAI,EAAGV,EAAIsK,EAAEvJ,OAAQL,EAAIV,IAAKU,EAAG,KAClCyE,EAAImF,EAAE5J,GAAI2F,EAAIiE,EAAE5J,EAAI,MACpBgmB,GAAW,IAAIhD,GAAYrd,EAAEmC,EAAGnC,EAAE8R,EAAGhT,EAAEqD,EAAGrD,EAAEgT,GAAI8K,GAAGliB,OAAS,EAAG,OAAO,SAEvE,mCY3aXioB,EACA7T,EACA0oB,OAGID,EACJ5U,EAAMljB,MAAM9E,SAAQ,SAACmE,EAAEzE,UAAYyE,EAAG2C,MAAQpH,UAC1CguB,IACCvQ,eAAc,GACdrY,MAAMkjB,EAAMljB,OACZC,MAAMijB,EAAMjjB,OACZgqB,kBAAiB,SAAU1mB,IACxBu0B,EAAav0B,GACFrH,OAAOhB,SAAQ,SAAAmE,UAAIA,EAAE8S,QAAU4lB,YAK9C79B,EAAIgpB,EAAMljB,MAAM/E,OAChBd,EAAQ,GACRuF,EAAKwjB,EAAMljB,MAAMoE,MAAM,UAC3B1E,EAAGxE,SAAQ,SAACmE,EAAGzE,UAAYyE,EAAG2C,MAAQpH,KACtCk9B,EAAW57B,OAAOhB,SAAQ,SAAAoD,OAClB05B,EAAY15B,EAAE0D,MAAQ1D,EAAErC,GAAK/B,EACjCwF,EAAGhF,KAAK4D,QACgB,IAAbA,EAAExC,QACTwC,EAAExC,OAAOZ,SAAQ,SAAAmE,UAAKlF,EAAMO,KAAK,CAAEZ,OAAQk+B,EAAWj+B,OAAQsF,EAAE2C,gBAC5C,IAAb1D,EAAEpC,QACToC,EAAEpC,OAAOhB,SAAQ,SAAAuxB,UAAMtyB,EAAMO,KAAK,CAAEZ,OAAQk+B,EAAWj+B,OAAQ0yB,EAAGxwB,GAAK/B,UAE/E49B,EAAW13B,WAAWlF,SAAQ,SAAAC,GAC1BhB,EAAMO,KAAK,CAAEZ,OAAQqB,EAAErB,OAAOkI,MAAOjI,OAAQoB,EAAEpB,OAAOiI,gBAItD4mB,IACCvZ,KAAKA,GACLrP,MAAMN,GACNO,MAAM9F,GACNke,eAAc,GACd6S,aAAa,IACbnqB,yBAAyB,GACzBuqB,qBAAqB,MACrB/a,MAAM,IAAK,EAAG,EAAG,GAAG,GAKlB,CACHmnB,MACI,IAAI9O,IACH0C,qBAAqB,MACrBjc,KAAKA,GACLgJ,eAAc,GACdrY,MAAMkjB,EAAMljB,OACZC,MAAMijB,EAAMjjB,OAEZ+qB,iBAAiB,MACjBE,aAAa,IACbnqB,yBAAyB,GACzBkpB,kBAAiB,SAAU1mB,IACxBu0B,EAAav0B,GACFrH,OAAOhB,SAAQ,SAAUmE,GAChCA,EAAE8S,QAAU4lB,QAEjBxnB,MAAM,GAAI,EAAG,IAAK,GAAG,GAC5BunB,WAAYA,2CjB+Z4BG,EAAkD1oB,EAAqBE,WAGzG/P,EAAiBu4B,EAAMz1B,KAAI,SAAApH,UAAK,IAAIqP,EAASrP,EAAE88B,kBAC/CjqB,EAAmB,GACnB/T,EAAI+9B,EAAMh9B,OACPL,EAAI,EAAGA,EAAIV,EAAI,EAAGU,IAEvBqT,EAAGvT,KAAK,IAAI0P,EAAW1K,EAAG9E,GAAI8E,EAAG9E,EAAI,IADxBq9B,EAAMr9B,GAC4ByU,KADhB4oB,EAAMr9B,EAAI,GACmByU,MAAQ,QAElE8oB,EAAWz4B,EAAG,GAChB04B,EAAY14B,EAAGxF,EAAI,GACnBm+B,EAAeJ,EAAM,GAAG5oB,KAAO,EAC/BipB,EAAgBL,EAAM/9B,EAAI,GAAGmV,KAAO,EACpCkpB,EAAmB,KAAMC,EAAmB,YAC5CjpB,IACAgpB,EAAS,IAAI9tB,EAAS8E,EAA8B,IAAlB4oB,EAAStuB,QAC3CnK,EAAGhF,KAAK69B,GACRtqB,EAAGvT,KAAK,IAAI0P,EAAWmuB,EAAQJ,EAAUE,KAEzC5oB,IACA+oB,EAAS,IAAI/tB,EAASgF,EAA+B,IAAnB2oB,EAAUvuB,QAC5CnK,EAAGhF,KAAK89B,GACRvqB,EAAGvT,KAAK,IAAI0P,EAAWguB,EAAWI,EAAQF,KAEjC,IAAIxqB,EAAOpO,EAAIuO,GACrBQ,QACA,CACHgqB,WAAY/4B,EAAG0E,MAAM,EAAG6zB,EAAMh9B,QAAQuH,KAAI,SAAAnD,UAAKA,EAAEmL,cACjD+E,WAAYgpB,EAASA,EAAO/tB,WAAa2tB,EAAS3tB,WAAa6tB,EAC/D5oB,WAAY+oB,EAASA,EAAOhuB,WAAa4tB,EAAU5tB,WAAa8tB,8BElKzC36B,OACvB+B,EAAK/B,EAAG6E,KAAI,SAAA2D,UAAK,IAAIsE,EAAStE,EAAEsM,SAChCxE,EAAK8J,EAAqBpa,EAAI+B,GAC9Bib,EAAS,IAAI7M,EAAOpO,EAAIuO,GAC5B0M,EAAOlM,QACP/O,EAAGxE,SAAQ,SAACmE,EAAGzE,UAAM+C,EAAG/C,GAAGqY,WAAW5T,EAAEmL,eACxC9K,EAAK/B,EAAG6E,KAAI,SAAA2D,UAAI,IAAIsE,EAAStE,EAAEuM,SAC/BzE,EAAK+J,EAAqBra,EAAI+B,IAC9Bib,EAAS,IAAI7M,EAAOpO,EAAIuO,IACjBQ,QACP/O,EAAGxE,SAAQ,SAACmE,EAAGzE,UAAM+C,EAAG/C,GAAGsY,WAAW7T,EAAEmL"}